<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - applications/FluidDynamicsApplication/custom_utilities/dynamic_smagorinsky_utilities.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">applications/FluidDynamicsApplication/custom_utilities</a> - dynamic_smagorinsky_utilities.h<span style="font-size: 80%;"> (source / <a href="dynamic_smagorinsky_utilities.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">135</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-10 04:44:37</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //    |  /           |</a>
<a name="2"><span class="lineNum">       2 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="3"><span class="lineNum">       3 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="4"><span class="lineNum">       4 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="5"><span class="lineNum">       5 </span>            : //                   Multi-Physics</a>
<a name="6"><span class="lineNum">       6 </span>            : //</a>
<a name="7"><span class="lineNum">       7 </span>            : //  License:         BSD License</a>
<a name="8"><span class="lineNum">       8 </span>            : //                   Kratos default license: kratos/license.txt</a>
<a name="9"><span class="lineNum">       9 </span>            : //</a>
<a name="10"><span class="lineNum">      10 </span>            : //  Main authors:    Jordi Cotela</a>
<a name="11"><span class="lineNum">      11 </span>            : //</a>
<a name="12"><span class="lineNum">      12 </span>            : </a>
<a name="13"><span class="lineNum">      13 </span>            : // System includes</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;vector&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;map&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : // External includes</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            : // Project includes</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &quot;includes/define.h&quot;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &quot;includes/node.h&quot;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;includes/element.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;utilities/openmp_utils.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;utilities/parallel_utilities.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &quot;utilities/geometry_utilities.h&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : </a>
<a name="28"><span class="lineNum">      28 </span>            : #include &quot;includes/cfd_variables.h&quot;</a>
<a name="29"><span class="lineNum">      29 </span>            : #include &quot;fluid_dynamics_application_variables.h&quot;</a>
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;includes/global_pointer_variables.h&quot;</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : #ifndef KRATOS_DYNAMIC_SMAGORINSKY_UTILITIES_H_INCLUDED</a>
<a name="33"><span class="lineNum">      33 </span>            : #define KRATOS_DYNAMIC_SMAGORINSKY_UTILITIES_H_INCLUDED</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : namespace Kratos</a>
<a name="36"><span class="lineNum">      36 </span>            : {</a>
<a name="37"><span class="lineNum">      37 </span>            : ///@addtogroup FluidDynamicsApplication</a>
<a name="38"><span class="lineNum">      38 </span>            : ///@{</a>
<a name="39"><span class="lineNum">      39 </span>            : </a>
<a name="40"><span class="lineNum">      40 </span>            : ///@name Kratos Classes</a>
<a name="41"><span class="lineNum">      41 </span>            : ///@{</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            : /// Helper class to dynamically determine a value for the Smagorinsly parameter.</a>
<a name="44"><span class="lineNum">      44 </span>            : /**</a>
<a name="45"><span class="lineNum">      45 </span>            :  This class uses the Variational Germano Identity to determine a value for the</a>
<a name="46"><span class="lineNum">      46 </span>            :  Smagorinsky parameter. This value is stored in the elemental variable C_SMAGORINSKY,</a>
<a name="47"><span class="lineNum">      47 </span>            :  the element implementation is responsible for using it. The ability to assign</a>
<a name="48"><span class="lineNum">      48 </span>            :  different values to different patches of elements (identified by the PATCH_INDEX</a>
<a name="49"><span class="lineNum">      49 </span>            :  variable) is supported, although it tends to produce unreliable results due to</a>
<a name="50"><span class="lineNum">      50 </span>            :  a 0/0 indetermination in patches with smooth velocity fields.</a>
<a name="51"><span class="lineNum">      51 </span>            : </a>
<a name="52"><span class="lineNum">      52 </span>            :  This class is based in Oberai, A.A. and Wanderer, J., Variational formulation</a>
<a name="53"><span class="lineNum">      53 </span>            :  of the Germano identity for the Navier Stokes equations, Journal of Turbulence,</a>
<a name="54"><span class="lineNum">      54 </span>            :  2005, vol 6. Note that the formulation described there requires a nested mesh.</a>
<a name="55"><span class="lineNum">      55 </span>            :  It takes the model part containing a coarse mesh as input and assumes that</a>
<a name="56"><span class="lineNum">      56 </span>            :  all elements will be subdivided before CalculateC() is called.</a>
<a name="57"><span class="lineNum">      57 </span>            : </a>
<a name="58"><span class="lineNum">      58 </span>            :  Remember to call StoreCoarseMesh before refining the element, otherwise the coarse mesh will be lost.</a>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<a name="60"><span class="lineNum">      60 </span>            :  @see VMS for an element implementation that uses the Smagorinsky model.</a>
<a name="61"><span class="lineNum">      61 </span>            :  @see Local_Refine_Triangle_Mesh,Local_Refine_Tetrahedra_Mesh for the element refinement process.</a>
<a name="62"><span class="lineNum">      62 </span>            :  */</a>
<a name="63"><span class="lineNum">      63 </span>            : class DynamicSmagorinskyUtils</a>
<a name="64"><span class="lineNum">      64 </span>            : {</a>
<a name="65"><span class="lineNum">      65 </span>            : public:</a>
<a name="66"><span class="lineNum">      66 </span>            : </a>
<a name="67"><span class="lineNum">      67 </span>            :     ///@name Life Cycle</a>
<a name="68"><span class="lineNum">      68 </span>            :     ///@{</a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span>            :     /// Constructor</a>
<a name="71"><span class="lineNum">      71 </span>            :     /**</a>
<a name="72"><span class="lineNum">      72 </span>            :      @param rModelPart Reference to the model part containing the coarse mesh</a>
<a name="73"><span class="lineNum">      73 </span>            :      @param DomainSize Spatial dimension (2 or 3)</a>
<a name="74"><span class="lineNum">      74 </span>            :      */</a>
<a name="75"><span class="lineNum">      75 </span><span class="lineNoCov">          0 :     DynamicSmagorinskyUtils(ModelPart&amp; rModelPart, unsigned int DomainSize):</span></a>
<a name="76"><span class="lineNum">      76 </span><span class="lineNoCov">          0 :         mrModelPart(rModelPart),</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineNoCov">          0 :         mDomainSize(DomainSize),</span></a>
<a name="78"><span class="lineNum">      78 </span>            :         mCoarseMesh(),</a>
<a name="79"><span class="lineNum">      79 </span>            :         mPatchIndices()</a>
<a name="80"><span class="lineNum">      80 </span>            :     {}</a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            :     /// Destructor</a>
<a name="83"><span class="lineNum">      83 </span><span class="lineNoCov">          0 :     ~DynamicSmagorinskyUtils() {}</span></a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            :     ///@}</a>
<a name="86"><span class="lineNum">      86 </span>            :     ///@name Operations</a>
<a name="87"><span class="lineNum">      87 </span>            :     ///@{</a>
<a name="88"><span class="lineNum">      88 </span>            : </a>
<a name="89"><span class="lineNum">      89 </span>            :     /// Store current mesh as coarse mesh. Call before refining.</a>
<a name="90"><span class="lineNum">      90 </span>            :     /**</a>
<a name="91"><span class="lineNum">      91 </span>            :      If you are refining more than once, this only has to be called before last refinement.</a>
<a name="92"><span class="lineNum">      92 </span>            :      */</a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :     void StoreCoarseMesh()</span></a>
<a name="94"><span class="lineNum">      94 </span>            :     {</a>
<a name="95"><span class="lineNum">      95 </span>            :         // Clear existing mesh (if any)</a>
<a name="96"><span class="lineNum">      96 </span>            :         mCoarseMesh.clear();</a>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<a name="98"><span class="lineNum">      98 </span>            :         // Store current mesh</a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :         for( ModelPart::ElementsContainerType::ptr_iterator itpElem = mrModelPart.Elements().ptr_begin();</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :                 itpElem != mrModelPart.Elements().ptr_end(); ++itpElem)</span></a>
<a name="101"><span class="lineNum">     101 </span>            :         {</a>
<a name="102"><span class="lineNum">     102 </span>            : //                (*itpElem)-&gt;GetValue(C_SMAGORINSKY) = 0.0; // Set the Smagorinsky parameter to zero for the coarse mesh (do this once to reset any input values)</a>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 :             mCoarseMesh.push_back(*itpElem);</span></a>
<a name="104"><span class="lineNum">     104 </span>            :         }</a>
<a name="105"><span class="lineNum">     105 </span>            : </a>
<a name="106"><span class="lineNum">     106 </span>            :         // Count the number of patches in the model (in parallel)</a>
<a name="107"><span class="lineNum">     107 </span><span class="lineNoCov">          0 :         const int NumThreads = ParallelUtilities::GetNumThreads();</span></a>
<a name="108"><span class="lineNum">     108 </span>            :         OpenMPUtils::PartitionVector ElementPartition;</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :         OpenMPUtils::DivideInPartitions(mCoarseMesh.size(),NumThreads,ElementPartition);</span></a>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<a name="111"><span class="lineNum">     111 </span><span class="lineNoCov">          0 :         std::vector&lt; std::vector&lt;int&gt; &gt; LocalIndices(NumThreads);</span></a>
<a name="112"><span class="lineNum">     112 </span>            : </a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :         #pragma omp parallel</span></a>
<a name="114"><span class="lineNum">     114 </span>            :         {</a>
<a name="115"><span class="lineNum">     115 </span>            :             int k = OpenMPUtils::ThisThread();</a>
<a name="116"><span class="lineNum">     116 </span>            :             ModelPart::ElementsContainerType::iterator ElemBegin = mCoarseMesh.begin() + ElementPartition[k];</a>
<a name="117"><span class="lineNum">     117 </span>            :             ModelPart::ElementsContainerType::iterator ElemEnd = mCoarseMesh.begin() + ElementPartition[k+1];</a>
<a name="118"><span class="lineNum">     118 </span>            : </a>
<a name="119"><span class="lineNum">     119 </span>            :             for( ModelPart::ElementIterator itElem = ElemBegin; itElem != ElemEnd; ++itElem)</a>
<a name="120"><span class="lineNum">     120 </span>            :             {</a>
<a name="121"><span class="lineNum">     121 </span>            :                 this-&gt;AddNewIndex(LocalIndices[k],itElem-&gt;GetValue(PATCH_INDEX));</a>
<a name="122"><span class="lineNum">     122 </span>            :             }</a>
<a name="123"><span class="lineNum">     123 </span>            :         }</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span>            :         // Combine the partial lists and create a map for PATCH_INDEX -&gt; Vector position</a>
<a name="126"><span class="lineNum">     126 </span>            :         unsigned int Counter = 0;</a>
<a name="127"><span class="lineNum">     127 </span><span class="lineNoCov">          0 :         std::pair&lt;int, unsigned int&gt; NewVal;</span></a>
<a name="128"><span class="lineNum">     128 </span>            :         std::pair&lt; std::map&lt;int, unsigned int&gt;::iterator, bool &gt; Result;</a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :         for( std::vector&lt; std::vector&lt;int&gt; &gt;::iterator itList = LocalIndices.begin(); itList != LocalIndices.end(); ++itList )</span></a>
<a name="130"><span class="lineNum">     130 </span>            :         {</a>
<a name="131"><span class="lineNum">     131 </span><span class="lineNoCov">          0 :             for( std::vector&lt;int&gt;::iterator itIndex = itList-&gt;begin(); itIndex != itList-&gt;end(); ++itIndex)</span></a>
<a name="132"><span class="lineNum">     132 </span>            :             {</a>
<a name="133"><span class="lineNum">     133 </span>            :                 // Note that instering in map already sorts and checks for uniqueness</a>
<a name="134"><span class="lineNum">     134 </span><span class="lineNoCov">          0 :                 NewVal.first = *itIndex;</span></a>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :                 NewVal.second = Counter;</span></a>
<a name="136"><span class="lineNum">     136 </span>            :                 Result = mPatchIndices.insert(NewVal);</a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :                 if (Result.second)</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :                     ++Counter;</span></a>
<a name="139"><span class="lineNum">     139 </span>            :             }</a>
<a name="140"><span class="lineNum">     140 </span>            :         }</a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="142"><span class="lineNum">     142 </span>            : </a>
<a name="143"><span class="lineNum">     143 </span>            :     /// Provide a value for the Smagorinsky coefficient using the Variational Germano Identity</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :     void CalculateC()</span></a>
<a name="145"><span class="lineNum">     145 </span>            :     {</a>
<a name="146"><span class="lineNum">     146 </span>            :         // Update the velocity values for the terms that belong to the coarse mesh</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :         this-&gt;SetCoarseVel();</span></a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            :         // Partitioning</a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :         const int NumThreads = ParallelUtilities::GetNumThreads();</span></a>
<a name="151"><span class="lineNum">     151 </span>            :         OpenMPUtils::PartitionVector CoarseElementPartition,FineElementPartition;</a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :         OpenMPUtils::DivideInPartitions(mCoarseMesh.size(),NumThreads,CoarseElementPartition);</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :         OpenMPUtils::DivideInPartitions(mrModelPart.Elements().size(),NumThreads,FineElementPartition);</span></a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :         // Initialize temporary containers</a>
<a name="156"><span class="lineNum">     156 </span><span class="lineNoCov">          0 :         unsigned int PatchNumber = mPatchIndices.size();</span></a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :         std::vector&lt; std::vector&lt;double&gt; &gt; GlobalPatchNum(NumThreads); // Numerator on each patch</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :         std::vector&lt; std::vector&lt;double&gt; &gt; GlobalPatchDen(NumThreads); // Denominator on each patch</span></a>
<a name="160"><span class="lineNum">     160 </span>            : </a>
<a name="161"><span class="lineNum">     161 </span>            :         const double EnergyTol = 0.005;</a>
<a name="162"><span class="lineNum">     162 </span>            :         double TotalDissipation = 0;</a>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :         #pragma omp parallel reduction(+:TotalDissipation)</span></a>
<a name="165"><span class="lineNum">     165 </span>            :         {</a>
<a name="166"><span class="lineNum">     166 </span>            :             int k = OpenMPUtils::ThisThread();</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            :             // Initialize the iterator boundaries for this thread</a>
<a name="169"><span class="lineNum">     169 </span>            :             ModelPart::ElementsContainerType::iterator CoarseElemBegin = mCoarseMesh.begin() + CoarseElementPartition[k];</a>
<a name="170"><span class="lineNum">     170 </span>            :             ModelPart::ElementsContainerType::iterator CoarseElemEnd = mCoarseMesh.begin() + CoarseElementPartition[k+1];</a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span>            :             ModelPart::ElementsContainerType::iterator FineElemBegin = mrModelPart.ElementsBegin() + FineElementPartition[k];</a>
<a name="173"><span class="lineNum">     173 </span>            :             ModelPart::ElementsContainerType::iterator FineElemEnd = mrModelPart.ElementsBegin() + FineElementPartition[k+1];</a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span>            :             // Initialize some thread-local variables</a>
<a name="176"><span class="lineNum">     176 </span>            :             Vector LocalValues, LocalCoarseVel;</a>
<a name="177"><span class="lineNum">     177 </span>            :             Matrix LocalMassMatrix;</a>
<a name="178"><span class="lineNum">     178 </span>            :             ProcessInfo&amp; rProcessInfo = mrModelPart.GetProcessInfo();</a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            :             double Residual,Model;</a>
<a name="181"><span class="lineNum">     181 </span>            :             unsigned int PatchPosition;</a>
<a name="182"><span class="lineNum">     182 </span>            : </a>
<a name="183"><span class="lineNum">     183 </span>            :             // Thread-local containers for the values in each patch</a>
<a name="184"><span class="lineNum">     184 </span>            :             std::vector&lt;double&gt;&amp; rPatchNum = GlobalPatchNum[k];</a>
<a name="185"><span class="lineNum">     185 </span>            :             std::vector&lt;double&gt;&amp; rPatchDen = GlobalPatchDen[k];</a>
<a name="186"><span class="lineNum">     186 </span>            :             rPatchNum.resize(PatchNumber,0.0);// Fill with zeros</a>
<a name="187"><span class="lineNum">     187 </span>            :             rPatchDen.resize(PatchNumber,0.0);</a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :             if (mDomainSize == 2)</a>
<a name="190"><span class="lineNum">     190 </span>            :             {</a>
<a name="191"><span class="lineNum">     191 </span>            :                 LocalValues.resize(9);</a>
<a name="192"><span class="lineNum">     192 </span>            :                 LocalCoarseVel.resize(9);</a>
<a name="193"><span class="lineNum">     193 </span>            :                 LocalMassMatrix.resize(9,9,false);</a>
<a name="194"><span class="lineNum">     194 </span>            :                 array_1d&lt;double,3&gt; N;</a>
<a name="195"><span class="lineNum">     195 </span>            :                 BoundedMatrix&lt;double,3,2&gt; DN_DX;</a>
<a name="196"><span class="lineNum">     196 </span>            :                 BoundedMatrix&lt;double,2,2&gt; dv_dx;</a>
<a name="197"><span class="lineNum">     197 </span>            : </a>
<a name="198"><span class="lineNum">     198 </span>            :                 // Evaluate the N-S and model terms in each coarse element</a>
<a name="199"><span class="lineNum">     199 </span>            :                 for( ModelPart::ElementsContainerType::iterator itElem = CoarseElemBegin; itElem != CoarseElemEnd; ++itElem)</a>
<a name="200"><span class="lineNum">     200 </span>            :                 {</a>
<a name="201"><span class="lineNum">     201 </span>            :                     PatchPosition = mPatchIndices[ itElem-&gt;GetValue(PATCH_INDEX) ];</a>
<a name="202"><span class="lineNum">     202 </span>            :                     this-&gt;GermanoTerms2D(*itElem,N,DN_DX,dv_dx,LocalValues,LocalCoarseVel,LocalMassMatrix,rProcessInfo,Residual,Model);</a>
<a name="203"><span class="lineNum">     203 </span>            : </a>
<a name="204"><span class="lineNum">     204 </span>            :                     rPatchNum[PatchPosition] += Residual;</a>
<a name="205"><span class="lineNum">     205 </span>            :                     rPatchDen[PatchPosition] += Model;</a>
<a name="206"><span class="lineNum">     206 </span>            :                     TotalDissipation += Residual;</a>
<a name="207"><span class="lineNum">     207 </span>            :                 }</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span>            :                 // Now evaluate the corresponding terms in the fine mesh</a>
<a name="210"><span class="lineNum">     210 </span>            :                 for( ModelPart::ElementsContainerType::iterator itElem = FineElemBegin; itElem != FineElemEnd; ++itElem)</a>
<a name="211"><span class="lineNum">     211 </span>            :                 {</a>
<a name="212"><span class="lineNum">     212 </span>            :                     // Deactivate Smagorinsky to compute the residual of galerkin+stabilization terms only</a>
<a name="213"><span class="lineNum">     213 </span>            :                     itElem-&gt;GetValue(C_SMAGORINSKY) = 0.0;</a>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<a name="215"><span class="lineNum">     215 </span>            :                     PatchPosition = mPatchIndices[ itElem-&gt;GetValue(PATCH_INDEX) ];</a>
<a name="216"><span class="lineNum">     216 </span>            :                     this-&gt;GermanoTerms2D(*itElem,N,DN_DX,dv_dx,LocalValues,LocalCoarseVel,LocalMassMatrix,rProcessInfo,Residual,Model);</a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span>            :                     rPatchNum[PatchPosition] -= Residual;</a>
<a name="219"><span class="lineNum">     219 </span>            :                     rPatchDen[PatchPosition] -= Model;</a>
<a name="220"><span class="lineNum">     220 </span>            :                 }</a>
<a name="221"><span class="lineNum">     221 </span>            :             }</a>
<a name="222"><span class="lineNum">     222 </span>            :             else // mDomainSize == 3</a>
<a name="223"><span class="lineNum">     223 </span>            :             {</a>
<a name="224"><span class="lineNum">     224 </span>            :                 LocalValues.resize(16);</a>
<a name="225"><span class="lineNum">     225 </span>            :                 LocalCoarseVel.resize(16);</a>
<a name="226"><span class="lineNum">     226 </span>            :                 LocalMassMatrix.resize(16,16,false);</a>
<a name="227"><span class="lineNum">     227 </span>            :                 array_1d&lt;double,4&gt; N;</a>
<a name="228"><span class="lineNum">     228 </span>            :                 BoundedMatrix&lt;double,4,3&gt; DN_DX;</a>
<a name="229"><span class="lineNum">     229 </span>            :                 BoundedMatrix&lt;double,3,3&gt; dv_dx;</a>
<a name="230"><span class="lineNum">     230 </span>            : </a>
<a name="231"><span class="lineNum">     231 </span>            :                 // Evaluate the N-S and model terms in each coarse element</a>
<a name="232"><span class="lineNum">     232 </span>            :                 for( ModelPart::ElementsContainerType::iterator itElem = CoarseElemBegin; itElem != CoarseElemEnd; ++itElem)</a>
<a name="233"><span class="lineNum">     233 </span>            :                 {</a>
<a name="234"><span class="lineNum">     234 </span>            :                     PatchPosition = mPatchIndices[ itElem-&gt;GetValue(PATCH_INDEX) ];</a>
<a name="235"><span class="lineNum">     235 </span>            :                     this-&gt;GermanoTerms3D(*itElem,N,DN_DX,dv_dx,LocalValues,LocalCoarseVel,LocalMassMatrix,rProcessInfo,Residual,Model);</a>
<a name="236"><span class="lineNum">     236 </span>            : </a>
<a name="237"><span class="lineNum">     237 </span>            :                     rPatchNum[PatchPosition] += Residual;</a>
<a name="238"><span class="lineNum">     238 </span>            :                     rPatchDen[PatchPosition] += Model;</a>
<a name="239"><span class="lineNum">     239 </span>            :                     TotalDissipation += Residual;</a>
<a name="240"><span class="lineNum">     240 </span>            :                 }</a>
<a name="241"><span class="lineNum">     241 </span>            : </a>
<a name="242"><span class="lineNum">     242 </span>            :                 // Now evaluate the corresponding terms in the fine mesh</a>
<a name="243"><span class="lineNum">     243 </span>            :                 for( ModelPart::ElementsContainerType::iterator itElem = FineElemBegin; itElem != FineElemEnd; ++itElem)</a>
<a name="244"><span class="lineNum">     244 </span>            :                 {</a>
<a name="245"><span class="lineNum">     245 </span>            :                     // Deactivate Smagorinsky to compute the residual of galerkin+stabilization terms only</a>
<a name="246"><span class="lineNum">     246 </span>            :                     itElem-&gt;GetValue(C_SMAGORINSKY) = 0.0;</a>
<a name="247"><span class="lineNum">     247 </span>            : </a>
<a name="248"><span class="lineNum">     248 </span>            :                     PatchPosition = mPatchIndices[ itElem-&gt;GetValue(PATCH_INDEX) ];</a>
<a name="249"><span class="lineNum">     249 </span>            :                     this-&gt;GermanoTerms3D(*itElem,N,DN_DX,dv_dx,LocalValues,LocalCoarseVel,LocalMassMatrix,rProcessInfo,Residual,Model);</a>
<a name="250"><span class="lineNum">     250 </span>            : </a>
<a name="251"><span class="lineNum">     251 </span>            :                     rPatchNum[PatchPosition] -= Residual;</a>
<a name="252"><span class="lineNum">     252 </span>            :                     rPatchDen[PatchPosition] -= Model;</a>
<a name="253"><span class="lineNum">     253 </span>            :                 }</a>
<a name="254"><span class="lineNum">     254 </span>            :             }</a>
<a name="255"><span class="lineNum">     255 </span>            :         }</a>
<a name="256"><span class="lineNum">     256 </span>            : </a>
<a name="257"><span class="lineNum">     257 </span>            :         // Combine the results of each thread in position 0</a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :         for( std::vector&lt; std::vector&lt;double&gt; &gt;::iterator itNum = GlobalPatchNum.begin()+1, itDen = GlobalPatchDen.begin()+1;</span></a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :                 itNum != GlobalPatchNum.end(); ++itNum, ++itDen)</span></a>
<a name="260"><span class="lineNum">     260 </span>            :         {</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 :             for( std::vector&lt;double&gt;::iterator TotalNum = GlobalPatchNum[0].begin(), LocalNum = itNum-&gt;begin(),</span></a>
<a name="262"><span class="lineNum">     262 </span>            :                     TotalDen = GlobalPatchDen[0].begin(), LocalDen = itDen-&gt;begin();</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :                     TotalNum != GlobalPatchNum[0].end(); ++TotalNum,++LocalNum,++TotalDen,++LocalDen)</span></a>
<a name="264"><span class="lineNum">     264 </span>            :             {</a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :                 *TotalNum += *LocalNum;</span></a>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :                 *TotalDen += *LocalDen;</span></a>
<a name="267"><span class="lineNum">     267 </span>            :             }</a>
<a name="268"><span class="lineNum">     268 </span>            :         }</a>
<a name="269"><span class="lineNum">     269 </span>            : </a>
<a name="270"><span class="lineNum">     270 </span>            :         // Compute the smagorinsky coefficient for each patch by combining the values from each thread</a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :         std::vector&lt;double&gt; PatchC(PatchNumber);</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineNoCov">          0 :         double NumTol = EnergyTol * fabs(TotalDissipation);</span></a>
<a name="273"><span class="lineNum">     273 </span><span class="lineNoCov">          0 :         for( std::vector&lt;double&gt;::iterator itNum = GlobalPatchNum[0].begin(), itDen = GlobalPatchDen[0].begin(), itC = PatchC.begin();</span></a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :                 itC != PatchC.end(); ++itNum, ++itDen, ++itC)</span></a>
<a name="275"><span class="lineNum">     275 </span>            :         {</a>
<a name="276"><span class="lineNum">     276 </span>            :             // If the dissipation we are &quot;missing&quot; by not considering Smagorinsky is small, do not use Smagorinsky (this avoids a division by ~0, as the denominator should go to zero too)</a>
<a name="277"><span class="lineNum">     277 </span><span class="lineNoCov">          0 :             if ( (fabs(*itNum) &lt; NumTol) )//|| (fabs(*itDen) &lt; 1.0e-12) )</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineNoCov">          0 :                 *itC = 0.0;</span></a>
<a name="279"><span class="lineNum">     279 </span>            :             else</a>
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :                 *itC = sqrt( 0.5 * fabs( *itNum / *itDen ) );</span></a>
<a name="281"><span class="lineNum">     281 </span>            :         }</a>
<a name="282"><span class="lineNum">     282 </span>            : </a>
<a name="283"><span class="lineNum">     283 </span>            :         // Finally, assign each element its new smagorinsky value</a>
<a name="284"><span class="lineNum">     284 </span><span class="lineNoCov">          0 :         #pragma omp parallel</span></a>
<a name="285"><span class="lineNum">     285 </span>            :         {</a>
<a name="286"><span class="lineNum">     286 </span>            :             int k = OpenMPUtils::ThisThread();</a>
<a name="287"><span class="lineNum">     287 </span>            :             ModelPart::ElementsContainerType::iterator ElemBegin = mrModelPart.ElementsBegin() + FineElementPartition[k];</a>
<a name="288"><span class="lineNum">     288 </span>            :             ModelPart::ElementsContainerType::iterator ElemEnd = mrModelPart.ElementsBegin() + FineElementPartition[k+1];</a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span>            :             unsigned int PatchPosition;</a>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<a name="292"><span class="lineNum">     292 </span>            :             for( ModelPart::ElementIterator itElem = ElemBegin; itElem != ElemEnd; ++itElem)</a>
<a name="293"><span class="lineNum">     293 </span>            :             {</a>
<a name="294"><span class="lineNum">     294 </span>            :                 PatchPosition = mPatchIndices[ itElem-&gt;GetValue(PATCH_INDEX) ];</a>
<a name="295"><span class="lineNum">     295 </span>            :                 itElem-&gt;GetValue(C_SMAGORINSKY) = PatchC[PatchPosition];</a>
<a name="296"><span class="lineNum">     296 </span>            :             }</a>
<a name="297"><span class="lineNum">     297 </span>            :         }</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span>            :     /// For the bridge analysis problem, correct the boundary flag after the refinement.</a>
<a name="301"><span class="lineNum">     301 </span>            :     /**</a>
<a name="302"><span class="lineNum">     302 </span>            :      Remember to run this AFTER EACH REFINEMENT STEP</a>
<a name="303"><span class="lineNum">     303 </span>            :      Possible values for the variable: 1.0 inlet, 2.0 bridge surface, 3.0 outlet, 0.0 otherwise</a>
<a name="304"><span class="lineNum">     304 </span>            :      @param rThisVariable The Kratos variable used to identify the boundary</a>
<a name="305"><span class="lineNum">     305 </span>            :      */</a>
<a name="306"><span class="lineNum">     306 </span><span class="lineNoCov">          0 :     void CorrectFlagValues(Variable&lt;double&gt;&amp; rThisVariable = FLAG_VARIABLE)</span></a>
<a name="307"><span class="lineNum">     307 </span>            :     {</a>
<a name="308"><span class="lineNum">     308 </span>            :         // Loop over coarse mesh to evaluate all terms that do not involve the fine mesh</a>
<a name="309"><span class="lineNum">     309 </span><span class="lineNoCov">          0 :         const int NumThreads = ParallelUtilities::GetNumThreads();</span></a>
<a name="310"><span class="lineNum">     310 </span>            :         OpenMPUtils::PartitionVector NodePartition;</a>
<a name="311"><span class="lineNum">     311 </span><span class="lineNoCov">          0 :         OpenMPUtils::DivideInPartitions(mrModelPart.NumberOfNodes(),NumThreads,NodePartition);</span></a>
<a name="312"><span class="lineNum">     312 </span>            : </a>
<a name="313"><span class="lineNum">     313 </span><span class="lineNoCov">          0 :         #pragma omp parallel</span></a>
<a name="314"><span class="lineNum">     314 </span>            :         {</a>
<a name="315"><span class="lineNum">     315 </span>            :             int k = OpenMPUtils::ThisThread();</a>
<a name="316"><span class="lineNum">     316 </span>            :             ModelPart::NodeIterator NodesBegin = mrModelPart.NodesBegin() + NodePartition[k];</a>
<a name="317"><span class="lineNum">     317 </span>            :             ModelPart::NodeIterator NodesEnd = mrModelPart.NodesBegin() + NodePartition[k+1];</a>
<a name="318"><span class="lineNum">     318 </span>            : </a>
<a name="319"><span class="lineNum">     319 </span>            :             double Value0, Value1;</a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span>            :             for( ModelPart::NodeIterator itNode = NodesBegin; itNode != NodesEnd; ++itNode)</a>
<a name="322"><span class="lineNum">     322 </span>            :             {</a>
<a name="323"><span class="lineNum">     323 </span>            :                 if( itNode-&gt;GetValue(FATHER_NODES).size() == 2 ) // If the node is refined</a>
<a name="324"><span class="lineNum">     324 </span>            :                 {</a>
<a name="325"><span class="lineNum">     325 </span>            :                     Value0 = itNode-&gt;GetValue(FATHER_NODES)[0].FastGetSolutionStepValue(rThisVariable);</a>
<a name="326"><span class="lineNum">     326 </span>            :                     Value1 = itNode-&gt;GetValue(FATHER_NODES)[1].FastGetSolutionStepValue(rThisVariable);</a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            :                     if( Value0 != Value1 ) // If this node is problematic</a>
<a name="329"><span class="lineNum">     329 </span>            :                     {</a>
<a name="330"><span class="lineNum">     330 </span>            :                         if ( Value0 == 0.0 || Value1 == 0.0 )</a>
<a name="331"><span class="lineNum">     331 </span>            :                         {</a>
<a name="332"><span class="lineNum">     332 </span>            :                             // if either of the parents is not on the boundary, this node is not on the boundary</a>
<a name="333"><span class="lineNum">     333 </span>            :                             itNode-&gt;FastGetSolutionStepValue(rThisVariable) = 0.0;</a>
<a name="334"><span class="lineNum">     334 </span>            :                         }</a>
<a name="335"><span class="lineNum">     335 </span>            :                         /* All remaining cases are unlikely in well-posed problems,</a>
<a name="336"><span class="lineNum">     336 </span>            :                          I'm arbitrarily giving priority to the outlet,</a>
<a name="337"><span class="lineNum">     337 </span>            :                          so that the node is only inlet or bridge surface if both parents are</a>
<a name="338"><span class="lineNum">     338 </span>            :                          */</a>
<a name="339"><span class="lineNum">     339 </span>            :                         else if( Value0 == 3.0 )</a>
<a name="340"><span class="lineNum">     340 </span>            :                         {</a>
<a name="341"><span class="lineNum">     341 </span>            :                             itNode-&gt;FastGetSolutionStepValue(rThisVariable) = Value0;</a>
<a name="342"><span class="lineNum">     342 </span>            :                         }</a>
<a name="343"><span class="lineNum">     343 </span>            :                         else if( Value1 == 3.0 )</a>
<a name="344"><span class="lineNum">     344 </span>            :                         {</a>
<a name="345"><span class="lineNum">     345 </span>            :                             // The node is only bridge surface if both parents are</a>
<a name="346"><span class="lineNum">     346 </span>            :                             itNode-&gt;FastGetSolutionStepValue(rThisVariable) = Value1;</a>
<a name="347"><span class="lineNum">     347 </span>            :                         }</a>
<a name="348"><span class="lineNum">     348 </span>            :                         else // Default behaviour: Parent 0 takes precedence</a>
<a name="349"><span class="lineNum">     349 </span>            :                         {</a>
<a name="350"><span class="lineNum">     350 </span>            :                             itNode-&gt;FastGetSolutionStepValue(rThisVariable) = Value0;</a>
<a name="351"><span class="lineNum">     351 </span>            :                         }</a>
<a name="352"><span class="lineNum">     352 </span>            :                     }</a>
<a name="353"><span class="lineNum">     353 </span>            :                 }</a>
<a name="354"><span class="lineNum">     354 </span>            :             }</a>
<a name="355"><span class="lineNum">     355 </span>            :         }</a>
<a name="356"><span class="lineNum">     356 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<a name="358"><span class="lineNum">     358 </span>            :     ///@}</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span>            : private:</a>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span>            :     ///@name Member Variables</a>
<a name="363"><span class="lineNum">     363 </span>            :     ///@{</a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            :     /// ModelPart of the fluid problem</a>
<a name="366"><span class="lineNum">     366 </span>            :     ModelPart&amp; mrModelPart;</a>
<a name="367"><span class="lineNum">     367 </span>            :     /// Spatial dimenstion</a>
<a name="368"><span class="lineNum">     368 </span>            :     unsigned int mDomainSize;</a>
<a name="369"><span class="lineNum">     369 </span>            :     /// Container for the coarse mesh (the fine mesh is stored by the model part)</a>
<a name="370"><span class="lineNum">     370 </span>            :     ModelPart::ElementsContainerType mCoarseMesh;</a>
<a name="371"><span class="lineNum">     371 </span>            :     /// A map relating patch indices to positions in the internal storage arrays</a>
<a name="372"><span class="lineNum">     372 </span>            :     std::map&lt;int, unsigned int&gt; mPatchIndices;</a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            :     ///@name Private Operations</a>
<a name="375"><span class="lineNum">     375 </span>            :     ///@{</a>
<a name="376"><span class="lineNum">     376 </span>            : </a>
<a name="377"><span class="lineNum">     377 </span>            :     /// Calculate the &quot;Coarse Mesh&quot; velocity</a>
<a name="378"><span class="lineNum">     378 </span>            :     /**</a>
<a name="379"><span class="lineNum">     379 </span>            :      The operations on the coarse mesh are evaluated on the fine mesh, but using an averaged velocity on the nodes that only exist on the fine mesh.</a>
<a name="380"><span class="lineNum">     380 </span>            :      Velocity gradients calculated on the fine mesh using this average velocity will be equal to those that would be obtained using the coarse mesh.</a>
<a name="381"><span class="lineNum">     381 </span>            :      This function assigns the &quot;coarse&quot; velocity value to all nodes</a>
<a name="382"><span class="lineNum">     382 </span>            :      */</a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :     void SetCoarseVel()</span></a>
<a name="384"><span class="lineNum">     384 </span>            :     {</a>
<a name="385"><span class="lineNum">     385 </span>            :         /*</a>
<a name="386"><span class="lineNum">     386 </span>            :          Note: This loop can't be parallelized, as we are relying on the fact that refined nodes are at the end of the list and their parents will be updated before the refined nodes</a>
<a name="387"><span class="lineNum">     387 </span>            :          are reached. There is an alternative solution (always calculate the coarse mesh velocity from the historic database) which can be parallelized but won't work for multiple</a>
<a name="388"><span class="lineNum">     388 </span>            :          levels of refinement</a>
<a name="389"><span class="lineNum">     389 </span>            :          */</a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :         for( ModelPart::NodeIterator itNode = mrModelPart.NodesBegin(); itNode != mrModelPart.NodesEnd(); ++itNode)</span></a>
<a name="391"><span class="lineNum">     391 </span>            :         {</a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :             if( itNode-&gt;GetValue(FATHER_NODES).size() == 2 )</span></a>
<a name="393"><span class="lineNum">     393 </span>            :             {</a>
<a name="394"><span class="lineNum">     394 </span>            :                 Node&lt;3&gt;&amp; rParent1 = itNode-&gt;GetValue(FATHER_NODES)[0];</a>
<a name="395"><span class="lineNum">     395 </span>            :                 Node&lt;3&gt;&amp; rParent2 = itNode-&gt;GetValue(FATHER_NODES)[1];</a>
<a name="396"><span class="lineNum">     396 </span>            : </a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 itNode-&gt;GetValue(COARSE_VELOCITY) = 0.5 * ( rParent1.FastGetSolutionStepValue(VELOCITY) + rParent2.FastGetSolutionStepValue(VELOCITY) );</span></a>
<a name="398"><span class="lineNum">     398 </span>            :             }</a>
<a name="399"><span class="lineNum">     399 </span>            :             else</a>
<a name="400"><span class="lineNum">     400 </span>            :             {</a>
<a name="401"><span class="lineNum">     401 </span>            :                 itNode-&gt;GetValue(COARSE_VELOCITY) = itNode-&gt;FastGetSolutionStepValue(VELOCITY);</a>
<a name="402"><span class="lineNum">     402 </span>            :             }</a>
<a name="403"><span class="lineNum">     403 </span>            :         }</a>
<a name="404"><span class="lineNum">     404 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<a name="406"><span class="lineNum">     406 </span>            :     /// Return the Galerkin (+stabilization) and Model terms for this element (2D version)</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 :     void GermanoTerms2D(Element&amp; rElem,</span></a>
<a name="408"><span class="lineNum">     408 </span>            :                         array_1d&lt;double,3&gt;&amp; rShapeFunc,</a>
<a name="409"><span class="lineNum">     409 </span>            :                         BoundedMatrix&lt;double,3,2&gt;&amp; rShapeDeriv,</a>
<a name="410"><span class="lineNum">     410 </span>            :                         BoundedMatrix&lt;double,2,2&gt;&amp; rGradient,</a>
<a name="411"><span class="lineNum">     411 </span>            :                         Vector&amp; rNodalResidualContainer,</a>
<a name="412"><span class="lineNum">     412 </span>            :                         Vector&amp; rNodalVelocityContainer,</a>
<a name="413"><span class="lineNum">     413 </span>            :                         Matrix&amp; rMassMatrix,</a>
<a name="414"><span class="lineNum">     414 </span>            :                         ProcessInfo&amp; rProcessInfo,</a>
<a name="415"><span class="lineNum">     415 </span>            :                         double&amp; rResidual,</a>
<a name="416"><span class="lineNum">     416 </span>            :                         double&amp; rModel)</a>
<a name="417"><span class="lineNum">     417 </span>            :     {</a>
<a name="418"><span class="lineNum">     418 </span>            :         const double Dim = 2;</a>
<a name="419"><span class="lineNum">     419 </span>            :         const double NumNodes = 3;</a>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<a name="421"><span class="lineNum">     421 </span>            :         // Initialize</a>
<a name="422"><span class="lineNum">     422 </span>            :         double Area;</a>
<a name="423"><span class="lineNum">     423 </span>            :         double Density = 0.0;</a>
<a name="424"><span class="lineNum">     424 </span>            :         rGradient = ZeroMatrix(Dim,Dim);</a>
<a name="425"><span class="lineNum">     425 </span>            : </a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :         rResidual = 0.0;</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :         rModel = 0.0;</span></a>
<a name="428"><span class="lineNum">     428 </span>            : </a>
<a name="429"><span class="lineNum">     429 </span>            :         // Calculate the residual</a>
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :         this-&gt;CalculateResidual(rElem,rMassMatrix,rNodalVelocityContainer,rNodalResidualContainer,rProcessInfo); // We use rNodalVelocityContainer as an auxiliaty variable</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :         this-&gt;GetCoarseVelocity2D(rElem,rNodalVelocityContainer);</span></a>
<a name="432"><span class="lineNum">     432 </span>            : </a>
<a name="433"><span class="lineNum">     433 </span><span class="lineNoCov">          0 :         for( Vector::iterator itRHS = rNodalResidualContainer.begin(), itVel = rNodalVelocityContainer.begin(); itRHS != rNodalResidualContainer.end(); ++itRHS, ++itVel)</span></a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 :             rResidual += (*itVel) * (*itRHS);</span></a>
<a name="435"><span class="lineNum">     435 </span>            : </a>
<a name="436"><span class="lineNum">     436 </span>            :         // Calculate the model term</a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :         GeometryUtils::CalculateGeometryData( rElem.GetGeometry(), rShapeDeriv, rShapeFunc, Area);</span></a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span>            :         // Compute Grad(u), Density and &lt; Grad(w), Grad(u) &gt;</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j &lt; NumNodes; ++j) // Columns of &lt;Grad(Ni),Grad(Nj)&gt;</span></a>
<a name="441"><span class="lineNum">     441 </span>            :         {</a>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 :             Density += rShapeFunc[j] * rElem.GetGeometry()[j].FastGetSolutionStepValue(DENSITY);</span></a>
<a name="443"><span class="lineNum">     443 </span>            :             const array_1d&lt; double,3 &gt;&amp; rNodeVel = rElem.GetGeometry()[j].FastGetSolutionStepValue(VELOCITY); // Nodal velocity</a>
<a name="444"><span class="lineNum">     444 </span>            : </a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :             for (unsigned int i = 0; i &lt; NumNodes; ++i) // Rows of &lt;Grad(Ni),Grad(Nj)&gt;</span></a>
<a name="446"><span class="lineNum">     446 </span>            :             {</a>
<a name="447"><span class="lineNum">     447 </span><span class="lineNoCov">          0 :                 const array_1d&lt; double,3 &gt;&amp; rNodeTest = rElem.GetGeometry()[i].GetValue(COARSE_VELOCITY); // Test function (particularized to coarse velocity)</span></a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :                 for (unsigned int k = 0; k &lt; Dim; ++k) // Space Dimensions</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineNoCov">          0 :                     rModel += rNodeTest[k] * rShapeDeriv(i,k) * rShapeDeriv(j,k) * rNodeVel[k];</span></a>
<a name="451"><span class="lineNum">     451 </span>            :             }</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span><span class="lineNoCov">          0 :             for (unsigned int m = 0; m &lt; Dim; ++m) // Calculate symmetric gradient</span></a>
<a name="454"><span class="lineNum">     454 </span>            :             {</a>
<a name="455"><span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 for (unsigned int n = 0; n &lt; m; ++n) // Off-diagonal</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 :                     rGradient(m,n) += 0.5 * (rShapeDeriv(j,n) * rNodeVel[m] + rShapeDeriv(j,m) * rNodeVel[n]); // Symmetric gradient, only lower half is written</span></a>
<a name="457"><span class="lineNum">     457 </span><span class="lineNoCov">          0 :                 rGradient(m,m) += rShapeDeriv(j,m) * rNodeVel[m]; // Diagonal</span></a>
<a name="458"><span class="lineNum">     458 </span>            :             }</a>
<a name="459"><span class="lineNum">     459 </span>            :         }</a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span><span class="lineNoCov">          0 :         rModel *= Area; // To this point, rModel contains the integral over the element of Grad(U_coarse):Grad(U)</span></a>
<a name="462"><span class="lineNum">     462 </span>            : </a>
<a name="463"><span class="lineNum">     463 </span>            :         // Norm[ Grad(u) ]</a>
<a name="464"><span class="lineNum">     464 </span>            :         double SqNorm = 0.0;</a>
<a name="465"><span class="lineNum">     465 </span><span class="lineNoCov">          0 :         for (unsigned int i = 0; i &lt; Dim; ++i)</span></a>
<a name="466"><span class="lineNum">     466 </span>            :         {</a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :             for (unsigned int j = 0; j &lt; i; ++j)</span></a>
<a name="468"><span class="lineNum">     468 </span><span class="lineNoCov">          0 :                 SqNorm += 2.0 * rGradient(i,j) * rGradient(i,j); // Adding off-diagonal terms (twice, as matrix is symmetric)</span></a>
<a name="469"><span class="lineNum">     469 </span><span class="lineNoCov">          0 :             SqNorm += rGradient(i,i) * rGradient(i,i); // Diagonal terms</span></a>
<a name="470"><span class="lineNum">     470 </span>            :         }</a>
<a name="471"><span class="lineNum">     471 </span>            : </a>
<a name="472"><span class="lineNum">     472 </span>            :         // &quot;Fixed&quot; part of Smagorinsky viscosity: Density * FilterWidth^2 * Norm(SymmetricGrad(U)). 2*C^2 is accounted for in the caller function</a>
<a name="473"><span class="lineNum">     473 </span><span class="lineNoCov">          0 :         const double sqH = 2*Area;</span></a>
<a name="474"><span class="lineNum">     474 </span><span class="lineNoCov">          0 :         rModel *= Density * sqH * sqrt(SqNorm);</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="476"><span class="lineNum">     476 </span>            : </a>
<a name="477"><span class="lineNum">     477 </span>            :     /// Return the Galerkin (+stabilization) and Model terms for this element (3D version)</a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :     void GermanoTerms3D(Element&amp; rElem,</span></a>
<a name="479"><span class="lineNum">     479 </span>            :                         array_1d&lt;double,4&gt;&amp; rShapeFunc,</a>
<a name="480"><span class="lineNum">     480 </span>            :                         BoundedMatrix&lt;double,4,3&gt;&amp; rShapeDeriv,</a>
<a name="481"><span class="lineNum">     481 </span>            :                         BoundedMatrix&lt;double,3,3&gt;&amp; rGradient,</a>
<a name="482"><span class="lineNum">     482 </span>            :                         Vector&amp; rNodalResidualContainer,</a>
<a name="483"><span class="lineNum">     483 </span>            :                         Vector&amp; rNodalVelocityContainer,</a>
<a name="484"><span class="lineNum">     484 </span>            :                         Matrix&amp; rMassMatrix,</a>
<a name="485"><span class="lineNum">     485 </span>            :                         ProcessInfo&amp; rProcessInfo,</a>
<a name="486"><span class="lineNum">     486 </span>            :                         double&amp; rResidual,</a>
<a name="487"><span class="lineNum">     487 </span>            :                         double&amp; rModel)</a>
<a name="488"><span class="lineNum">     488 </span>            :     {</a>
<a name="489"><span class="lineNum">     489 </span>            :         const double Dim = 3;</a>
<a name="490"><span class="lineNum">     490 </span>            :         const double NumNodes = 4;</a>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<a name="492"><span class="lineNum">     492 </span>            :         // Initialize</a>
<a name="493"><span class="lineNum">     493 </span>            :         double Volume;</a>
<a name="494"><span class="lineNum">     494 </span>            :         double Density = 0.0;</a>
<a name="495"><span class="lineNum">     495 </span>            :         rGradient = ZeroMatrix(Dim,Dim);</a>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<a name="497"><span class="lineNum">     497 </span><span class="lineNoCov">          0 :         rResidual = 0.0;</span></a>
<a name="498"><span class="lineNum">     498 </span><span class="lineNoCov">          0 :         rModel = 0.0;</span></a>
<a name="499"><span class="lineNum">     499 </span>            : </a>
<a name="500"><span class="lineNum">     500 </span>            :         // Calculate the residual</a>
<a name="501"><span class="lineNum">     501 </span><span class="lineNoCov">          0 :         this-&gt;CalculateResidual(rElem,rMassMatrix,rNodalVelocityContainer,rNodalResidualContainer,rProcessInfo); // We use rNodalVelocityContainer as an auxiliaty variable</span></a>
<a name="502"><span class="lineNum">     502 </span><span class="lineNoCov">          0 :         this-&gt;GetCoarseVelocity3D(rElem,rNodalVelocityContainer);</span></a>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<a name="504"><span class="lineNum">     504 </span><span class="lineNoCov">          0 :         for( Vector::iterator itRHS = rNodalResidualContainer.begin(), itVel = rNodalVelocityContainer.begin(); itRHS != rNodalResidualContainer.end(); ++itRHS, ++itVel)</span></a>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 :             rResidual += (*itVel) * (*itRHS);</span></a>
<a name="506"><span class="lineNum">     506 </span>            : </a>
<a name="507"><span class="lineNum">     507 </span>            :         // Calculate the model term</a>
<a name="508"><span class="lineNum">     508 </span><span class="lineNoCov">          0 :         GeometryUtils::CalculateGeometryData( rElem.GetGeometry(), rShapeDeriv, rShapeFunc, Volume);</span></a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span>            :         // Compute Grad(u), Density and &lt; Grad(w), Grad(u) &gt;</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j &lt; NumNodes; ++j) // Columns of &lt;Grad(Ni),Grad(Nj)&gt;</span></a>
<a name="512"><span class="lineNum">     512 </span>            :         {</a>
<a name="513"><span class="lineNum">     513 </span><span class="lineNoCov">          0 :             Density += rShapeFunc[j] * rElem.GetGeometry()[j].FastGetSolutionStepValue(DENSITY);</span></a>
<a name="514"><span class="lineNum">     514 </span>            :             const array_1d&lt; double,3 &gt;&amp; rNodeVel = rElem.GetGeometry()[j].FastGetSolutionStepValue(VELOCITY); // Nodal velocity</a>
<a name="515"><span class="lineNum">     515 </span>            : </a>
<a name="516"><span class="lineNum">     516 </span><span class="lineNoCov">          0 :             for (unsigned int i = 0; i &lt; NumNodes; ++i) // Rows of &lt;Grad(Ni),Grad(Nj)&gt;</span></a>
<a name="517"><span class="lineNum">     517 </span>            :             {</a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :                 const array_1d&lt; double,3 &gt;&amp; rNodeTest = rElem.GetGeometry()[i].GetValue(COARSE_VELOCITY); // Test function (particularized to coarse velocity)</span></a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span><span class="lineNoCov">          0 :                 for (unsigned int k = 0; k &lt; Dim; ++k) // Space Dimensions</span></a>
<a name="521"><span class="lineNum">     521 </span><span class="lineNoCov">          0 :                     rModel += rNodeTest[k] * rShapeDeriv(i,k) * rShapeDeriv(j,k) * rNodeVel[k];</span></a>
<a name="522"><span class="lineNum">     522 </span>            :             }</a>
<a name="523"><span class="lineNum">     523 </span>            : </a>
<a name="524"><span class="lineNum">     524 </span><span class="lineNoCov">          0 :             for (unsigned int m = 0; m &lt; Dim; ++m) // Calculate symmetric gradient</span></a>
<a name="525"><span class="lineNum">     525 </span>            :             {</a>
<a name="526"><span class="lineNum">     526 </span><span class="lineNoCov">          0 :                 for (unsigned int n = 0; n &lt; m; ++n) // Off-diagonal</span></a>
<a name="527"><span class="lineNum">     527 </span><span class="lineNoCov">          0 :                     rGradient(m,n) += 0.5 * (rShapeDeriv(j,n) * rNodeVel[m] + rShapeDeriv(j,m) * rNodeVel[n]); // Symmetric gradient, only lower half is written</span></a>
<a name="528"><span class="lineNum">     528 </span><span class="lineNoCov">          0 :                 rGradient(m,m) += rShapeDeriv(j,m) * rNodeVel[m]; // Diagonal</span></a>
<a name="529"><span class="lineNum">     529 </span>            :             }</a>
<a name="530"><span class="lineNum">     530 </span>            :         }</a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span><span class="lineNoCov">          0 :         rModel *= Volume; // To this point, rModel contains the integral over the element of Grad(U_coarse):Grad(U)</span></a>
<a name="533"><span class="lineNum">     533 </span>            : </a>
<a name="534"><span class="lineNum">     534 </span>            :         // Norm[ Symmetric Grad(u) ] = ( 2 * Sij * Sij )^(1/2), we compute the Sij * Sij part in the following loop:</a>
<a name="535"><span class="lineNum">     535 </span>            :         double SqNorm = 0.0;</a>
<a name="536"><span class="lineNum">     536 </span><span class="lineNoCov">          0 :         for (unsigned int i = 0; i &lt; Dim; ++i)</span></a>
<a name="537"><span class="lineNum">     537 </span>            :         {</a>
<a name="538"><span class="lineNum">     538 </span><span class="lineNoCov">          0 :             for (unsigned int j = 0; j &lt; i; ++j)</span></a>
<a name="539"><span class="lineNum">     539 </span><span class="lineNoCov">          0 :                 SqNorm += 2.0 * rGradient(i,j) * rGradient(i,j); // Adding off-diagonal terms (twice, as matrix is symmetric)</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineNoCov">          0 :             SqNorm += rGradient(i,i) * rGradient(i,i); // Diagonal terms</span></a>
<a name="541"><span class="lineNum">     541 </span>            :         }</a>
<a name="542"><span class="lineNum">     542 </span>            : </a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 :         const double cubeH = 6*Volume;</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineNoCov">          0 :         rModel *= Density * pow(cubeH, 2.0/3.0) * sqrt(2.0 * SqNorm);</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="546"><span class="lineNum">     546 </span>            : </a>
<a name="547"><span class="lineNum">     547 </span>            :     /// Equivalent to VMS2DSmagorinsky::GetFirstDerivativesVector(), using the velocity evaluated on the coarse mesh</a>
<a name="548"><span class="lineNum">     548 </span><span class="lineNoCov">          0 :     void GetCoarseVelocity2D(Element&amp; rElement,</span></a>
<a name="549"><span class="lineNum">     549 </span>            :                              Vector&amp; rVar)</a>
<a name="550"><span class="lineNum">     550 </span>            :     {</a>
<a name="551"><span class="lineNum">     551 </span>            :         unsigned int LocalIndex = 0;</a>
<a name="552"><span class="lineNum">     552 </span>            :         const Element::GeometryType&amp; rGeom = rElement.GetGeometry();</a>
<a name="553"><span class="lineNum">     553 </span>            : </a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :         for (unsigned int itNode = 0; itNode &lt; 3; ++itNode)</span></a>
<a name="555"><span class="lineNum">     555 </span>            :         {</a>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 :             const array_1d&lt; double,3&gt;&amp; rCoarseVel = rGeom[itNode].GetValue(COARSE_VELOCITY);</span></a>
<a name="557"><span class="lineNum">     557 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = rCoarseVel[0];</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = rCoarseVel[1];</span></a>
<a name="559"><span class="lineNum">     559 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = 0.0; // Pressure Dof</span></a>
<a name="560"><span class="lineNum">     560 </span>            :         }</a>
<a name="561"><span class="lineNum">     561 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<a name="563"><span class="lineNum">     563 </span>            :     /// Equivalent to VMS3DSmagorinsky::GetFirstDerivativesVector(), using the velocity evaluated on the coarse mesh</a>
<a name="564"><span class="lineNum">     564 </span><span class="lineNoCov">          0 :     void GetCoarseVelocity3D(Element&amp; rElement,</span></a>
<a name="565"><span class="lineNum">     565 </span>            :                              Vector&amp; rVar)</a>
<a name="566"><span class="lineNum">     566 </span>            :     {</a>
<a name="567"><span class="lineNum">     567 </span>            :         unsigned int LocalIndex = 0;</a>
<a name="568"><span class="lineNum">     568 </span>            :         const Element::GeometryType&amp; rGeom = rElement.GetGeometry();</a>
<a name="569"><span class="lineNum">     569 </span>            : </a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :         for (unsigned int itNode = 0; itNode &lt; 4; ++itNode)</span></a>
<a name="571"><span class="lineNum">     571 </span>            :         {</a>
<a name="572"><span class="lineNum">     572 </span><span class="lineNoCov">          0 :             const array_1d&lt; double,3&gt;&amp; rCoarseVel = rGeom[itNode].GetValue(COARSE_VELOCITY);</span></a>
<a name="573"><span class="lineNum">     573 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = rCoarseVel[0];</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = rCoarseVel[1];</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = rCoarseVel[2];</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineNoCov">          0 :             rVar[LocalIndex++] = 0.0; // Pressure Dof</span></a>
<a name="577"><span class="lineNum">     577 </span>            :         }</a>
<a name="578"><span class="lineNum">     578 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="579"><span class="lineNum">     579 </span>            : </a>
<a name="580"><span class="lineNum">     580 </span>            :     /// Call the element's member functions to obtain its residual</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineNoCov">          0 :     void CalculateResidual(Element&amp; rElement,</span></a>
<a name="582"><span class="lineNum">     582 </span>            :                            Matrix&amp; rMassMatrix, ///@todo This matrix and the next vector should be transformed to static members once we find a threadsafe way to do so</a>
<a name="583"><span class="lineNum">     583 </span>            :                            Vector&amp; rAuxVector,</a>
<a name="584"><span class="lineNum">     584 </span>            :                            Vector&amp; rResidual,</a>
<a name="585"><span class="lineNum">     585 </span>            :                            const ProcessInfo&amp; rCurrentProcessInfo)</a>
<a name="586"><span class="lineNum">     586 </span>            :     {</a>
<a name="587"><span class="lineNum">     587 </span>            :         const auto&amp; r_const_elem_ref = rElement;</a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :         rElement.InitializeNonLinearIteration(rCurrentProcessInfo);</span></a>
<a name="589"><span class="lineNum">     589 </span>            : </a>
<a name="590"><span class="lineNum">     590 </span>            :         // Dynamic stabilization terms</a>
<a name="591"><span class="lineNum">     591 </span><span class="lineNoCov">          0 :         rElement.CalculateRightHandSide(rResidual,rCurrentProcessInfo);</span></a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            :         // Dynamic Terms</a>
<a name="594"><span class="lineNum">     594 </span><span class="lineNoCov">          0 :         rElement.CalculateMassMatrix(rMassMatrix,rCurrentProcessInfo);</span></a>
<a name="595"><span class="lineNum">     595 </span><span class="lineNoCov">          0 :         r_const_elem_ref.GetSecondDerivativesVector(rAuxVector,0);</span></a>
<a name="596"><span class="lineNum">     596 </span>            : </a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :         noalias(rResidual) -= prod(rMassMatrix,rAuxVector);</span></a>
<a name="598"><span class="lineNum">     598 </span>            : </a>
<a name="599"><span class="lineNum">     599 </span>            :         // Velocity Terms</a>
<a name="600"><span class="lineNum">     600 </span><span class="lineNoCov">          0 :         rElement.CalculateLocalVelocityContribution(rMassMatrix,rResidual,rCurrentProcessInfo); // Note that once we are here, we no longer need the mass matrix</span></a>
<a name="601"><span class="lineNum">     601 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span>            :     /// Check if a patch index is known</a>
<a name="604"><span class="lineNum">     604 </span><span class="lineNoCov">          0 :     void AddNewIndex( std::vector&lt;int&gt;&amp; rIndices,</span></a>
<a name="605"><span class="lineNum">     605 </span>            :                       int ThisIndex )</a>
<a name="606"><span class="lineNum">     606 </span>            :     {</a>
<a name="607"><span class="lineNum">     607 </span>            :         bool IsNew = true;</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineNoCov">          0 :         for( std::vector&lt;int&gt;::iterator itIndex = rIndices.begin(); itIndex != rIndices.end(); ++itIndex)</span></a>
<a name="609"><span class="lineNum">     609 </span>            :         {</a>
<a name="610"><span class="lineNum">     610 </span><span class="lineNoCov">          0 :             if( ThisIndex == *itIndex)</span></a>
<a name="611"><span class="lineNum">     611 </span>            :             {</a>
<a name="612"><span class="lineNum">     612 </span>            :                 IsNew = false;</a>
<a name="613"><span class="lineNum">     613 </span>            :                 break;</a>
<a name="614"><span class="lineNum">     614 </span>            :             }</a>
<a name="615"><span class="lineNum">     615 </span>            :         }</a>
<a name="616"><span class="lineNum">     616 </span>            : </a>
<a name="617"><span class="lineNum">     617 </span><span class="lineNoCov">          0 :         if (IsNew)</span></a>
<a name="618"><span class="lineNum">     618 </span><span class="lineNoCov">          0 :             rIndices.push_back(ThisIndex);</span></a>
<a name="619"><span class="lineNum">     619 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="620"><span class="lineNum">     620 </span>            : </a>
<a name="621"><span class="lineNum">     621 </span>            :     ///@} // Private operations</a>
<a name="622"><span class="lineNum">     622 </span>            : </a>
<a name="623"><span class="lineNum">     623 </span>            : };</a>
<a name="624"><span class="lineNum">     624 </span>            : </a>
<a name="625"><span class="lineNum">     625 </span>            : ///@} Kratos classes</a>
<a name="626"><span class="lineNum">     626 </span>            : </a>
<a name="627"><span class="lineNum">     627 </span>            : ///@} Application group</a>
<a name="628"><span class="lineNum">     628 </span>            : </a>
<a name="629"><span class="lineNum">     629 </span>            : } // namespace Kratos</a>
<a name="630"><span class="lineNum">     630 </span>            : </a>
<a name="631"><span class="lineNum">     631 </span>            : #endif  /* KRATOS_DYNAMIC_SMAGORINSKY_UTILITIES_H_INCLUDED */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
