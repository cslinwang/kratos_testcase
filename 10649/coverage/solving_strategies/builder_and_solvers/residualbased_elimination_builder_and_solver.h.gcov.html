<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - solving_strategies/builder_and_solvers/residualbased_elimination_builder_and_solver.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">solving_strategies/builder_and_solvers</a> - residualbased_elimination_builder_and_solver.h<span style="font-size: 80%;"> (source / <a href="residualbased_elimination_builder_and_solver.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">281</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-17 14:09:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //    |  /           |</a>
<a name="2"><span class="lineNum">       2 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="3"><span class="lineNum">       3 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="4"><span class="lineNum">       4 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="5"><span class="lineNum">       5 </span>            : //                   Multi-Physics</a>
<a name="6"><span class="lineNum">       6 </span>            : //</a>
<a name="7"><span class="lineNum">       7 </span>            : //  License:       BSD License</a>
<a name="8"><span class="lineNum">       8 </span>            : //                Kratos default license: kratos/license.txt</a>
<a name="9"><span class="lineNum">       9 </span>            : //</a>
<a name="10"><span class="lineNum">      10 </span>            : //  Main authors:    Riccardo Rossi</a>
<a name="11"><span class="lineNum">      11 </span>            : //  Collaborators:   Vicente Mataix</a>
<a name="12"><span class="lineNum">      12 </span>            : //</a>
<a name="13"><span class="lineNum">      13 </span>            : //</a>
<a name="14"><span class="lineNum">      14 </span>            : </a>
<a name="15"><span class="lineNum">      15 </span>            : #if !defined(KRATOS_RESIDUAL_BASED_ELIMINATION_BUILDER_AND_SOLVER )</a>
<a name="16"><span class="lineNum">      16 </span>            : #define  KRATOS_RESIDUAL_BASED_ELIMINATION_BUILDER_AND_SOLVER</a>
<a name="17"><span class="lineNum">      17 </span>            : </a>
<a name="18"><span class="lineNum">      18 </span>            : /* System includes */</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &lt;set&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &lt;unordered_set&gt;</a>
<a name="21"><span class="lineNum">      21 </span>            : </a>
<a name="22"><span class="lineNum">      22 </span>            : /* External includes */</a>
<a name="23"><span class="lineNum">      23 </span>            : #ifdef KRATOS_SMP_OPENMP</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &lt;omp.h&gt;</a>
<a name="25"><span class="lineNum">      25 </span>            : #endif</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : /* Project includes */</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &quot;utilities/timer.h&quot;</a>
<a name="29"><span class="lineNum">      29 </span>            : #include &quot;includes/define.h&quot;</a>
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;includes/key_hash.h&quot;</a>
<a name="31"><span class="lineNum">      31 </span>            : #include &quot;solving_strategies/builder_and_solvers/builder_and_solver.h&quot;</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="33"><span class="lineNum">      33 </span>            : #include &quot;utilities/builtin_timer.h&quot;</a>
<a name="34"><span class="lineNum">      34 </span>            : #include &quot;utilities/atomic_utilities.h&quot;</a>
<a name="35"><span class="lineNum">      35 </span>            : #include &quot;spaces/ublas_space.h&quot;</a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : namespace Kratos</a>
<a name="38"><span class="lineNum">      38 </span>            : {</a>
<a name="39"><span class="lineNum">      39 </span>            : </a>
<a name="40"><span class="lineNum">      40 </span>            : ///@name Kratos Globals</a>
<a name="41"><span class="lineNum">      41 </span>            : ///@{</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            : ///@}</a>
<a name="44"><span class="lineNum">      44 </span>            : ///@name Type Definitions</a>
<a name="45"><span class="lineNum">      45 </span>            : ///@{</a>
<a name="46"><span class="lineNum">      46 </span>            : </a>
<a name="47"><span class="lineNum">      47 </span>            : ///@}</a>
<a name="48"><span class="lineNum">      48 </span>            : ///@name  Enum's</a>
<a name="49"><span class="lineNum">      49 </span>            : ///@{</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : ///@}</a>
<a name="52"><span class="lineNum">      52 </span>            : ///@name  Functions</a>
<a name="53"><span class="lineNum">      53 </span>            : ///@{</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            : ///@}</a>
<a name="56"><span class="lineNum">      56 </span>            : ///@name Kratos Classes</a>
<a name="57"><span class="lineNum">      57 </span>            : ///@{</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span>            : /**</a>
<a name="60"><span class="lineNum">      60 </span>            :  * @class ResidualBasedEliminationBuilderAndSolver</a>
<a name="61"><span class="lineNum">      61 </span>            :  * @ingroup KratosCore</a>
<a name="62"><span class="lineNum">      62 </span>            :  * @brief Current class provides an implementation for standard  elimination builder and solving operations.</a>
<a name="63"><span class="lineNum">      63 </span>            :  * @details The RHS is constituted by the unbalanced loads (residual)</a>
<a name="64"><span class="lineNum">      64 </span>            :  * Degrees of freedom are reordered putting the restrained degrees of freedom at</a>
<a name="65"><span class="lineNum">      65 </span>            :  * the end of the system ordered in reverse order with respect to the DofSet.</a>
<a name="66"><span class="lineNum">      66 </span>            :  * Imposition of the dirichlet conditions is naturally dealt with as the residual already contains this information.</a>
<a name="67"><span class="lineNum">      67 </span>            :  * Calculation of the reactions involves a cost very similar to the calculation of the total residual</a>
<a name="68"><span class="lineNum">      68 </span>            :  * @author Riccardo Rossi</a>
<a name="69"><span class="lineNum">      69 </span>            :  */</a>
<a name="70"><span class="lineNum">      70 </span>            : template&lt;class TSparseSpace,</a>
<a name="71"><span class="lineNum">      71 </span>            :          class TDenseSpace, //= DenseSpace&lt;double&gt;,</a>
<a name="72"><span class="lineNum">      72 </span>            :          class TLinearSolver //= LinearSolver&lt;TSparseSpace,TDenseSpace&gt;</a>
<a name="73"><span class="lineNum">      73 </span>            :          &gt;</a>
<a name="74"><span class="lineNum">      74 </span>            : class ResidualBasedEliminationBuilderAndSolver</a>
<a name="75"><span class="lineNum">      75 </span>            :     : public BuilderAndSolver&lt; TSparseSpace, TDenseSpace, TLinearSolver &gt;</a>
<a name="76"><span class="lineNum">      76 </span>            : {</a>
<a name="77"><span class="lineNum">      77 </span>            : public:</a>
<a name="78"><span class="lineNum">      78 </span>            :     ///@name Type Definitions</a>
<a name="79"><span class="lineNum">      79 </span>            :     ///@{</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            :     /// Pointer definition of ResidualBasedEliminationBuilderAndSolverWithConstraints</a>
<a name="82"><span class="lineNum">      82 </span>            :     KRATOS_CLASS_POINTER_DEFINITION(ResidualBasedEliminationBuilderAndSolver);</a>
<a name="83"><span class="lineNum">      83 </span>            : </a>
<a name="84"><span class="lineNum">      84 </span>            :     /// Definition of the base class</a>
<a name="85"><span class="lineNum">      85 </span>            :     typedef BuilderAndSolver&lt;TSparseSpace, TDenseSpace, TLinearSolver&gt; BaseType;</a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span>            :     /// The definition of the current class</a>
<a name="88"><span class="lineNum">      88 </span>            :     typedef ResidualBasedEliminationBuilderAndSolver&lt;TSparseSpace, TDenseSpace, TLinearSolver&gt; ClassType;</a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            :     /// Definition of the classes from the base class</a>
<a name="91"><span class="lineNum">      91 </span>            :     typedef typename BaseType::SizeType SizeType;</a>
<a name="92"><span class="lineNum">      92 </span>            :     typedef typename BaseType::IndexType IndexType;</a>
<a name="93"><span class="lineNum">      93 </span>            :     typedef typename BaseType::TSchemeType TSchemeType;</a>
<a name="94"><span class="lineNum">      94 </span>            :     typedef typename BaseType::TDataType TDataType;</a>
<a name="95"><span class="lineNum">      95 </span>            :     typedef typename BaseType::DofsArrayType DofsArrayType;</a>
<a name="96"><span class="lineNum">      96 </span>            :     typedef typename BaseType::TSystemMatrixType TSystemMatrixType;</a>
<a name="97"><span class="lineNum">      97 </span>            :     typedef typename BaseType::TSystemVectorType TSystemVectorType;</a>
<a name="98"><span class="lineNum">      98 </span>            :     typedef typename BaseType::LocalSystemVectorType LocalSystemVectorType;</a>
<a name="99"><span class="lineNum">      99 </span>            :     typedef typename BaseType::LocalSystemMatrixType LocalSystemMatrixType;</a>
<a name="100"><span class="lineNum">     100 </span>            :     typedef typename BaseType::TSystemMatrixPointerType TSystemMatrixPointerType;</a>
<a name="101"><span class="lineNum">     101 </span>            :     typedef typename BaseType::TSystemVectorPointerType TSystemVectorPointerType;</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            :     /// Definition of the equation id vector</a>
<a name="104"><span class="lineNum">     104 </span>            :     typedef Element::EquationIdVectorType EquationIdVectorType;</a>
<a name="105"><span class="lineNum">     105 </span>            :     typedef Element::DofsVectorType DofsVectorType;</a>
<a name="106"><span class="lineNum">     106 </span>            : </a>
<a name="107"><span class="lineNum">     107 </span>            :     /// Node definition</a>
<a name="108"><span class="lineNum">     108 </span>            :     typedef Node&lt;3&gt; NodeType;</a>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<a name="110"><span class="lineNum">     110 </span>            :     /// Containers definition</a>
<a name="111"><span class="lineNum">     111 </span>            :     typedef typename BaseType::NodesArrayType NodesArrayType;</a>
<a name="112"><span class="lineNum">     112 </span>            :     typedef typename BaseType::ElementsArrayType ElementsArrayType;</a>
<a name="113"><span class="lineNum">     113 </span>            :     typedef typename BaseType::ConditionsArrayType ConditionsArrayType;</a>
<a name="114"><span class="lineNum">     114 </span>            :     typedef typename BaseType::ElementsContainerType ElementsContainerType;</a>
<a name="115"><span class="lineNum">     115 </span>            : </a>
<a name="116"><span class="lineNum">     116 </span>            :     ///@}</a>
<a name="117"><span class="lineNum">     117 </span>            :     ///@name Life Cycle</a>
<a name="118"><span class="lineNum">     118 </span>            :     ///@{</a>
<a name="119"><span class="lineNum">     119 </span>            : </a>
<a name="120"><span class="lineNum">     120 </span>            :     /**</a>
<a name="121"><span class="lineNum">     121 </span>            :      * @brief Default constructor</a>
<a name="122"><span class="lineNum">     122 </span>            :      */</a>
<a name="123"><span class="lineNum">     123 </span>            :     explicit ResidualBasedEliminationBuilderAndSolver() : BaseType()</a>
<a name="124"><span class="lineNum">     124 </span>            :     {</a>
<a name="125"><span class="lineNum">     125 </span>            :     }</a>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<a name="127"><span class="lineNum">     127 </span>            :     /**</a>
<a name="128"><span class="lineNum">     128 </span>            :      * @brief Default constructor. (with parameters)</a>
<a name="129"><span class="lineNum">     129 </span>            :      */</a>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 :     explicit ResidualBasedEliminationBuilderAndSolver(</span></a>
<a name="131"><span class="lineNum">     131 </span>            :         typename TLinearSolver::Pointer pNewLinearSystemSolver,</a>
<a name="132"><span class="lineNum">     132 </span>            :         Parameters ThisParameters</a>
<a name="133"><span class="lineNum">     133 </span><span class="lineNoCov">          0 :         ) : BaseType(pNewLinearSystemSolver)</span></a>
<a name="134"><span class="lineNum">     134 </span>            :     {</a>
<a name="135"><span class="lineNum">     135 </span>            :         // Validate and assign defaults</a>
<a name="136"><span class="lineNum">     136 </span><span class="lineNoCov">          0 :         ThisParameters = this-&gt;ValidateAndAssignParameters(ThisParameters, this-&gt;GetDefaultParameters());</span></a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :         this-&gt;AssignSettings(ThisParameters);</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span>            :     /**</a>
<a name="141"><span class="lineNum">     141 </span>            :      * @brief Constructor.</a>
<a name="142"><span class="lineNum">     142 </span>            :      */</a>
<a name="143"><span class="lineNum">     143 </span><span class="lineNoCov">          0 :     explicit ResidualBasedEliminationBuilderAndSolver(</span></a>
<a name="144"><span class="lineNum">     144 </span>            :         typename TLinearSolver::Pointer pNewLinearSystemSolver)</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineNoCov">          0 :         : BaseType(pNewLinearSystemSolver)</span></a>
<a name="146"><span class="lineNum">     146 </span>            :     {</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            :     /** Destructor.</a>
<a name="150"><span class="lineNum">     150 </span>            :      */</a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :     ~ResidualBasedEliminationBuilderAndSolver() override</span></a>
<a name="152"><span class="lineNum">     152 </span>            :     {</a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :     /**</a>
<a name="156"><span class="lineNum">     156 </span>            :      * @brief Create method</a>
<a name="157"><span class="lineNum">     157 </span>            :      * @param pNewLinearSystemSolver The linear solver for the system of equations</a>
<a name="158"><span class="lineNum">     158 </span>            :      * @param ThisParameters The configuration parameters</a>
<a name="159"><span class="lineNum">     159 </span>            :      */</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :     typename BaseType::Pointer Create(</span></a>
<a name="161"><span class="lineNum">     161 </span>            :         typename TLinearSolver::Pointer pNewLinearSystemSolver,</a>
<a name="162"><span class="lineNum">     162 </span>            :         Parameters ThisParameters</a>
<a name="163"><span class="lineNum">     163 </span>            :         ) const override</a>
<a name="164"><span class="lineNum">     164 </span>            :     {</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineNoCov">          0 :         return Kratos::make_shared&lt;ClassType&gt;(pNewLinearSystemSolver,ThisParameters);</span></a>
<a name="166"><span class="lineNum">     166 </span>            :     }</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            :     ///@}</a>
<a name="169"><span class="lineNum">     169 </span>            :     ///@name Operators</a>
<a name="170"><span class="lineNum">     170 </span>            :     ///@{</a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span>            :     ///@}</a>
<a name="173"><span class="lineNum">     173 </span>            :     ///@name Operations</a>
<a name="174"><span class="lineNum">     174 </span>            :     ///@{</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span>            :     /**</a>
<a name="177"><span class="lineNum">     177 </span>            :      * @brief Function to perform the build of the RHS. The vector could be sized as the total number</a>
<a name="178"><span class="lineNum">     178 </span>            :      * of dofs or as the number of unrestrained ones</a>
<a name="179"><span class="lineNum">     179 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="180"><span class="lineNum">     180 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="181"><span class="lineNum">     181 </span>            :      * @param rA The LHS matrix</a>
<a name="182"><span class="lineNum">     182 </span>            :      * @param rb The RHS vector</a>
<a name="183"><span class="lineNum">     183 </span>            :      */</a>
<a name="184"><span class="lineNum">     184 </span><span class="lineNoCov">          0 :     void Build(</span></a>
<a name="185"><span class="lineNum">     185 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="186"><span class="lineNum">     186 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="187"><span class="lineNum">     187 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="188"><span class="lineNum">     188 </span>            :         TSystemVectorType&amp; rb</a>
<a name="189"><span class="lineNum">     189 </span>            :         ) override</a>
<a name="190"><span class="lineNum">     190 </span>            :     {</a>
<a name="191"><span class="lineNum">     191 </span>            :         KRATOS_TRY</a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :         KRATOS_ERROR_IF(!pScheme) &lt;&lt; &quot;No scheme provided!&quot; &lt;&lt; std::endl;</span></a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span>            :         // Getting the elements from the model</a>
<a name="196"><span class="lineNum">     196 </span>            :         ElementsArrayType&amp; r_elements_array = rModelPart.Elements();</a>
<a name="197"><span class="lineNum">     197 </span>            : </a>
<a name="198"><span class="lineNum">     198 </span>            :         // Getting the array of the conditions</a>
<a name="199"><span class="lineNum">     199 </span>            :         ConditionsArrayType&amp; r_conditions_array = rModelPart.Conditions();</a>
<a name="200"><span class="lineNum">     200 </span>            : </a>
<a name="201"><span class="lineNum">     201 </span>            :         // Getting the elements from the model</a>
<a name="202"><span class="lineNum">     202 </span><span class="lineNoCov">          0 :         const int nelements = static_cast&lt;int&gt;(r_elements_array.size());</span></a>
<a name="203"><span class="lineNum">     203 </span>            : </a>
<a name="204"><span class="lineNum">     204 </span>            :         // Getting the array of the conditions</a>
<a name="205"><span class="lineNum">     205 </span><span class="lineNoCov">          0 :         const int nconditions = static_cast&lt;int&gt;(r_conditions_array.size());</span></a>
<a name="206"><span class="lineNum">     206 </span>            : </a>
<a name="207"><span class="lineNum">     207 </span>            :         const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="208"><span class="lineNum">     208 </span><span class="lineNoCov">          0 :         const auto it_elem_begin = r_elements_array.begin();</span></a>
<a name="209"><span class="lineNum">     209 </span><span class="lineNoCov">          0 :         const auto it_cond_begin = r_conditions_array.begin();</span></a>
<a name="210"><span class="lineNum">     210 </span>            : </a>
<a name="211"><span class="lineNum">     211 </span>            :         //contributions to the system</a>
<a name="212"><span class="lineNum">     212 </span>            :         LocalSystemMatrixType LHS_Contribution = LocalSystemMatrixType(0, 0);</a>
<a name="213"><span class="lineNum">     213 </span>            :         LocalSystemVectorType RHS_Contribution = LocalSystemVectorType(0);</a>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<a name="215"><span class="lineNum">     215 </span>            :         // Vector containing the localization in the system of the different terms</a>
<a name="216"><span class="lineNum">     216 </span>            :         EquationIdVectorType equation_id;</a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span>            :         // Assemble all elements</a>
<a name="219"><span class="lineNum">     219 </span>            :         const auto timer = BuiltinTimer();</a>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<a name="221"><span class="lineNum">     221 </span><span class="lineNoCov">          0 :         #pragma omp parallel firstprivate(LHS_Contribution, RHS_Contribution, equation_id )</span></a>
<a name="222"><span class="lineNum">     222 </span>            :         {</a>
<a name="223"><span class="lineNum">     223 </span>            :             #pragma omp  for schedule(guided, 512) nowait</a>
<a name="224"><span class="lineNum">     224 </span>            :             for (int k = 0; k &lt; nelements; ++k) {</a>
<a name="225"><span class="lineNum">     225 </span>            :                 auto it_elem = it_elem_begin + k;</a>
<a name="226"><span class="lineNum">     226 </span>            : </a>
<a name="227"><span class="lineNum">     227 </span>            :                 // If the element is active</a>
<a name="228"><span class="lineNum">     228 </span>            :                 if (it_elem-&gt;IsActive()) {</a>
<a name="229"><span class="lineNum">     229 </span>            :                     // Calculate elemental contribution</a>
<a name="230"><span class="lineNum">     230 </span>            :                     pScheme-&gt;CalculateSystemContributions(*it_elem, LHS_Contribution, RHS_Contribution, equation_id, r_current_process_info);</a>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<a name="232"><span class="lineNum">     232 </span>            :                     // Assemble the elemental contribution</a>
<a name="233"><span class="lineNum">     233 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="234"><span class="lineNum">     234 </span>            :                     Assemble(rA, rb, LHS_Contribution, RHS_Contribution, equation_id, mLockArray);</a>
<a name="235"><span class="lineNum">     235 </span>            : #else</a>
<a name="236"><span class="lineNum">     236 </span>            :                     Assemble(rA, rb, LHS_Contribution, RHS_Contribution, equation_id);</a>
<a name="237"><span class="lineNum">     237 </span>            : #endif</a>
<a name="238"><span class="lineNum">     238 </span>            :                 }</a>
<a name="239"><span class="lineNum">     239 </span>            :             }</a>
<a name="240"><span class="lineNum">     240 </span>            : </a>
<a name="241"><span class="lineNum">     241 </span>            :             #pragma omp  for schedule(guided, 512)</a>
<a name="242"><span class="lineNum">     242 </span>            :             for (int k = 0; k &lt; nconditions; ++k) {</a>
<a name="243"><span class="lineNum">     243 </span>            :                 auto it_cond = it_cond_begin + k;</a>
<a name="244"><span class="lineNum">     244 </span>            : </a>
<a name="245"><span class="lineNum">     245 </span>            :                 // If the condition is active</a>
<a name="246"><span class="lineNum">     246 </span>            :                 if (it_cond-&gt;IsActive()) {</a>
<a name="247"><span class="lineNum">     247 </span>            :                     // Calculate elemental contribution</a>
<a name="248"><span class="lineNum">     248 </span>            :                     pScheme-&gt;CalculateSystemContributions(*it_cond, LHS_Contribution, RHS_Contribution, equation_id, r_current_process_info);</a>
<a name="249"><span class="lineNum">     249 </span>            : </a>
<a name="250"><span class="lineNum">     250 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="251"><span class="lineNum">     251 </span>            :                     Assemble(rA, rb, LHS_Contribution, RHS_Contribution, equation_id, mLockArray);</a>
<a name="252"><span class="lineNum">     252 </span>            : #else</a>
<a name="253"><span class="lineNum">     253 </span>            :                     Assemble(rA, rb, LHS_Contribution, RHS_Contribution, equation_id);</a>
<a name="254"><span class="lineNum">     254 </span>            : #endif</a>
<a name="255"><span class="lineNum">     255 </span>            :                 }</a>
<a name="256"><span class="lineNum">     256 </span>            :             }</a>
<a name="257"><span class="lineNum">     257 </span>            :         }</a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt;=1) &lt;&lt; &quot;System build time: &quot; &lt;&lt; timer.ElapsedSeconds() &lt;&lt; std::endl;</span></a>
<a name="259"><span class="lineNum">     259 </span>            : </a>
<a name="260"><span class="lineNum">     260 </span>            : </a>
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 2) &lt;&lt; &quot;Finished building&quot; &lt;&lt; std::endl;</span></a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span>            : </a>
<a name="264"><span class="lineNum">     264 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="265"><span class="lineNum">     265 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="266"><span class="lineNum">     266 </span>            : </a>
<a name="267"><span class="lineNum">     267 </span>            :     /**</a>
<a name="268"><span class="lineNum">     268 </span>            :      * @brief Function to perform the building of the LHS</a>
<a name="269"><span class="lineNum">     269 </span>            :      * @details Depending on the implementation chosen the size of the matrix could be equal to the total number of Dofs or to the number of unrestrained dofs</a>
<a name="270"><span class="lineNum">     270 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="271"><span class="lineNum">     271 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="272"><span class="lineNum">     272 </span>            :      * @param rA The LHS matrix</a>
<a name="273"><span class="lineNum">     273 </span>            :      */</a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :     void BuildLHS(</span></a>
<a name="275"><span class="lineNum">     275 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="276"><span class="lineNum">     276 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="277"><span class="lineNum">     277 </span>            :         TSystemMatrixType&amp; rA</a>
<a name="278"><span class="lineNum">     278 </span>            :         ) override</a>
<a name="279"><span class="lineNum">     279 </span>            :     {</a>
<a name="280"><span class="lineNum">     280 </span>            :         KRATOS_TRY</a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :         KRATOS_ERROR_IF(!pScheme) &lt;&lt; &quot;No scheme provided!&quot; &lt;&lt; std::endl;</span></a>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<a name="284"><span class="lineNum">     284 </span>            :         // Getting the elements from the model</a>
<a name="285"><span class="lineNum">     285 </span>            :         ElementsArrayType&amp; r_elements_array = rModelPart.Elements();</a>
<a name="286"><span class="lineNum">     286 </span>            : </a>
<a name="287"><span class="lineNum">     287 </span>            :         // Getting the array of the conditions</a>
<a name="288"><span class="lineNum">     288 </span>            :         ConditionsArrayType&amp; r_conditions_array = rModelPart.Conditions();</a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span>            :         // Getting the elements from the model</a>
<a name="291"><span class="lineNum">     291 </span><span class="lineNoCov">          0 :         const int nelements = static_cast&lt;int&gt;(r_elements_array.size());</span></a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span>            :         // Getting the array of the conditions</a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :         const int nconditions = static_cast&lt;int&gt;(r_conditions_array.size());</span></a>
<a name="295"><span class="lineNum">     295 </span>            : </a>
<a name="296"><span class="lineNum">     296 </span>            :         const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="297"><span class="lineNum">     297 </span><span class="lineNoCov">          0 :         const auto it_elem_begin = r_elements_array.begin();</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :         const auto it_cond_begin = r_conditions_array.begin();</span></a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span>            :         // Resetting to zero the vector of reactions</a>
<a name="301"><span class="lineNum">     301 </span>            :         TSparseSpace::SetToZero(*(BaseType::mpReactionsVector));</a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span>            :         // Contributions to the system</a>
<a name="304"><span class="lineNum">     304 </span>            :         LocalSystemMatrixType LHS_Contribution = LocalSystemMatrixType(0, 0);</a>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<a name="306"><span class="lineNum">     306 </span>            :         // Vector containing the localization in the system of the different terms</a>
<a name="307"><span class="lineNum">     307 </span>            :         EquationIdVectorType equation_id;</a>
<a name="308"><span class="lineNum">     308 </span>            : </a>
<a name="309"><span class="lineNum">     309 </span><span class="lineNoCov">          0 :         #pragma omp parallel firstprivate(LHS_Contribution, equation_id )</span></a>
<a name="310"><span class="lineNum">     310 </span>            :         {</a>
<a name="311"><span class="lineNum">     311 </span>            :             #pragma omp  for schedule(guided, 512) nowait</a>
<a name="312"><span class="lineNum">     312 </span>            :             for (int k = 0; k &lt; nelements; ++k) {</a>
<a name="313"><span class="lineNum">     313 </span>            :                 auto it_elem = it_elem_begin + k;</a>
<a name="314"><span class="lineNum">     314 </span>            : </a>
<a name="315"><span class="lineNum">     315 </span>            :                 // If the element is active</a>
<a name="316"><span class="lineNum">     316 </span>            :                 if (it_elem-&gt;IsActive()) {</a>
<a name="317"><span class="lineNum">     317 </span>            :                     // Calculate elemental contribution</a>
<a name="318"><span class="lineNum">     318 </span>            :                     pScheme-&gt;CalculateLHSContribution(*it_elem, LHS_Contribution, equation_id, r_current_process_info);</a>
<a name="319"><span class="lineNum">     319 </span>            : </a>
<a name="320"><span class="lineNum">     320 </span>            :                     // Assemble the elemental contribution</a>
<a name="321"><span class="lineNum">     321 </span>            :                     AssembleLHS(rA, LHS_Contribution, equation_id);</a>
<a name="322"><span class="lineNum">     322 </span>            :                 }</a>
<a name="323"><span class="lineNum">     323 </span>            :             }</a>
<a name="324"><span class="lineNum">     324 </span>            : </a>
<a name="325"><span class="lineNum">     325 </span>            :             #pragma omp  for schedule(guided, 512)</a>
<a name="326"><span class="lineNum">     326 </span>            :             for (int k = 0; k &lt; nconditions; ++k) {</a>
<a name="327"><span class="lineNum">     327 </span>            :                 auto it_cond = it_cond_begin + k;</a>
<a name="328"><span class="lineNum">     328 </span>            : </a>
<a name="329"><span class="lineNum">     329 </span>            :                 // If the condition is active</a>
<a name="330"><span class="lineNum">     330 </span>            :                 if (it_cond-&gt;IsActive()) {</a>
<a name="331"><span class="lineNum">     331 </span>            :                     // Calculate elemental contribution</a>
<a name="332"><span class="lineNum">     332 </span>            :                     pScheme-&gt;CalculateLHSContribution(*it_cond, LHS_Contribution, equation_id, r_current_process_info);</a>
<a name="333"><span class="lineNum">     333 </span>            : </a>
<a name="334"><span class="lineNum">     334 </span>            :                     // Assemble the elemental contribution</a>
<a name="335"><span class="lineNum">     335 </span>            :                     AssembleLHS(rA, LHS_Contribution, equation_id);</a>
<a name="336"><span class="lineNum">     336 </span>            :                 }</a>
<a name="337"><span class="lineNum">     337 </span>            :             }</a>
<a name="338"><span class="lineNum">     338 </span>            :         }</a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="342"><span class="lineNum">     342 </span>            : </a>
<a name="343"><span class="lineNum">     343 </span>            :     /**</a>
<a name="344"><span class="lineNum">     344 </span>            :      * @brief Build a rectangular matrix of size n*N where &quot;n&quot; is the number of unrestrained degrees of freedom</a>
<a name="345"><span class="lineNum">     345 </span>            :      * and &quot;N&quot; is the total number of degrees of freedom involved.</a>
<a name="346"><span class="lineNum">     346 </span>            :      * @details This matrix is obtained by building the total matrix without the lines corresponding to the fixed</a>
<a name="347"><span class="lineNum">     347 </span>            :      * degrees of freedom (but keeping the columns!!)</a>
<a name="348"><span class="lineNum">     348 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="349"><span class="lineNum">     349 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="350"><span class="lineNum">     350 </span>            :      * @param A The LHS matrix</a>
<a name="351"><span class="lineNum">     351 </span>            :      */</a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :     void BuildLHS_CompleteOnFreeRows(</span></a>
<a name="353"><span class="lineNum">     353 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="354"><span class="lineNum">     354 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="355"><span class="lineNum">     355 </span>            :         TSystemMatrixType&amp; rA</a>
<a name="356"><span class="lineNum">     356 </span>            :         ) override</a>
<a name="357"><span class="lineNum">     357 </span>            :     {</a>
<a name="358"><span class="lineNum">     358 </span>            :         KRATOS_TRY</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :         KRATOS_ERROR_IF(!pScheme) &lt;&lt; &quot;No scheme provided!&quot; &lt;&lt; std::endl;</span></a>
<a name="361"><span class="lineNum">     361 </span>            : </a>
<a name="362"><span class="lineNum">     362 </span>            :         // Getting the elements from the model</a>
<a name="363"><span class="lineNum">     363 </span>            :         ElementsArrayType&amp; r_elements_array = rModelPart.Elements();</a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            :         // Getting the array of the conditions</a>
<a name="366"><span class="lineNum">     366 </span>            :         ConditionsArrayType&amp; r_conditions_array = rModelPart.Conditions();</a>
<a name="367"><span class="lineNum">     367 </span>            : </a>
<a name="368"><span class="lineNum">     368 </span>            :         // Getting the elements from the model</a>
<a name="369"><span class="lineNum">     369 </span><span class="lineNoCov">          0 :         const int nelements = static_cast&lt;int&gt;(r_elements_array.size());</span></a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span>            :         // Getting the array of the conditions</a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :         const int nconditions = static_cast&lt;int&gt;(r_conditions_array.size());</span></a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            :         const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 :         const auto it_elem_begin = r_elements_array.begin();</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :         const auto it_cond_begin = r_conditions_array.begin();</span></a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span>            :         // Resetting to zero the vector of reactions</a>
<a name="379"><span class="lineNum">     379 </span>            :         TSparseSpace::SetToZero(*(BaseType::mpReactionsVector));</a>
<a name="380"><span class="lineNum">     380 </span>            : </a>
<a name="381"><span class="lineNum">     381 </span>            :         // Contributions to the system</a>
<a name="382"><span class="lineNum">     382 </span>            :         LocalSystemMatrixType LHS_Contribution = LocalSystemMatrixType(0, 0);</a>
<a name="383"><span class="lineNum">     383 </span>            : </a>
<a name="384"><span class="lineNum">     384 </span>            :         // Vector containing the localization in the system of the different terms</a>
<a name="385"><span class="lineNum">     385 </span>            :         EquationIdVectorType equation_id;</a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span><span class="lineNoCov">          0 :         #pragma omp parallel firstprivate(LHS_Contribution, equation_id )</span></a>
<a name="388"><span class="lineNum">     388 </span>            :         {</a>
<a name="389"><span class="lineNum">     389 </span>            :             #pragma omp  for schedule(guided, 512) nowait</a>
<a name="390"><span class="lineNum">     390 </span>            :             for (int k = 0; k &lt; nelements; ++k) {</a>
<a name="391"><span class="lineNum">     391 </span>            :                 auto it_elem = it_elem_begin + k;</a>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<a name="393"><span class="lineNum">     393 </span>            :                 // If the element is active</a>
<a name="394"><span class="lineNum">     394 </span>            :                 if (it_elem-&gt;IsActive()) {</a>
<a name="395"><span class="lineNum">     395 </span>            :                     // Calculate elemental contribution</a>
<a name="396"><span class="lineNum">     396 </span>            :                     pScheme-&gt;CalculateLHSContribution(*it_elem, LHS_Contribution, equation_id, r_current_process_info);</a>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<a name="398"><span class="lineNum">     398 </span>            :                     // Assemble the elemental contribution</a>
<a name="399"><span class="lineNum">     399 </span>            :                     AssembleLHSCompleteOnFreeRows(rA, LHS_Contribution, equation_id);</a>
<a name="400"><span class="lineNum">     400 </span>            :                 }</a>
<a name="401"><span class="lineNum">     401 </span>            :             }</a>
<a name="402"><span class="lineNum">     402 </span>            : </a>
<a name="403"><span class="lineNum">     403 </span>            :             #pragma omp  for schedule(guided, 512)</a>
<a name="404"><span class="lineNum">     404 </span>            :             for (int k = 0; k &lt; nconditions; ++k) {</a>
<a name="405"><span class="lineNum">     405 </span>            :                 auto it_cond = it_cond_begin + k;</a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :                 // If the condition is active</a>
<a name="408"><span class="lineNum">     408 </span>            :                 if (it_cond-&gt;IsActive()) {</a>
<a name="409"><span class="lineNum">     409 </span>            :                     // Calculate elemental contribution</a>
<a name="410"><span class="lineNum">     410 </span>            :                     pScheme-&gt;CalculateLHSContribution(*it_cond, LHS_Contribution, equation_id, r_current_process_info);</a>
<a name="411"><span class="lineNum">     411 </span>            : </a>
<a name="412"><span class="lineNum">     412 </span>            :                     // Assemble the elemental contribution</a>
<a name="413"><span class="lineNum">     413 </span>            :                     AssembleLHSCompleteOnFreeRows(rA, LHS_Contribution, equation_id);</a>
<a name="414"><span class="lineNum">     414 </span>            :                 }</a>
<a name="415"><span class="lineNum">     415 </span>            :             }</a>
<a name="416"><span class="lineNum">     416 </span>            :         }</a>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<a name="421"><span class="lineNum">     421 </span>            :     /**</a>
<a name="422"><span class="lineNum">     422 </span>            :      * @brief This is a call to the linear system solver</a>
<a name="423"><span class="lineNum">     423 </span>            :      * @param rA The LHS matrix</a>
<a name="424"><span class="lineNum">     424 </span>            :      * @param rDx The Unknowns vector</a>
<a name="425"><span class="lineNum">     425 </span>            :      * @param rb The RHS vector</a>
<a name="426"><span class="lineNum">     426 </span>            :      */</a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :     void SystemSolve(</span></a>
<a name="428"><span class="lineNum">     428 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="429"><span class="lineNum">     429 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="430"><span class="lineNum">     430 </span>            :         TSystemVectorType&amp; rb</a>
<a name="431"><span class="lineNum">     431 </span>            :         ) override</a>
<a name="432"><span class="lineNum">     432 </span>            :     {</a>
<a name="433"><span class="lineNum">     433 </span>            :         KRATOS_TRY</a>
<a name="434"><span class="lineNum">     434 </span>            : </a>
<a name="435"><span class="lineNum">     435 </span>            :         double norm_b;</a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :         if (TSparseSpace::Size(rb) != 0) {</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :             norm_b = TSparseSpace::TwoNorm(rb);</span></a>
<a name="438"><span class="lineNum">     438 </span>            :         } else {</a>
<a name="439"><span class="lineNum">     439 </span>            :             norm_b = 0.0;</a>
<a name="440"><span class="lineNum">     440 </span>            :         }</a>
<a name="441"><span class="lineNum">     441 </span>            : </a>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 :         if (norm_b != 0.0) {</span></a>
<a name="443"><span class="lineNum">     443 </span>            :             // Do solve</a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :             BaseType::mpLinearSystemSolver-&gt;Solve(rA, rDx, rb);</span></a>
<a name="445"><span class="lineNum">     445 </span>            :         } else</a>
<a name="446"><span class="lineNum">     446 </span>            :             TSparseSpace::SetToZero(rDx);</a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            :         // Prints information about the current time</a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 1) &lt;&lt; *(BaseType::mpLinearSystemSolver) &lt;&lt; std::endl;</span></a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="454"><span class="lineNum">     454 </span>            : </a>
<a name="455"><span class="lineNum">     455 </span>            :     /**</a>
<a name="456"><span class="lineNum">     456 </span>            :       *@brief This is a call to the linear system solver (taking into account some physical particularities of the problem)</a>
<a name="457"><span class="lineNum">     457 </span>            :      * @param rA The LHS matrix</a>
<a name="458"><span class="lineNum">     458 </span>            :      * @param rDx The Unknowns vector</a>
<a name="459"><span class="lineNum">     459 </span>            :      * @param rb The RHS vector</a>
<a name="460"><span class="lineNum">     460 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="461"><span class="lineNum">     461 </span>            :      */</a>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 :     void SystemSolveWithPhysics(</span></a>
<a name="463"><span class="lineNum">     463 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="464"><span class="lineNum">     464 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="465"><span class="lineNum">     465 </span>            :         TSystemVectorType&amp; rb,</a>
<a name="466"><span class="lineNum">     466 </span>            :         ModelPart&amp; rModelPart</a>
<a name="467"><span class="lineNum">     467 </span>            :         )</a>
<a name="468"><span class="lineNum">     468 </span>            :     {</a>
<a name="469"><span class="lineNum">     469 </span>            :         KRATOS_TRY</a>
<a name="470"><span class="lineNum">     470 </span>            : </a>
<a name="471"><span class="lineNum">     471 </span>            :         double norm_b;</a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :         if (TSparseSpace::Size(rb) != 0) {</span></a>
<a name="473"><span class="lineNum">     473 </span><span class="lineNoCov">          0 :             norm_b = TSparseSpace::TwoNorm(rb);</span></a>
<a name="474"><span class="lineNum">     474 </span>            :         } else {</a>
<a name="475"><span class="lineNum">     475 </span>            :             norm_b = 0.0;</a>
<a name="476"><span class="lineNum">     476 </span>            :         }</a>
<a name="477"><span class="lineNum">     477 </span>            : </a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :         if (norm_b != 0.0) {</span></a>
<a name="479"><span class="lineNum">     479 </span>            :             // Provide physical data as needed</a>
<a name="480"><span class="lineNum">     480 </span><span class="lineNoCov">          0 :             if(BaseType::mpLinearSystemSolver-&gt;AdditionalPhysicalDataIsNeeded() )</span></a>
<a name="481"><span class="lineNum">     481 </span><span class="lineNoCov">          0 :                 BaseType::mpLinearSystemSolver-&gt;ProvideAdditionalData(rA, rDx, rb, BaseType::mDofSet, rModelPart);</span></a>
<a name="482"><span class="lineNum">     482 </span>            : </a>
<a name="483"><span class="lineNum">     483 </span>            :             // Do solve</a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :             BaseType::mpLinearSystemSolver-&gt;Solve(rA, rDx, rb);</span></a>
<a name="485"><span class="lineNum">     485 </span>            :         } else {</a>
<a name="486"><span class="lineNum">     486 </span>            :             TSparseSpace::SetToZero(rDx);</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :             KRATOS_WARNING_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, rModelPart.GetCommunicator().MyPID() == 0) &lt;&lt; &quot;ATTENTION! setting the RHS to zero!&quot; &lt;&lt; std::endl;</span></a>
<a name="488"><span class="lineNum">     488 </span>            :         }</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span>            :         // Prints information about the current time</a>
<a name="491"><span class="lineNum">     491 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 1 &amp;&amp; rModelPart.GetCommunicator().MyPID() == 0) &lt;&lt; *(BaseType::mpLinearSystemSolver) &lt;&lt; std::endl;</span></a>
<a name="492"><span class="lineNum">     492 </span>            : </a>
<a name="493"><span class="lineNum">     493 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<a name="497"><span class="lineNum">     497 </span>            :     /**</a>
<a name="498"><span class="lineNum">     498 </span>            :      * @brief Function to perform the building and solving phase at the same time.</a>
<a name="499"><span class="lineNum">     499 </span>            :      * @details It is ideally the fastest and safer function to use when it is possible to solve</a>
<a name="500"><span class="lineNum">     500 </span>            :      * just after building</a>
<a name="501"><span class="lineNum">     501 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="502"><span class="lineNum">     502 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="503"><span class="lineNum">     503 </span>            :      * @param rA The LHS matrix</a>
<a name="504"><span class="lineNum">     504 </span>            :      * @param rDx The Unknowns vector</a>
<a name="505"><span class="lineNum">     505 </span>            :      * @param rb The RHS vector</a>
<a name="506"><span class="lineNum">     506 </span>            :      */</a>
<a name="507"><span class="lineNum">     507 </span><span class="lineNoCov">          0 :     void BuildAndSolve(</span></a>
<a name="508"><span class="lineNum">     508 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="509"><span class="lineNum">     509 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="510"><span class="lineNum">     510 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="511"><span class="lineNum">     511 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="512"><span class="lineNum">     512 </span>            :         TSystemVectorType&amp; rb</a>
<a name="513"><span class="lineNum">     513 </span>            :         ) override</a>
<a name="514"><span class="lineNum">     514 </span>            :     {</a>
<a name="515"><span class="lineNum">     515 </span>            :         KRATOS_TRY</a>
<a name="516"><span class="lineNum">     516 </span>            : </a>
<a name="517"><span class="lineNum">     517 </span><span class="lineNoCov">          0 :         Timer::Start(&quot;Build&quot;);</span></a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span><span class="lineNoCov">          0 :         Build(pScheme, rModelPart, rA, rb);</span></a>
<a name="520"><span class="lineNum">     520 </span>            : </a>
<a name="521"><span class="lineNum">     521 </span><span class="lineNoCov">          0 :         Timer::Stop(&quot;Build&quot;);</span></a>
<a name="522"><span class="lineNum">     522 </span>            : </a>
<a name="523"><span class="lineNum">     523 </span>            :         // Does nothing...dirichlet conditions are naturally dealt with in defining the residual</a>
<a name="524"><span class="lineNum">     524 </span><span class="lineNoCov">          0 :         ApplyDirichletConditions(pScheme, rModelPart, rA, rDx, rb);</span></a>
<a name="525"><span class="lineNum">     525 </span>            : </a>
<a name="526"><span class="lineNum">     526 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, ( this-&gt;GetEchoLevel() == 3)) &lt;&lt; &quot;Before the solution of the system&quot; &lt;&lt; &quot;\nSystem Matrix = &quot; &lt;&lt; rA &lt;&lt; &quot;\nUnknowns vector = &quot; &lt;&lt; rDx &lt;&lt; &quot;\nRHS vector = &quot; &lt;&lt; rb &lt;&lt; std::endl;</span></a>
<a name="527"><span class="lineNum">     527 </span>            : </a>
<a name="528"><span class="lineNum">     528 </span>            :         const auto timer = BuiltinTimer();</a>
<a name="529"><span class="lineNum">     529 </span><span class="lineNoCov">          0 :         Timer::Start(&quot;Solve&quot;);</span></a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<a name="531"><span class="lineNum">     531 </span><span class="lineNoCov">          0 :         SystemSolveWithPhysics(rA, rDx, rb, rModelPart);</span></a>
<a name="532"><span class="lineNum">     532 </span>            : </a>
<a name="533"><span class="lineNum">     533 </span><span class="lineNoCov">          0 :         Timer::Stop(&quot;Solve&quot;);</span></a>
<a name="534"><span class="lineNum">     534 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt;=1) &lt;&lt; &quot;System solve time: &quot; &lt;&lt; timer.ElapsedSeconds() &lt;&lt; std::endl;</span></a>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<a name="536"><span class="lineNum">     536 </span>            : </a>
<a name="537"><span class="lineNum">     537 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, ( this-&gt;GetEchoLevel() == 3)) &lt;&lt; &quot;After the solution of the system&quot; &lt;&lt; &quot;\nSystem Matrix = &quot; &lt;&lt; rA &lt;&lt; &quot;\nUnknowns vector = &quot; &lt;&lt; rDx &lt;&lt; &quot;\nRHS vector = &quot; &lt;&lt; rb &lt;&lt; std::endl;</span></a>
<a name="538"><span class="lineNum">     538 </span>            : </a>
<a name="539"><span class="lineNum">     539 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="540"><span class="lineNum">     540 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="541"><span class="lineNum">     541 </span>            : </a>
<a name="542"><span class="lineNum">     542 </span>            :     /**</a>
<a name="543"><span class="lineNum">     543 </span>            :      * @brief Corresponds to the previews, but the System's matrix is considered already built and only the RHS is built again</a>
<a name="544"><span class="lineNum">     544 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="545"><span class="lineNum">     545 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="546"><span class="lineNum">     546 </span>            :      * @param rA The LHS matrix</a>
<a name="547"><span class="lineNum">     547 </span>            :      * @param rDx The Unknowns vector</a>
<a name="548"><span class="lineNum">     548 </span>            :      * @param rb The RHS vector</a>
<a name="549"><span class="lineNum">     549 </span>            :      */</a>
<a name="550"><span class="lineNum">     550 </span><span class="lineNoCov">          0 :     void BuildRHSAndSolve(</span></a>
<a name="551"><span class="lineNum">     551 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="552"><span class="lineNum">     552 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="553"><span class="lineNum">     553 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="554"><span class="lineNum">     554 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="555"><span class="lineNum">     555 </span>            :         TSystemVectorType&amp; rb</a>
<a name="556"><span class="lineNum">     556 </span>            :         ) override</a>
<a name="557"><span class="lineNum">     557 </span>            :     {</a>
<a name="558"><span class="lineNum">     558 </span>            :         KRATOS_TRY</a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span><span class="lineNoCov">          0 :         BuildRHS(pScheme, rModelPart, rb);</span></a>
<a name="561"><span class="lineNum">     561 </span><span class="lineNoCov">          0 :         SystemSolve(rA, rDx, rb);</span></a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<a name="563"><span class="lineNum">     563 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="564"><span class="lineNum">     564 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<a name="566"><span class="lineNum">     566 </span>            :     /**</a>
<a name="567"><span class="lineNum">     567 </span>            :      * @brief Function to perform the build of the RHS.</a>
<a name="568"><span class="lineNum">     568 </span>            :      * @details The vector could be sized as the total number of dofs or as the number of unrestrained ones</a>
<a name="569"><span class="lineNum">     569 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="570"><span class="lineNum">     570 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="571"><span class="lineNum">     571 </span>            :      */</a>
<a name="572"><span class="lineNum">     572 </span><span class="lineNoCov">          0 :     void BuildRHS(</span></a>
<a name="573"><span class="lineNum">     573 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="574"><span class="lineNum">     574 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="575"><span class="lineNum">     575 </span>            :         TSystemVectorType&amp; rb</a>
<a name="576"><span class="lineNum">     576 </span>            :         ) override</a>
<a name="577"><span class="lineNum">     577 </span>            :     {</a>
<a name="578"><span class="lineNum">     578 </span>            :         KRATOS_TRY</a>
<a name="579"><span class="lineNum">     579 </span>            : </a>
<a name="580"><span class="lineNum">     580 </span>            :         // Resetting to zero the vector of reactions</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineNoCov">          0 :         if(BaseType::mCalculateReactionsFlag) {</span></a>
<a name="582"><span class="lineNum">     582 </span>            :             TSparseSpace::SetToZero(*(BaseType::mpReactionsVector));</a>
<a name="583"><span class="lineNum">     583 </span>            :         }</a>
<a name="584"><span class="lineNum">     584 </span>            : </a>
<a name="585"><span class="lineNum">     585 </span>            :         // Getting the Elements</a>
<a name="586"><span class="lineNum">     586 </span>            :         ElementsArrayType&amp; r_elements_array = rModelPart.Elements();</a>
<a name="587"><span class="lineNum">     587 </span>            : </a>
<a name="588"><span class="lineNum">     588 </span>            :         // Getting the array of the conditions</a>
<a name="589"><span class="lineNum">     589 </span>            :         ConditionsArrayType&amp; r_conditions_array = rModelPart.Conditions();</a>
<a name="590"><span class="lineNum">     590 </span>            : </a>
<a name="591"><span class="lineNum">     591 </span>            :         const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            :         // Contributions to the system</a>
<a name="594"><span class="lineNum">     594 </span>            :         LocalSystemVectorType RHS_Contribution = LocalSystemVectorType(0);</a>
<a name="595"><span class="lineNum">     595 </span>            : </a>
<a name="596"><span class="lineNum">     596 </span>            :         // Vector containing the localization in the system of the different terms</a>
<a name="597"><span class="lineNum">     597 </span>            :         EquationIdVectorType equation_id;</a>
<a name="598"><span class="lineNum">     598 </span>            : </a>
<a name="599"><span class="lineNum">     599 </span>            :         // Assemble all elements</a>
<a name="600"><span class="lineNum">     600 </span><span class="lineNoCov">          0 :         #pragma omp parallel firstprivate( RHS_Contribution, equation_id)</span></a>
<a name="601"><span class="lineNum">     601 </span>            :         {</a>
<a name="602"><span class="lineNum">     602 </span>            :             const auto it_elem_begin = r_elements_array.begin();</a>
<a name="603"><span class="lineNum">     603 </span>            :             const int nelements = static_cast&lt;int&gt;(r_elements_array.size());</a>
<a name="604"><span class="lineNum">     604 </span>            :             #pragma omp for schedule(guided, 512) nowait</a>
<a name="605"><span class="lineNum">     605 </span>            :             for (int i = 0; i &lt; nelements; ++i) {</a>
<a name="606"><span class="lineNum">     606 </span>            :                 auto it_elem = it_elem_begin + i;</a>
<a name="607"><span class="lineNum">     607 </span>            : </a>
<a name="608"><span class="lineNum">     608 </span>            :                 // If the element is active</a>
<a name="609"><span class="lineNum">     609 </span>            :                 if (it_elem-&gt;IsActive()) {</a>
<a name="610"><span class="lineNum">     610 </span>            :                     // Calculate elemental Right Hand Side Contribution</a>
<a name="611"><span class="lineNum">     611 </span>            :                     pScheme-&gt;CalculateRHSContribution(*it_elem, RHS_Contribution, equation_id, r_current_process_info);</a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            :                     // Assemble the elemental contribution</a>
<a name="614"><span class="lineNum">     614 </span>            :                     AssembleRHS(rb, RHS_Contribution, equation_id);</a>
<a name="615"><span class="lineNum">     615 </span>            :                 }</a>
<a name="616"><span class="lineNum">     616 </span>            :             }</a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span>            :             // Assemble all conditions</a>
<a name="619"><span class="lineNum">     619 </span>            :             const auto it_cond_begin = r_conditions_array.begin();</a>
<a name="620"><span class="lineNum">     620 </span>            :             const int nconditions = static_cast&lt;int&gt;(r_conditions_array.size());</a>
<a name="621"><span class="lineNum">     621 </span>            :             #pragma omp  for schedule(guided, 512)</a>
<a name="622"><span class="lineNum">     622 </span>            :             for (int i = 0; i &lt; nconditions; ++i) {</a>
<a name="623"><span class="lineNum">     623 </span>            :                 auto it_cond = it_cond_begin + i;</a>
<a name="624"><span class="lineNum">     624 </span>            :                 // If the condition is active</a>
<a name="625"><span class="lineNum">     625 </span>            :                 if (it_cond-&gt;IsActive()) {</a>
<a name="626"><span class="lineNum">     626 </span>            :                     // Calculate elemental contribution</a>
<a name="627"><span class="lineNum">     627 </span>            :                     pScheme-&gt;CalculateRHSContribution(*it_cond, RHS_Contribution, equation_id, r_current_process_info);</a>
<a name="628"><span class="lineNum">     628 </span>            : </a>
<a name="629"><span class="lineNum">     629 </span>            :                     // Assemble the elemental contribution</a>
<a name="630"><span class="lineNum">     630 </span>            :                     AssembleRHS(rb, RHS_Contribution, equation_id);</a>
<a name="631"><span class="lineNum">     631 </span>            :                 }</a>
<a name="632"><span class="lineNum">     632 </span>            :             }</a>
<a name="633"><span class="lineNum">     633 </span>            :         }</a>
<a name="634"><span class="lineNum">     634 </span>            : </a>
<a name="635"><span class="lineNum">     635 </span>            :         KRATOS_CATCH(&quot;&quot;)</a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="637"><span class="lineNum">     637 </span>            : </a>
<a name="638"><span class="lineNum">     638 </span>            :     /**</a>
<a name="639"><span class="lineNum">     639 </span>            :      * @brief Builds the list of the DofSets involved in the problem by &quot;asking&quot; to each element</a>
<a name="640"><span class="lineNum">     640 </span>            :      * and condition its Dofs.</a>
<a name="641"><span class="lineNum">     641 </span>            :      * @details The list of dofs is stores inside the BuilderAndSolver as it is closely connected to the</a>
<a name="642"><span class="lineNum">     642 </span>            :      * way the matrix and RHS are built</a>
<a name="643"><span class="lineNum">     643 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="644"><span class="lineNum">     644 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="645"><span class="lineNum">     645 </span>            :      */</a>
<a name="646"><span class="lineNum">     646 </span><span class="lineNoCov">          0 :     void SetUpDofSet(</span></a>
<a name="647"><span class="lineNum">     647 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="648"><span class="lineNum">     648 </span>            :         ModelPart&amp; rModelPart</a>
<a name="649"><span class="lineNum">     649 </span>            :         ) override</a>
<a name="650"><span class="lineNum">     650 </span>            :     {</a>
<a name="651"><span class="lineNum">     651 </span>            :         KRATOS_TRY;</a>
<a name="652"><span class="lineNum">     652 </span>            : </a>
<a name="653"><span class="lineNum">     653 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 1 &amp;&amp; rModelPart.GetCommunicator().MyPID() == 0) &lt;&lt; &quot;Setting up the dofs&quot; &lt;&lt; std::endl;</span></a>
<a name="654"><span class="lineNum">     654 </span>            : </a>
<a name="655"><span class="lineNum">     655 </span>            :         // Gets the array of elements from the modeler</a>
<a name="656"><span class="lineNum">     656 </span>            :         ElementsArrayType&amp; r_elements_array = rModelPart.Elements();</a>
<a name="657"><span class="lineNum">     657 </span><span class="lineNoCov">          0 :         const int nelements = static_cast&lt;int&gt;(r_elements_array.size());</span></a>
<a name="658"><span class="lineNum">     658 </span>            : </a>
<a name="659"><span class="lineNum">     659 </span>            :         DofsVectorType elemental_dof_list;</a>
<a name="660"><span class="lineNum">     660 </span>            : </a>
<a name="661"><span class="lineNum">     661 </span>            :         const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="662"><span class="lineNum">     662 </span>            : </a>
<a name="663"><span class="lineNum">     663 </span><span class="lineNoCov">          0 :         SizeType nthreads = ParallelUtilities::GetNumThreads();</span></a>
<a name="664"><span class="lineNum">     664 </span>            : </a>
<a name="665"><span class="lineNum">     665 </span>            :         typedef std::unordered_set &lt; NodeType::DofType::Pointer, DofPointerHasher&gt;  set_type;</a>
<a name="666"><span class="lineNum">     666 </span>            : </a>
<a name="667"><span class="lineNum">     667 </span><span class="lineNoCov">          0 :         std::vector&lt;set_type&gt; dofs_aux_list(nthreads);</span></a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; static_cast&lt;int&gt;(nthreads); ++i) {</span></a>
<a name="670"><span class="lineNum">     670 </span><span class="lineNoCov">          0 :             dofs_aux_list[i].reserve(nelements);</span></a>
<a name="671"><span class="lineNum">     671 </span>            :         }</a>
<a name="672"><span class="lineNum">     672 </span>            : </a>
<a name="673"><span class="lineNum">     673 </span><span class="lineNoCov">          0 :         IndexPartition&lt;std::size_t&gt;(nelements).for_each(elemental_dof_list, [&amp;](std::size_t Index, DofsVectorType&amp; tls_elemental_dof_list){</span></a>
<a name="674"><span class="lineNum">     674 </span>            :             auto it_elem = r_elements_array.begin() + Index;</a>
<a name="675"><span class="lineNum">     675 </span><span class="lineNoCov">          0 :             const IndexType this_thread_id = OpenMPUtils::ThisThread();</span></a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span>            :             // Gets list of Dof involved on every element</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineNoCov">          0 :             pScheme-&gt;GetDofList(*it_elem, tls_elemental_dof_list, r_current_process_info);</span></a>
<a name="679"><span class="lineNum">     679 </span>            : </a>
<a name="680"><span class="lineNum">     680 </span>            :             dofs_aux_list[this_thread_id].insert(tls_elemental_dof_list.begin(), tls_elemental_dof_list.end());</a>
<a name="681"><span class="lineNum">     681 </span>            :         });</a>
<a name="682"><span class="lineNum">     682 </span>            : </a>
<a name="683"><span class="lineNum">     683 </span>            :         ConditionsArrayType&amp; r_conditions_array = rModelPart.Conditions();</a>
<a name="684"><span class="lineNum">     684 </span><span class="lineNoCov">          0 :         const int nconditions = static_cast&lt;int&gt;(r_conditions_array.size());</span></a>
<a name="685"><span class="lineNum">     685 </span>            : </a>
<a name="686"><span class="lineNum">     686 </span><span class="lineNoCov">          0 :         IndexPartition&lt;std::size_t&gt;(nconditions).for_each(elemental_dof_list, [&amp;](std::size_t Index, DofsVectorType&amp; tls_elemental_dof_list){</span></a>
<a name="687"><span class="lineNum">     687 </span>            :             auto it_cond = r_conditions_array.begin() + Index;</a>
<a name="688"><span class="lineNum">     688 </span><span class="lineNoCov">          0 :             const IndexType this_thread_id = OpenMPUtils::ThisThread();</span></a>
<a name="689"><span class="lineNum">     689 </span>            : </a>
<a name="690"><span class="lineNum">     690 </span>            :             // Gets list of Dof involved on every element</a>
<a name="691"><span class="lineNum">     691 </span><span class="lineNoCov">          0 :             pScheme-&gt;GetDofList(*it_cond, tls_elemental_dof_list, r_current_process_info);</span></a>
<a name="692"><span class="lineNum">     692 </span>            :             dofs_aux_list[this_thread_id].insert(tls_elemental_dof_list.begin(), tls_elemental_dof_list.end());</a>
<a name="693"><span class="lineNum">     693 </span>            :         });</a>
<a name="694"><span class="lineNum">     694 </span>            : </a>
<a name="695"><span class="lineNum">     695 </span>            :         // Here we do a reduction in a tree so to have everything on thread 0</a>
<a name="696"><span class="lineNum">     696 </span><span class="lineNoCov">          0 :         SizeType old_max = nthreads;</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineNoCov">          0 :         SizeType new_max = ceil(0.5*static_cast&lt;double&gt;(old_max));</span></a>
<a name="698"><span class="lineNum">     698 </span><span class="lineNoCov">          0 :         while (new_max &gt;= 1 &amp;&amp; new_max != old_max) {</span></a>
<a name="699"><span class="lineNum">     699 </span><span class="lineNoCov">          0 :             IndexPartition&lt;std::size_t&gt;(new_max).for_each([&amp;](std::size_t Index){</span></a>
<a name="700"><span class="lineNum">     700 </span><span class="lineNoCov">          0 :                 if (Index + new_max &lt; old_max) {</span></a>
<a name="701"><span class="lineNum">     701 </span>            :                     dofs_aux_list[Index].insert(dofs_aux_list[Index + new_max].begin(), dofs_aux_list[Index + new_max].end());</a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :                     dofs_aux_list[Index + new_max].clear();</span></a>
<a name="703"><span class="lineNum">     703 </span>            :                 }</a>
<a name="704"><span class="lineNum">     704 </span>            :             });</a>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<a name="706"><span class="lineNum">     706 </span><span class="lineNoCov">          0 :             old_max = new_max;</span></a>
<a name="707"><span class="lineNum">     707 </span><span class="lineNoCov">          0 :             new_max = ceil(0.5*static_cast&lt;double&gt;(old_max));</span></a>
<a name="708"><span class="lineNum">     708 </span>            :         }</a>
<a name="709"><span class="lineNum">     709 </span>            : </a>
<a name="710"><span class="lineNum">     710 </span>            :         DofsArrayType dof_temp;</a>
<a name="711"><span class="lineNum">     711 </span><span class="lineNoCov">          0 :         BaseType::mDofSet = DofsArrayType();</span></a>
<a name="712"><span class="lineNum">     712 </span>            : </a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 :         dof_temp.reserve(dofs_aux_list[0].size());</span></a>
<a name="714"><span class="lineNum">     714 </span><span class="lineNoCov">          0 :         for (auto it = dofs_aux_list[0].begin(); it != dofs_aux_list[0].end(); ++it) {</span></a>
<a name="715"><span class="lineNum">     715 </span><span class="lineNoCov">          0 :             dof_temp.push_back(*it);</span></a>
<a name="716"><span class="lineNum">     716 </span>            :         }</a>
<a name="717"><span class="lineNum">     717 </span><span class="lineNoCov">          0 :         dof_temp.Sort();</span></a>
<a name="718"><span class="lineNum">     718 </span>            : </a>
<a name="719"><span class="lineNum">     719 </span>            :         BaseType::mDofSet = dof_temp;</a>
<a name="720"><span class="lineNum">     720 </span>            : </a>
<a name="721"><span class="lineNum">     721 </span>            :         // Throws an exception if there are no Degrees of freedom involved in the analysis</a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :         KRATOS_ERROR_IF(BaseType::mDofSet.size() == 0) &lt;&lt; &quot;No degrees of freedom!&quot; &lt;&lt; std::endl;</span></a>
<a name="723"><span class="lineNum">     723 </span>            : </a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :         BaseType::mDofSetIsInitialized = true;</span></a>
<a name="725"><span class="lineNum">     725 </span>            : </a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 2 &amp;&amp; rModelPart.GetCommunicator().MyPID() == 0) &lt;&lt; &quot;Finished setting up the dofs&quot; &lt;&lt; std::endl;</span></a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="729"><span class="lineNum">     729 </span>            :         if (mLockArray.size() != 0) {</a>
<a name="730"><span class="lineNum">     730 </span>            :             for (int i = 0; i &lt; static_cast&lt;int&gt;(mLockArray.size()); i++)</a>
<a name="731"><span class="lineNum">     731 </span>            :                 omp_destroy_lock(&amp;mLockArray[i]);</a>
<a name="732"><span class="lineNum">     732 </span>            :         }</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            :         mLockArray.resize(BaseType::mDofSet.size());</a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span>            :         for (int i = 0; i &lt; static_cast&lt;int&gt;(mLockArray.size()); i++)</a>
<a name="737"><span class="lineNum">     737 </span>            :             omp_init_lock(&amp;mLockArray[i]);</a>
<a name="738"><span class="lineNum">     738 </span>            : #endif</a>
<a name="739"><span class="lineNum">     739 </span>            : </a>
<a name="740"><span class="lineNum">     740 </span>            :         // If reactions are to be calculated, we check if all the dofs have reactions defined</a>
<a name="741"><span class="lineNum">     741 </span>            :         // This is tobe done only in debug mode</a>
<a name="742"><span class="lineNum">     742 </span>            : #ifdef KRATOS_DEBUG</a>
<a name="743"><span class="lineNum">     743 </span>            :         if(BaseType::GetCalculateReactionsFlag()) {</a>
<a name="744"><span class="lineNum">     744 </span>            :             for(auto dof_iterator = BaseType::mDofSet.begin(); dof_iterator != BaseType::mDofSet.end(); ++dof_iterator) {</a>
<a name="745"><span class="lineNum">     745 </span>            :                     KRATOS_ERROR_IF_NOT(dof_iterator-&gt;HasReaction()) &lt;&lt; &quot;Reaction variable not set for the following : &quot; &lt;&lt; std::endl</a>
<a name="746"><span class="lineNum">     746 </span>            :                         &lt;&lt; &quot;Node : &quot; &lt;&lt; dof_iterator-&gt;Id() &lt;&lt; std::endl</a>
<a name="747"><span class="lineNum">     747 </span>            :                         &lt;&lt; &quot;Dof : &quot; &lt;&lt; (*dof_iterator) &lt;&lt; std::endl &lt;&lt; &quot;Not possible to calculate reactions.&quot; &lt;&lt; std::endl;</a>
<a name="748"><span class="lineNum">     748 </span>            :             }</a>
<a name="749"><span class="lineNum">     749 </span>            :         }</a>
<a name="750"><span class="lineNum">     750 </span>            : #endif</a>
<a name="751"><span class="lineNum">     751 </span>            : </a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;);</span></a>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="754"><span class="lineNum">     754 </span>            : </a>
<a name="755"><span class="lineNum">     755 </span>            :     /**</a>
<a name="756"><span class="lineNum">     756 </span>            :      * @brief Organises the dofset in order to speed up the building phase</a>
<a name="757"><span class="lineNum">     757 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="758"><span class="lineNum">     758 </span>            :      */</a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :     void SetUpSystem(ModelPart&amp; rModelPart) override</span></a>
<a name="760"><span class="lineNum">     760 </span>            :     {</a>
<a name="761"><span class="lineNum">     761 </span>            :         // Set equation id for degrees of freedom</a>
<a name="762"><span class="lineNum">     762 </span>            :         // the free degrees of freedom are positioned at the beginning of the system,</a>
<a name="763"><span class="lineNum">     763 </span>            :         // while the fixed one are at the end (in opposite order).</a>
<a name="764"><span class="lineNum">     764 </span>            :         //</a>
<a name="765"><span class="lineNum">     765 </span>            :         // that means that if the EquationId is greater than &quot;mEquationSystemSize&quot;</a>
<a name="766"><span class="lineNum">     766 </span>            :         // the pointed degree of freedom is restrained</a>
<a name="767"><span class="lineNum">     767 </span>            :         //</a>
<a name="768"><span class="lineNum">     768 </span>            :         int free_id = 0;</a>
<a name="769"><span class="lineNum">     769 </span><span class="lineNoCov">          0 :         int fix_id = BaseType::mDofSet.size();</span></a>
<a name="770"><span class="lineNum">     770 </span>            : </a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :         for (auto dof_iterator = BaseType::mDofSet.begin(); dof_iterator != BaseType::mDofSet.end(); ++dof_iterator)</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineNoCov">          0 :             if (dof_iterator-&gt;IsFixed())</span></a>
<a name="773"><span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 dof_iterator-&gt;SetEquationId(--fix_id);</span></a>
<a name="774"><span class="lineNum">     774 </span>            :             else</a>
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 :                 dof_iterator-&gt;SetEquationId(free_id++);</span></a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :         BaseType::mEquationSystemSize = fix_id;</span></a>
<a name="778"><span class="lineNum">     778 </span>            : </a>
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<a name="781"><span class="lineNum">     781 </span>            :     /**</a>
<a name="782"><span class="lineNum">     782 </span>            :      * @brief This method resize and initializes the system of euqations</a>
<a name="783"><span class="lineNum">     783 </span>            :      * @param pA The pointer to the LHS matrix</a>
<a name="784"><span class="lineNum">     784 </span>            :      * @param pDx The pointer to the vector of Unknowns</a>
<a name="785"><span class="lineNum">     785 </span>            :      * @param pb The pointer to the RHS vector</a>
<a name="786"><span class="lineNum">     786 </span>            :      * @param rModelPart The model part to be computed</a>
<a name="787"><span class="lineNum">     787 </span>            :      */</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :     void ResizeAndInitializeVectors(</span></a>
<a name="789"><span class="lineNum">     789 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="790"><span class="lineNum">     790 </span>            :         TSystemMatrixPointerType&amp; pA,</a>
<a name="791"><span class="lineNum">     791 </span>            :         TSystemVectorPointerType&amp; pDx,</a>
<a name="792"><span class="lineNum">     792 </span>            :         TSystemVectorPointerType&amp; pb,</a>
<a name="793"><span class="lineNum">     793 </span>            :         ModelPart&amp; rModelPart</a>
<a name="794"><span class="lineNum">     794 </span>            :         ) override</a>
<a name="795"><span class="lineNum">     795 </span>            :     {</a>
<a name="796"><span class="lineNum">     796 </span>            :         KRATOS_TRY</a>
<a name="797"><span class="lineNum">     797 </span>            : </a>
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :         if (pA == nullptr) { // If the pointer is not initialized initialize it to an empty matrix</span></a>
<a name="799"><span class="lineNum">     799 </span>            : </a>
<a name="800"><span class="lineNum">     800 </span><span class="lineNoCov">          0 :             TSystemMatrixPointerType pNewA = TSystemMatrixPointerType(new TSystemMatrixType(0, 0));</span></a>
<a name="801"><span class="lineNum">     801 </span>            :             pA.swap(pNewA);</a>
<a name="802"><span class="lineNum">     802 </span>            :         }</a>
<a name="803"><span class="lineNum">     803 </span><span class="lineNoCov">          0 :         if (pDx == nullptr) { // If the pointer is not initialized initialize it to an empty matrix</span></a>
<a name="804"><span class="lineNum">     804 </span>            : </a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :             TSystemVectorPointerType pNewDx = TSystemVectorPointerType(new TSystemVectorType(0));</span></a>
<a name="806"><span class="lineNum">     806 </span>            :             pDx.swap(pNewDx);</a>
<a name="807"><span class="lineNum">     807 </span>            :         }</a>
<a name="808"><span class="lineNum">     808 </span><span class="lineNoCov">          0 :         if (pb == nullptr) { // If the pointer is not initialized initialize it to an empty matrix</span></a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span><span class="lineNoCov">          0 :             TSystemVectorPointerType pNewb = TSystemVectorPointerType(new TSystemVectorType(0));</span></a>
<a name="811"><span class="lineNum">     811 </span>            :             pb.swap(pNewb);</a>
<a name="812"><span class="lineNum">     812 </span>            :         }</a>
<a name="813"><span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (BaseType::mpReactionsVector == nullptr) { // If the pointer is not initialized initialize it to an empty matrix</span></a>
<a name="814"><span class="lineNum">     814 </span>            : </a>
<a name="815"><span class="lineNum">     815 </span><span class="lineNoCov">          0 :             TSystemVectorPointerType pNewReactionsVector = TSystemVectorPointerType(new TSystemVectorType(0));</span></a>
<a name="816"><span class="lineNum">     816 </span>            :             BaseType::mpReactionsVector.swap(pNewReactionsVector);</a>
<a name="817"><span class="lineNum">     817 </span>            :         }</a>
<a name="818"><span class="lineNum">     818 </span>            : </a>
<a name="819"><span class="lineNum">     819 </span>            :         TSystemMatrixType&amp; rA = *pA;</a>
<a name="820"><span class="lineNum">     820 </span>            :         TSystemVectorType&amp; rDx = *pDx;</a>
<a name="821"><span class="lineNum">     821 </span>            :         TSystemVectorType&amp; rb = *pb;</a>
<a name="822"><span class="lineNum">     822 </span>            : </a>
<a name="823"><span class="lineNum">     823 </span>            :         // Resizing the system vectors and matrix</a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :         if (rA.size1() == 0 || BaseType::GetReshapeMatrixFlag()) { // If the matrix is not initialized</span></a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :             rA.resize(BaseType::mEquationSystemSize, BaseType::mEquationSystemSize, false);</span></a>
<a name="826"><span class="lineNum">     826 </span><span class="lineNoCov">          0 :             ConstructMatrixStructure(pScheme, rA, rModelPart);</span></a>
<a name="827"><span class="lineNum">     827 </span>            :         } else {</a>
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 :             if (rA.size1() != BaseType::mEquationSystemSize || rA.size2() != BaseType::mEquationSystemSize) {</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineNoCov">          0 :                 KRATOS_ERROR &lt;&lt;&quot;The equation system size has changed during the simulation. This is not permitted.&quot;&lt;&lt;std::endl;</span></a>
<a name="830"><span class="lineNum">     830 </span>            :                 rA.resize(BaseType::mEquationSystemSize, BaseType::mEquationSystemSize, true);</a>
<a name="831"><span class="lineNum">     831 </span>            :                 ConstructMatrixStructure(pScheme, rA, rModelPart);</a>
<a name="832"><span class="lineNum">     832 </span>            :             }</a>
<a name="833"><span class="lineNum">     833 </span>            :         }</a>
<a name="834"><span class="lineNum">     834 </span><span class="lineNoCov">          0 :         if (rDx.size() != BaseType::mEquationSystemSize) {</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineNoCov">          0 :             rDx.resize(BaseType::mEquationSystemSize, false);</span></a>
<a name="836"><span class="lineNum">     836 </span>            :         }</a>
<a name="837"><span class="lineNum">     837 </span>            :         TSparseSpace::SetToZero(rDx);</a>
<a name="838"><span class="lineNum">     838 </span><span class="lineNoCov">          0 :         if (rb.size() != BaseType::mEquationSystemSize) {</span></a>
<a name="839"><span class="lineNum">     839 </span><span class="lineNoCov">          0 :             rb.resize(BaseType::mEquationSystemSize, false);</span></a>
<a name="840"><span class="lineNum">     840 </span>            :         }</a>
<a name="841"><span class="lineNum">     841 </span>            :         TSparseSpace::SetToZero(rb);</a>
<a name="842"><span class="lineNum">     842 </span>            : </a>
<a name="843"><span class="lineNum">     843 </span>            :         //if needed resize the vector for the calculation of reactions</a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 :         if (BaseType::mCalculateReactionsFlag == true) {</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :             const std::size_t reactions_vector_size = BaseType::mDofSet.size() - BaseType::mEquationSystemSize;</span></a>
<a name="846"><span class="lineNum">     846 </span><span class="lineNoCov">          0 :             if (BaseType::mpReactionsVector-&gt;size() != reactions_vector_size)</span></a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :                 BaseType::mpReactionsVector-&gt;resize(reactions_vector_size, false);</span></a>
<a name="848"><span class="lineNum">     848 </span>            :         }</a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="851"><span class="lineNum">     851 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="852"><span class="lineNum">     852 </span>            : </a>
<a name="853"><span class="lineNum">     853 </span>            : </a>
<a name="854"><span class="lineNum">     854 </span>            :     /**</a>
<a name="855"><span class="lineNum">     855 </span>            :      * @brief This method computes the reactions</a>
<a name="856"><span class="lineNum">     856 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="857"><span class="lineNum">     857 </span>            :      * @param rModelPart The model part considered</a>
<a name="858"><span class="lineNum">     858 </span>            :      * @param rA The LHS of the system</a>
<a name="859"><span class="lineNum">     859 </span>            :      * @param rDx The vector of Unknowns</a>
<a name="860"><span class="lineNum">     860 </span>            :      * @param rb The RHS vector</a>
<a name="861"><span class="lineNum">     861 </span>            :      */</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineNoCov">          0 :     void CalculateReactions(</span></a>
<a name="863"><span class="lineNum">     863 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="864"><span class="lineNum">     864 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="865"><span class="lineNum">     865 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="866"><span class="lineNum">     866 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="867"><span class="lineNum">     867 </span>            :         TSystemVectorType&amp; rb</a>
<a name="868"><span class="lineNum">     868 </span>            :         ) override</a>
<a name="869"><span class="lineNum">     869 </span>            :     {</a>
<a name="870"><span class="lineNum">     870 </span>            :         //refresh RHS to have the correct reactions</a>
<a name="871"><span class="lineNum">     871 </span><span class="lineNoCov">          0 :         BuildRHS(pScheme, rModelPart, rb);</span></a>
<a name="872"><span class="lineNum">     872 </span>            : </a>
<a name="873"><span class="lineNum">     873 </span>            :         // Updating variables</a>
<a name="874"><span class="lineNum">     874 </span>            :         std::size_t i;</a>
<a name="875"><span class="lineNum">     875 </span>            :         TSystemVectorType&amp; r_reactions_vector = *BaseType::mpReactionsVector;</a>
<a name="876"><span class="lineNum">     876 </span><span class="lineNoCov">          0 :         for (auto it2 = BaseType::mDofSet.ptr_begin(); it2 != BaseType::mDofSet.ptr_end(); ++it2) {</span></a>
<a name="877"><span class="lineNum">     877 </span><span class="lineNoCov">          0 :             i = (*it2)-&gt;EquationId();</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineNoCov">          0 :             if (i &gt;= BaseType::mEquationSystemSize) {</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 :                 i -= BaseType::mEquationSystemSize;</span></a>
<a name="880"><span class="lineNum">     880 </span><span class="lineNoCov">          0 :                 (*it2)-&gt;GetSolutionStepReactionValue() = -r_reactions_vector[i];</span></a>
<a name="881"><span class="lineNum">     881 </span>            :             }</a>
<a name="882"><span class="lineNum">     882 </span>            : </a>
<a name="883"><span class="lineNum">     883 </span>            :         }</a>
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="885"><span class="lineNum">     885 </span>            : </a>
<a name="886"><span class="lineNum">     886 </span>            :     /**</a>
<a name="887"><span class="lineNum">     887 </span>            :      * @brief Applies the dirichlet conditions. This operation may be very heavy or completely</a>
<a name="888"><span class="lineNum">     888 </span>            :      * unexpensive depending on the implementation chosen and on how the System Matrix is built.</a>
<a name="889"><span class="lineNum">     889 </span>            :      * @details For explanation of how it works for a particular implementation the user</a>
<a name="890"><span class="lineNum">     890 </span>            :      * should refer to the particular Builder And Solver chosen</a>
<a name="891"><span class="lineNum">     891 </span>            :      * @param pScheme The integration scheme considered</a>
<a name="892"><span class="lineNum">     892 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="893"><span class="lineNum">     893 </span>            :      * @param rA The LHS matrix</a>
<a name="894"><span class="lineNum">     894 </span>            :      * @param rDx The Unknowns vector</a>
<a name="895"><span class="lineNum">     895 </span>            :      * @param rb The RHS vector</a>
<a name="896"><span class="lineNum">     896 </span>            :      */</a>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 :     void ApplyDirichletConditions(</span></a>
<a name="898"><span class="lineNum">     898 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="899"><span class="lineNum">     899 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="900"><span class="lineNum">     900 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="901"><span class="lineNum">     901 </span>            :         TSystemVectorType&amp; rDx,</a>
<a name="902"><span class="lineNum">     902 </span>            :         TSystemVectorType&amp; rb</a>
<a name="903"><span class="lineNum">     903 </span>            :         ) override</a>
<a name="904"><span class="lineNum">     904 </span>            :     {</a>
<a name="905"><span class="lineNum">     905 </span>            :         // Detect if there is a line of all zeros and set the diagonal to a 1 if this happens</a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :         mScaleFactor = TSparseSpace::CheckAndCorrectZeroDiagonalValues(rModelPart.GetProcessInfo(), rA, rb, mScalingDiagonal); </span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="908"><span class="lineNum">     908 </span>            : </a>
<a name="909"><span class="lineNum">     909 </span>            :     /**</a>
<a name="910"><span class="lineNum">     910 </span>            :      * @brief This function is intended to be called at the end of the solution step to clean up memory storage not needed</a>
<a name="911"><span class="lineNum">     911 </span>            :      */</a>
<a name="912"><span class="lineNum">     912 </span><span class="lineNoCov">          0 :     void Clear() override</span></a>
<a name="913"><span class="lineNum">     913 </span>            :     {</a>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 :         this-&gt;mDofSet = DofsArrayType();</span></a>
<a name="915"><span class="lineNum">     915 </span>            :         this-&gt;mpReactionsVector.reset();</a>
<a name="916"><span class="lineNum">     916 </span>            : //             this-&gt;mReactionsVector = TSystemVectorType();</a>
<a name="917"><span class="lineNum">     917 </span>            : </a>
<a name="918"><span class="lineNum">     918 </span><span class="lineNoCov">          0 :         this-&gt;mpLinearSystemSolver-&gt;Clear();</span></a>
<a name="919"><span class="lineNum">     919 </span>            : </a>
<a name="920"><span class="lineNum">     920 </span><span class="lineNoCov">          0 :         KRATOS_INFO_IF(&quot;ResidualBasedEliminationBuilderAndSolver&quot;, this-&gt;GetEchoLevel() &gt; 1) &lt;&lt; &quot;Clear Function called&quot; &lt;&lt; std::endl;</span></a>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="922"><span class="lineNum">     922 </span>            : </a>
<a name="923"><span class="lineNum">     923 </span>            :     /**</a>
<a name="924"><span class="lineNum">     924 </span>            :      * @brief This function is designed to be called once to perform all the checks needed</a>
<a name="925"><span class="lineNum">     925 </span>            :      * on the input provided. Checks can be &quot;expensive&quot; as the function is designed</a>
<a name="926"><span class="lineNum">     926 </span>            :      * to catch user's errors.</a>
<a name="927"><span class="lineNum">     927 </span>            :      * @param rModelPart The model part of the problem to solve</a>
<a name="928"><span class="lineNum">     928 </span>            :      * @return 0 all ok</a>
<a name="929"><span class="lineNum">     929 </span>            :      */</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :     int Check(ModelPart&amp; rModelPart) override</span></a>
<a name="931"><span class="lineNum">     931 </span>            :     {</a>
<a name="932"><span class="lineNum">     932 </span>            :         KRATOS_TRY</a>
<a name="933"><span class="lineNum">     933 </span>            : </a>
<a name="934"><span class="lineNum">     934 </span><span class="lineNoCov">          0 :         return 0;</span></a>
<a name="935"><span class="lineNum">     935 </span>            :         KRATOS_CATCH(&quot;&quot;);</a>
<a name="936"><span class="lineNum">     936 </span>            :     }</a>
<a name="937"><span class="lineNum">     937 </span>            : </a>
<a name="938"><span class="lineNum">     938 </span>            :     /**</a>
<a name="939"><span class="lineNum">     939 </span>            :      * @brief This method provides the defaults parameters to avoid conflicts between the different constructors</a>
<a name="940"><span class="lineNum">     940 </span>            :      * @return The default parameters</a>
<a name="941"><span class="lineNum">     941 </span>            :      */</a>
<a name="942"><span class="lineNum">     942 </span><span class="lineNoCov">          0 :     Parameters GetDefaultParameters() const override</span></a>
<a name="943"><span class="lineNum">     943 </span>            :     {</a>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 :         Parameters default_parameters = Parameters(R&quot;(</span></a>
<a name="945"><span class="lineNum">     945 </span>            :         {</a>
<a name="946"><span class="lineNum">     946 </span>            :             &quot;name&quot;                                 : &quot;elimination_builder_and_solver&quot;,</a>
<a name="947"><span class="lineNum">     947 </span>            :             &quot;block_builder&quot;                        : false,</a>
<a name="948"><span class="lineNum">     948 </span>            :             &quot;diagonal_values_for_dirichlet_dofs&quot;   : &quot;use_max_diagonal&quot;</a>
<a name="949"><span class="lineNum">     949 </span>            :         })&quot;);</a>
<a name="950"><span class="lineNum">     950 </span>            : </a>
<a name="951"><span class="lineNum">     951 </span>            :         // Getting base class default parameters</a>
<a name="952"><span class="lineNum">     952 </span><span class="lineNoCov">          0 :         const Parameters base_default_parameters = BaseType::GetDefaultParameters();</span></a>
<a name="953"><span class="lineNum">     953 </span><span class="lineNoCov">          0 :         default_parameters.RecursivelyAddMissingParameters(base_default_parameters);</span></a>
<a name="954"><span class="lineNum">     954 </span><span class="lineNoCov">          0 :         return default_parameters;</span></a>
<a name="955"><span class="lineNum">     955 </span>            :     }</a>
<a name="956"><span class="lineNum">     956 </span>            : </a>
<a name="957"><span class="lineNum">     957 </span>            :     /**</a>
<a name="958"><span class="lineNum">     958 </span>            :      * @brief Returns the name of the class as used in the settings (snake_case format)</a>
<a name="959"><span class="lineNum">     959 </span>            :      * @return The name of the class</a>
<a name="960"><span class="lineNum">     960 </span>            :      */</a>
<a name="961"><span class="lineNum">     961 </span>            :     static std::string Name()</a>
<a name="962"><span class="lineNum">     962 </span>            :     {</a>
<a name="963"><span class="lineNum">     963 </span>            :         return &quot;elimination_builder_and_solver&quot;;</a>
<a name="964"><span class="lineNum">     964 </span>            :     }</a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span>            :     ///@}</a>
<a name="967"><span class="lineNum">     967 </span>            :     ///@name Access</a>
<a name="968"><span class="lineNum">     968 </span>            :     ///@{</a>
<a name="969"><span class="lineNum">     969 </span>            : </a>
<a name="970"><span class="lineNum">     970 </span>            :     ///@}</a>
<a name="971"><span class="lineNum">     971 </span>            :     ///@name Inquiry</a>
<a name="972"><span class="lineNum">     972 </span>            :     ///@{</a>
<a name="973"><span class="lineNum">     973 </span>            : </a>
<a name="974"><span class="lineNum">     974 </span>            :     ///@}</a>
<a name="975"><span class="lineNum">     975 </span>            :     ///@name Input and output</a>
<a name="976"><span class="lineNum">     976 </span>            :     ///@{</a>
<a name="977"><span class="lineNum">     977 </span>            : </a>
<a name="978"><span class="lineNum">     978 </span>            :     /// Turn back information as a string.</a>
<a name="979"><span class="lineNum">     979 </span><span class="lineNoCov">          0 :     std::string Info() const override</span></a>
<a name="980"><span class="lineNum">     980 </span>            :     {</a>
<a name="981"><span class="lineNum">     981 </span><span class="lineNoCov">          0 :         return &quot;ResidualBasedEliminationBuilderAndSolver&quot;;</span></a>
<a name="982"><span class="lineNum">     982 </span>            :     }</a>
<a name="983"><span class="lineNum">     983 </span>            : </a>
<a name="984"><span class="lineNum">     984 </span>            :     /// Print information about this object.</a>
<a name="985"><span class="lineNum">     985 </span><span class="lineNoCov">          0 :     void PrintInfo(std::ostream&amp; rOStream) const override</span></a>
<a name="986"><span class="lineNum">     986 </span>            :     {</a>
<a name="987"><span class="lineNum">     987 </span><span class="lineNoCov">          0 :         rOStream &lt;&lt; Info();</span></a>
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="989"><span class="lineNum">     989 </span>            : </a>
<a name="990"><span class="lineNum">     990 </span>            :     /// Print object's data.</a>
<a name="991"><span class="lineNum">     991 </span><span class="lineNoCov">          0 :     void PrintData(std::ostream&amp; rOStream) const override</span></a>
<a name="992"><span class="lineNum">     992 </span>            :     {</a>
<a name="993"><span class="lineNum">     993 </span><span class="lineNoCov">          0 :         rOStream &lt;&lt; Info();</span></a>
<a name="994"><span class="lineNum">     994 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="995"><span class="lineNum">     995 </span>            : </a>
<a name="996"><span class="lineNum">     996 </span>            :     ///@}</a>
<a name="997"><span class="lineNum">     997 </span>            :     ///@name Friends</a>
<a name="998"><span class="lineNum">     998 </span>            :     ///@{</a>
<a name="999"><span class="lineNum">     999 </span>            : </a>
<a name="1000"><span class="lineNum">    1000 </span>            :     ///@}</a>
<a name="1001"><span class="lineNum">    1001 </span>            : </a>
<a name="1002"><span class="lineNum">    1002 </span>            : protected:</a>
<a name="1003"><span class="lineNum">    1003 </span>            :     ///@name Protected static Member Variables</a>
<a name="1004"><span class="lineNum">    1004 </span>            :     ///@{</a>
<a name="1005"><span class="lineNum">    1005 </span>            : </a>
<a name="1006"><span class="lineNum">    1006 </span>            :     ///@}</a>
<a name="1007"><span class="lineNum">    1007 </span>            :     ///@name Protected member Variables</a>
<a name="1008"><span class="lineNum">    1008 </span>            :     ///@{</a>
<a name="1009"><span class="lineNum">    1009 </span>            : </a>
<a name="1010"><span class="lineNum">    1010 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1011"><span class="lineNum">    1011 </span>            :    std::vector&lt;omp_lock_t&gt; mLockArray; /// TODO: Replace with std::vector&lt;LockObject&gt;</a>
<a name="1012"><span class="lineNum">    1012 </span>            : #endif</a>
<a name="1013"><span class="lineNum">    1013 </span>            : </a>
<a name="1014"><span class="lineNum">    1014 </span>            :     double mScaleFactor = 1.0;         /// The manually set scale factor</a>
<a name="1015"><span class="lineNum">    1015 </span>            : </a>
<a name="1016"><span class="lineNum">    1016 </span>            :     SCALING_DIAGONAL mScalingDiagonal = SCALING_DIAGONAL::NO_SCALING;; /// We identify the scaling considered for the dirichlet dofs</a>
<a name="1017"><span class="lineNum">    1017 </span>            : </a>
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<a name="1019"><span class="lineNum">    1019 </span>            :     ///@}</a>
<a name="1020"><span class="lineNum">    1020 </span>            :     ///@name Protected Operators</a>
<a name="1021"><span class="lineNum">    1021 </span>            :     ///@{</a>
<a name="1022"><span class="lineNum">    1022 </span>            : </a>
<a name="1023"><span class="lineNum">    1023 </span>            :     ///@}</a>
<a name="1024"><span class="lineNum">    1024 </span>            :     ///@name Protected Operations</a>
<a name="1025"><span class="lineNum">    1025 </span>            :     ///@{</a>
<a name="1026"><span class="lineNum">    1026 </span>            : </a>
<a name="1027"><span class="lineNum">    1027 </span>            :    /**</a>
<a name="1028"><span class="lineNum">    1028 </span>            :     * @brief This method assembles the system</a>
<a name="1029"><span class="lineNum">    1029 </span>            :     * @param rA The LHS of the system</a>
<a name="1030"><span class="lineNum">    1030 </span>            :     * @param rb The RHS of the system</a>
<a name="1031"><span class="lineNum">    1031 </span>            :     * @param rLHSContribution The LHS local contribution</a>
<a name="1032"><span class="lineNum">    1032 </span>            :     * @param rRHSContribution The RHS local contribution</a>
<a name="1033"><span class="lineNum">    1033 </span>            :     * @param rEquationId The equation id</a>
<a name="1034"><span class="lineNum">    1034 </span>            :     * @param rLockArray The lock of the dof</a>
<a name="1035"><span class="lineNum">    1035 </span>            :     * @note The main difference respect the block builder and solver is the fact that the fixed DoFs are not considered on the assembling</a>
<a name="1036"><span class="lineNum">    1036 </span>            :     */</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineNoCov">          0 :     void Assemble(</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="1039"><span class="lineNum">    1039 </span>            :         TSystemVectorType&amp; rb,</a>
<a name="1040"><span class="lineNum">    1040 </span>            :         const LocalSystemMatrixType&amp; rLHSContribution,</a>
<a name="1041"><span class="lineNum">    1041 </span>            :         const LocalSystemVectorType&amp; rRHSContribution,</a>
<a name="1042"><span class="lineNum">    1042 </span>            :         const Element::EquationIdVectorType&amp; rEquationId</a>
<a name="1043"><span class="lineNum">    1043 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1044"><span class="lineNum">    1044 </span>            :         ,std::vector&lt; omp_lock_t &gt;&amp; rLockArray</a>
<a name="1045"><span class="lineNum">    1045 </span>            : #endif</a>
<a name="1046"><span class="lineNum">    1046 </span>            :         )</a>
<a name="1047"><span class="lineNum">    1047 </span>            :     {</a>
<a name="1048"><span class="lineNum">    1048 </span>            :         const SizeType local_size = rLHSContribution.size1();</a>
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<a name="1050"><span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         for (IndexType i_local = 0; i_local &lt; local_size; ++i_local) {</span></a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineNoCov">          0 :             const IndexType i_global = rEquationId[i_local];</span></a>
<a name="1052"><span class="lineNum">    1052 </span>            : </a>
<a name="1053"><span class="lineNum">    1053 </span><span class="lineNoCov">          0 :             if (i_global &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1054"><span class="lineNum">    1054 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1055"><span class="lineNum">    1055 </span>            :                 omp_set_lock(&amp;rLockArray[i_global]);</a>
<a name="1056"><span class="lineNum">    1056 </span>            :                 rb[i_global] += rRHSContribution(i_local);</a>
<a name="1057"><span class="lineNum">    1057 </span>            : #else</a>
<a name="1058"><span class="lineNum">    1058 </span>            :                 double&amp; r_a = rb[i_global];</a>
<a name="1059"><span class="lineNum">    1059 </span>            :                 const double&amp; v_a = rRHSContribution(i_local);</a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineNoCov">          0 :                 AtomicAdd(r_a, v_a);</span></a>
<a name="1061"><span class="lineNum">    1061 </span>            : #endif</a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineNoCov">          0 :                 AssembleRowContributionFreeDofs(rA, rLHSContribution, i_global, i_local, rEquationId);</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            : </a>
<a name="1064"><span class="lineNum">    1064 </span>            : #ifdef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1065"><span class="lineNum">    1065 </span>            :                 omp_unset_lock(&amp;rLockArray[i_global]);</a>
<a name="1066"><span class="lineNum">    1066 </span>            : #endif</a>
<a name="1067"><span class="lineNum">    1067 </span>            :             }</a>
<a name="1068"><span class="lineNum">    1068 </span>            :             //note that computation of reactions is not performed here!</a>
<a name="1069"><span class="lineNum">    1069 </span>            :         }</a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1071"><span class="lineNum">    1071 </span>            : </a>
<a name="1072"><span class="lineNum">    1072 </span>            :     /**</a>
<a name="1073"><span class="lineNum">    1073 </span>            :      * @brief This method constructs the relationship between the DoF</a>
<a name="1074"><span class="lineNum">    1074 </span>            :      * @param pScheme The integration scheme</a>
<a name="1075"><span class="lineNum">    1075 </span>            :      * @param rA The LHS of the system</a>
<a name="1076"><span class="lineNum">    1076 </span>            :      * @param rModelPart The model part which defines the problem</a>
<a name="1077"><span class="lineNum">    1077 </span>            :      */</a>
<a name="1078"><span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     virtual void ConstructMatrixStructure(</span></a>
<a name="1079"><span class="lineNum">    1079 </span>            :         typename TSchemeType::Pointer pScheme,</a>
<a name="1080"><span class="lineNum">    1080 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="1081"><span class="lineNum">    1081 </span>            :         ModelPart&amp; rModelPart</a>
<a name="1082"><span class="lineNum">    1082 </span>            :         )</a>
<a name="1083"><span class="lineNum">    1083 </span>            :     {</a>
<a name="1084"><span class="lineNum">    1084 </span>            :         // Filling with zero the matrix (creating the structure)</a>
<a name="1085"><span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         Timer::Start(&quot;MatrixStructure&quot;);</span></a>
<a name="1086"><span class="lineNum">    1086 </span>            : </a>
<a name="1087"><span class="lineNum">    1087 </span><span class="lineNoCov">          0 :         const SizeType equation_size = BaseType::mEquationSystemSize;</span></a>
<a name="1088"><span class="lineNum">    1088 </span>            : </a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineNoCov">          0 :         std::vector&lt;std::unordered_set&lt;IndexType&gt; &gt; indices(equation_size);</span></a>
<a name="1090"><span class="lineNum">    1090 </span>            : </a>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineNoCov">          0 :         block_for_each(indices, [](std::unordered_set&lt;IndexType&gt;&amp; rIndices){</span></a>
<a name="1092"><span class="lineNum">    1092 </span>            :             rIndices.reserve(40);</a>
<a name="1093"><span class="lineNum">    1093 </span>            :         });</a>
<a name="1094"><span class="lineNum">    1094 </span>            : </a>
<a name="1095"><span class="lineNum">    1095 </span><span class="lineNoCov">          0 :         Element::EquationIdVectorType ids(3, 0);</span></a>
<a name="1096"><span class="lineNum">    1096 </span>            : </a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineNoCov">          0 :         #pragma omp parallel firstprivate(ids)</span></a>
<a name="1098"><span class="lineNum">    1098 </span>            :         {</a>
<a name="1099"><span class="lineNum">    1099 </span>            :             // The process info</a>
<a name="1100"><span class="lineNum">    1100 </span>            :             const ProcessInfo&amp; r_current_process_info = rModelPart.GetProcessInfo();</a>
<a name="1101"><span class="lineNum">    1101 </span>            : </a>
<a name="1102"><span class="lineNum">    1102 </span>            :             // We repeat the same declaration for each thead</a>
<a name="1103"><span class="lineNum">    1103 </span>            :             std::vector&lt;std::unordered_set&lt;IndexType&gt; &gt; temp_indexes(equation_size);</a>
<a name="1104"><span class="lineNum">    1104 </span>            : </a>
<a name="1105"><span class="lineNum">    1105 </span>            :             #pragma omp for</a>
<a name="1106"><span class="lineNum">    1106 </span>            :             for (int index = 0; index &lt; static_cast&lt;int&gt;(equation_size); ++index)</a>
<a name="1107"><span class="lineNum">    1107 </span>            :                 temp_indexes[index].reserve(30);</a>
<a name="1108"><span class="lineNum">    1108 </span>            : </a>
<a name="1109"><span class="lineNum">    1109 </span>            :             // Getting the size of the array of elements from the model</a>
<a name="1110"><span class="lineNum">    1110 </span>            :             const int number_of_elements = static_cast&lt;int&gt;(rModelPart.Elements().size());</a>
<a name="1111"><span class="lineNum">    1111 </span>            : </a>
<a name="1112"><span class="lineNum">    1112 </span>            :             // Element initial iterator</a>
<a name="1113"><span class="lineNum">    1113 </span>            :             const auto it_elem_begin = rModelPart.ElementsBegin();</a>
<a name="1114"><span class="lineNum">    1114 </span>            : </a>
<a name="1115"><span class="lineNum">    1115 </span>            :             // We iterate over the elements</a>
<a name="1116"><span class="lineNum">    1116 </span>            :             #pragma omp for schedule(guided, 512) nowait</a>
<a name="1117"><span class="lineNum">    1117 </span>            :             for (int i_elem = 0; i_elem&lt;number_of_elements; ++i_elem) {</a>
<a name="1118"><span class="lineNum">    1118 </span>            :                 auto it_elem = it_elem_begin + i_elem;</a>
<a name="1119"><span class="lineNum">    1119 </span>            :                 pScheme-&gt;EquationId( *it_elem, ids, r_current_process_info);</a>
<a name="1120"><span class="lineNum">    1120 </span>            : </a>
<a name="1121"><span class="lineNum">    1121 </span>            :                 for (auto&amp; id_i : ids) {</a>
<a name="1122"><span class="lineNum">    1122 </span>            :                     if (id_i &lt; BaseType::mEquationSystemSize) {</a>
<a name="1123"><span class="lineNum">    1123 </span>            :                         auto&amp; row_indices = temp_indexes[id_i];</a>
<a name="1124"><span class="lineNum">    1124 </span>            :                         for (auto&amp; id_j : ids)</a>
<a name="1125"><span class="lineNum">    1125 </span>            :                             if (id_j &lt; BaseType::mEquationSystemSize)</a>
<a name="1126"><span class="lineNum">    1126 </span>            :                                 row_indices.insert(id_j);</a>
<a name="1127"><span class="lineNum">    1127 </span>            :                     }</a>
<a name="1128"><span class="lineNum">    1128 </span>            :                 }</a>
<a name="1129"><span class="lineNum">    1129 </span>            :             }</a>
<a name="1130"><span class="lineNum">    1130 </span>            : </a>
<a name="1131"><span class="lineNum">    1131 </span>            :             // Getting the size of the array of the conditions</a>
<a name="1132"><span class="lineNum">    1132 </span>            :             const int number_of_conditions = static_cast&lt;int&gt;(rModelPart.Conditions().size());</a>
<a name="1133"><span class="lineNum">    1133 </span>            : </a>
<a name="1134"><span class="lineNum">    1134 </span>            :             // Condition initial iterator</a>
<a name="1135"><span class="lineNum">    1135 </span>            :             const auto it_cond_begin = rModelPart.ConditionsBegin();</a>
<a name="1136"><span class="lineNum">    1136 </span>            : </a>
<a name="1137"><span class="lineNum">    1137 </span>            :             // We iterate over the conditions</a>
<a name="1138"><span class="lineNum">    1138 </span>            :             #pragma omp for schedule(guided, 512) nowait</a>
<a name="1139"><span class="lineNum">    1139 </span>            :             for (int i_cond = 0; i_cond&lt;number_of_conditions; ++i_cond) {</a>
<a name="1140"><span class="lineNum">    1140 </span>            :                 auto it_cond = it_cond_begin + i_cond;</a>
<a name="1141"><span class="lineNum">    1141 </span>            :                 pScheme-&gt;EquationId( *it_cond, ids, r_current_process_info);</a>
<a name="1142"><span class="lineNum">    1142 </span>            : </a>
<a name="1143"><span class="lineNum">    1143 </span>            :                 for (auto&amp; id_i : ids) {</a>
<a name="1144"><span class="lineNum">    1144 </span>            :                     if (id_i &lt; BaseType::mEquationSystemSize) {</a>
<a name="1145"><span class="lineNum">    1145 </span>            :                         auto&amp; row_indices = temp_indexes[id_i];</a>
<a name="1146"><span class="lineNum">    1146 </span>            :                         for (auto&amp; id_j : ids)</a>
<a name="1147"><span class="lineNum">    1147 </span>            :                             if (id_j &lt; BaseType::mEquationSystemSize)</a>
<a name="1148"><span class="lineNum">    1148 </span>            :                                 row_indices.insert(id_j);</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                     }</a>
<a name="1150"><span class="lineNum">    1150 </span>            :                 }</a>
<a name="1151"><span class="lineNum">    1151 </span>            :             }</a>
<a name="1152"><span class="lineNum">    1152 </span>            : </a>
<a name="1153"><span class="lineNum">    1153 </span>            :             // Merging all the temporal indexes</a>
<a name="1154"><span class="lineNum">    1154 </span>            :             #pragma omp critical</a>
<a name="1155"><span class="lineNum">    1155 </span>            :             {</a>
<a name="1156"><span class="lineNum">    1156 </span>            :                 for (int i = 0; i &lt; static_cast&lt;int&gt;(temp_indexes.size()); ++i) {</a>
<a name="1157"><span class="lineNum">    1157 </span>            :                     indices[i].insert(temp_indexes[i].begin(), temp_indexes[i].end());</a>
<a name="1158"><span class="lineNum">    1158 </span>            :                 }</a>
<a name="1159"><span class="lineNum">    1159 </span>            :             }</a>
<a name="1160"><span class="lineNum">    1160 </span>            :         }</a>
<a name="1161"><span class="lineNum">    1161 </span>            : </a>
<a name="1162"><span class="lineNum">    1162 </span>            :         // Count the row sizes</a>
<a name="1163"><span class="lineNum">    1163 </span>            :         SizeType nnz = 0;</a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         for (IndexType i = 0; i &lt; indices.size(); ++i)</span></a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineNoCov">          0 :             nnz += indices[i].size();</span></a>
<a name="1166"><span class="lineNum">    1166 </span>            : </a>
<a name="1167"><span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         rA = TSystemMatrixType(indices.size(), indices.size(), nnz);</span></a>
<a name="1168"><span class="lineNum">    1168 </span>            : </a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         double* Avalues = rA.value_data().begin();</span></a>
<a name="1170"><span class="lineNum">    1170 </span><span class="lineNoCov">          0 :         std::size_t* Arow_indices = rA.index1_data().begin();</span></a>
<a name="1171"><span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         std::size_t* Acol_indices = rA.index2_data().begin();</span></a>
<a name="1172"><span class="lineNum">    1172 </span>            : </a>
<a name="1173"><span class="lineNum">    1173 </span>            :         // Filling the index1 vector - DO NOT MAKE PARALLEL THE FOLLOWING LOOP!</a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         Arow_indices[0] = 0;</span></a>
<a name="1175"><span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         for (IndexType i = 0; i &lt; rA.size1(); ++i)</span></a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineNoCov">          0 :             Arow_indices[i + 1] = Arow_indices[i] + indices[i].size();</span></a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         IndexPartition&lt;std::size_t&gt;(rA.size1()).for_each([&amp;](std::size_t Index){</span></a>
<a name="1179"><span class="lineNum">    1179 </span><span class="lineNoCov">          0 :             const IndexType row_begin = Arow_indices[Index];</span></a>
<a name="1180"><span class="lineNum">    1180 </span><span class="lineNoCov">          0 :             const IndexType row_end = Arow_indices[Index + 1];</span></a>
<a name="1181"><span class="lineNum">    1181 </span>            :             IndexType k = row_begin;</a>
<a name="1182"><span class="lineNum">    1182 </span><span class="lineNoCov">          0 :             for (auto it = indices[Index].begin(); it != indices[Index].end(); ++it) {</span></a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                 Acol_indices[k] = *it;</span></a>
<a name="1184"><span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                 Avalues[k] = 0.0;</span></a>
<a name="1185"><span class="lineNum">    1185 </span><span class="lineNoCov">          0 :                 ++k;</span></a>
<a name="1186"><span class="lineNum">    1186 </span>            :             }</a>
<a name="1187"><span class="lineNum">    1187 </span>            : </a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineNoCov">          0 :             std::sort(&amp;Acol_indices[row_begin], &amp;Acol_indices[row_end]);</span></a>
<a name="1189"><span class="lineNum">    1189 </span>            :         });</a>
<a name="1190"><span class="lineNum">    1190 </span>            : </a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         rA.set_filled(indices.size() + 1, nnz);</span></a>
<a name="1192"><span class="lineNum">    1192 </span>            : </a>
<a name="1193"><span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         Timer::Stop(&quot;MatrixStructure&quot;);</span></a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            : </a>
<a name="1196"><span class="lineNum">    1196 </span>            :     /**</a>
<a name="1197"><span class="lineNum">    1197 </span>            :      * @brief This method assembles the LHS of the system</a>
<a name="1198"><span class="lineNum">    1198 </span>            :      * @param rA The LHS to assemble</a>
<a name="1199"><span class="lineNum">    1199 </span>            :      * @param rLHSContribution The local LHS contribution</a>
<a name="1200"><span class="lineNum">    1200 </span>            :      * @param rEquationId The equation id</a>
<a name="1201"><span class="lineNum">    1201 </span>            :      */</a>
<a name="1202"><span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     void AssembleLHS(</span></a>
<a name="1203"><span class="lineNum">    1203 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="1204"><span class="lineNum">    1204 </span>            :         LocalSystemMatrixType&amp; rLHSContribution,</a>
<a name="1205"><span class="lineNum">    1205 </span>            :         EquationIdVectorType&amp; rEquationId</a>
<a name="1206"><span class="lineNum">    1206 </span>            :         )</a>
<a name="1207"><span class="lineNum">    1207 </span>            :     {</a>
<a name="1208"><span class="lineNum">    1208 </span>            :         const SizeType local_size = rLHSContribution.size1();</a>
<a name="1209"><span class="lineNum">    1209 </span>            : </a>
<a name="1210"><span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         for (IndexType i_local = 0; i_local &lt; local_size; ++i_local) {</span></a>
<a name="1211"><span class="lineNum">    1211 </span><span class="lineNoCov">          0 :             const IndexType i_global = rEquationId[i_local];</span></a>
<a name="1212"><span class="lineNum">    1212 </span><span class="lineNoCov">          0 :             if (i_global &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1213"><span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 for (IndexType j_local = 0; j_local &lt; local_size; ++j_local) {</span></a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                     const IndexType j_global = rEquationId[j_local];</span></a>
<a name="1215"><span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                     if (j_global &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                         rA(i_global, j_global) += rLHSContribution(i_local, j_local);</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            :                     }</a>
<a name="1218"><span class="lineNum">    1218 </span>            :                 }</a>
<a name="1219"><span class="lineNum">    1219 </span>            :             }</a>
<a name="1220"><span class="lineNum">    1220 </span>            :         }</a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span>            :     /**</a>
<a name="1224"><span class="lineNum">    1224 </span>            :      * @brief This function is equivalent to the AssembleRowContribution of the block builder and solver</a>
<a name="1225"><span class="lineNum">    1225 </span>            :      * @note The main difference respect the block builder and solver is the fact that the fixed DoFs are skipped</a>
<a name="1226"><span class="lineNum">    1226 </span>            :      */</a>
<a name="1227"><span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     inline void AssembleRowContributionFreeDofs(</span></a>
<a name="1228"><span class="lineNum">    1228 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="1229"><span class="lineNum">    1229 </span>            :         const Matrix&amp; rALocal,</a>
<a name="1230"><span class="lineNum">    1230 </span>            :         const IndexType i,</a>
<a name="1231"><span class="lineNum">    1231 </span>            :         const IndexType i_local,</a>
<a name="1232"><span class="lineNum">    1232 </span>            :         const Element::EquationIdVectorType&amp; EquationId</a>
<a name="1233"><span class="lineNum">    1233 </span>            :         )</a>
<a name="1234"><span class="lineNum">    1234 </span>            :     {</a>
<a name="1235"><span class="lineNum">    1235 </span>            :         double* values_vector = rA.value_data().begin();</a>
<a name="1236"><span class="lineNum">    1236 </span>            :         IndexType* index1_vector = rA.index1_data().begin();</a>
<a name="1237"><span class="lineNum">    1237 </span>            :         IndexType* index2_vector = rA.index2_data().begin();</a>
<a name="1238"><span class="lineNum">    1238 </span>            : </a>
<a name="1239"><span class="lineNum">    1239 </span><span class="lineNoCov">          0 :         const IndexType left_limit = index1_vector[i];</span></a>
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<a name="1241"><span class="lineNum">    1241 </span>            :         // Find the first entry</a>
<a name="1242"><span class="lineNum">    1242 </span>            :         // We iterate over the equation ids until we find the first equation id to be considered</a>
<a name="1243"><span class="lineNum">    1243 </span>            :         // We count in which component we find an ID</a>
<a name="1244"><span class="lineNum">    1244 </span>            :         IndexType last_pos = 0;</a>
<a name="1245"><span class="lineNum">    1245 </span>            :         IndexType last_found = 0;</a>
<a name="1246"><span class="lineNum">    1246 </span>            :         IndexType counter = 0;</a>
<a name="1247"><span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         for(IndexType j=0; j &lt; EquationId.size(); ++j) {</span></a>
<a name="1248"><span class="lineNum">    1248 </span><span class="lineNoCov">          0 :             ++counter;</span></a>
<a name="1249"><span class="lineNum">    1249 </span><span class="lineNoCov">          0 :             const IndexType j_global = EquationId[j];</span></a>
<a name="1250"><span class="lineNum">    1250 </span><span class="lineNoCov">          0 :             if (j_global &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1251"><span class="lineNum">    1251 </span>            :                 last_pos = ForwardFind(j_global,left_limit,index2_vector);</a>
<a name="1252"><span class="lineNum">    1252 </span>            :                 last_found = j_global;</a>
<a name="1253"><span class="lineNum">    1253 </span>            :                 break;</a>
<a name="1254"><span class="lineNum">    1254 </span>            :             }</a>
<a name="1255"><span class="lineNum">    1255 </span>            :         }</a>
<a name="1256"><span class="lineNum">    1256 </span>            : </a>
<a name="1257"><span class="lineNum">    1257 </span>            :         // If the counter is equal to the size of the EquationID vector that means that only one dof will be considered, if the number is greater means that all the dofs are fixed. If the number is below means that at we have several dofs free to be considered</a>
<a name="1258"><span class="lineNum">    1258 </span><span class="lineNoCov">          0 :         if (counter &lt;= EquationId.size()) {</span></a>
<a name="1259"><span class="lineNum">    1259 </span>            : #ifndef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineNoCov">          0 :             double&amp; r_a = values_vector[last_pos];</span></a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             const double&amp; v_a = rALocal(i_local,counter - 1);</span></a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineNoCov">          0 :             AtomicAdd(r_a,  v_a);</span></a>
<a name="1263"><span class="lineNum">    1263 </span>            : #else</a>
<a name="1264"><span class="lineNum">    1264 </span>            :             values_vector[last_pos] += rALocal(i_local,counter - 1);</a>
<a name="1265"><span class="lineNum">    1265 </span>            : #endif</a>
<a name="1266"><span class="lineNum">    1266 </span>            :             // Now find all of the other entries</a>
<a name="1267"><span class="lineNum">    1267 </span>            :             IndexType pos = 0;</a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineNoCov">          0 :             for(IndexType j = counter; j &lt; EquationId.size(); ++j) {</span></a>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                 IndexType id_to_find = EquationId[j];</span></a>
<a name="1270"><span class="lineNum">    1270 </span><span class="lineNoCov">          0 :                 if (id_to_find &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                     if(id_to_find &gt; last_found)</span></a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineNoCov">          0 :                         pos = ForwardFind(id_to_find,last_pos+1,index2_vector);</span></a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineNoCov">          0 :                     else if(id_to_find &lt; last_found)</span></a>
<a name="1274"><span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                         pos = BackwardFind(id_to_find,last_pos-1,index2_vector);</span></a>
<a name="1275"><span class="lineNum">    1275 </span>            :                     else</a>
<a name="1276"><span class="lineNum">    1276 </span>            :                         pos = last_pos;</a>
<a name="1277"><span class="lineNum">    1277 </span>            : </a>
<a name="1278"><span class="lineNum">    1278 </span>            : #ifndef USE_LOCKS_IN_ASSEMBLY</a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineNoCov">          0 :                     double&amp; r = values_vector[pos];</span></a>
<a name="1280"><span class="lineNum">    1280 </span>            :                     const double&amp; v = rALocal(i_local,j);</a>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                     AtomicAdd(r,  v);</span></a>
<a name="1282"><span class="lineNum">    1282 </span>            : #else</a>
<a name="1283"><span class="lineNum">    1283 </span>            :                     values_vector[pos] += rALocal(i_local,j);</a>
<a name="1284"><span class="lineNum">    1284 </span>            : #endif</a>
<a name="1285"><span class="lineNum">    1285 </span>            :                     last_found = id_to_find;</a>
<a name="1286"><span class="lineNum">    1286 </span>            :                     last_pos = pos;</a>
<a name="1287"><span class="lineNum">    1287 </span>            :                 }</a>
<a name="1288"><span class="lineNum">    1288 </span>            :             }</a>
<a name="1289"><span class="lineNum">    1289 </span>            :         }</a>
<a name="1290"><span class="lineNum">    1290 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1291"><span class="lineNum">    1291 </span>            : </a>
<a name="1292"><span class="lineNum">    1292 </span>            :     inline IndexType ForwardFind(const IndexType id_to_find,</a>
<a name="1293"><span class="lineNum">    1293 </span>            :                                    const IndexType start,</a>
<a name="1294"><span class="lineNum">    1294 </span>            :                                    const IndexType* index_vector)</a>
<a name="1295"><span class="lineNum">    1295 </span>            :     {</a>
<a name="1296"><span class="lineNum">    1296 </span>            :         IndexType pos = start;</a>
<a name="1297"><span class="lineNum">    1297 </span><span class="lineNoCov">          0 :         while(id_to_find != index_vector[pos]) pos++;</span></a>
<a name="1298"><span class="lineNum">    1298 </span>            :         return pos;</a>
<a name="1299"><span class="lineNum">    1299 </span>            :     }</a>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<a name="1301"><span class="lineNum">    1301 </span>            :     inline IndexType BackwardFind(const IndexType id_to_find,</a>
<a name="1302"><span class="lineNum">    1302 </span>            :                                     const IndexType start,</a>
<a name="1303"><span class="lineNum">    1303 </span>            :                                     const IndexType* index_vector)</a>
<a name="1304"><span class="lineNum">    1304 </span>            :     {</a>
<a name="1305"><span class="lineNum">    1305 </span>            :         IndexType pos = start;</a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineNoCov">          0 :         while(id_to_find != index_vector[pos]) pos--;</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            :         return pos;</a>
<a name="1308"><span class="lineNum">    1308 </span>            :     }</a>
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<a name="1310"><span class="lineNum">    1310 </span>            :     /**</a>
<a name="1311"><span class="lineNum">    1311 </span>            :      * @brief This method assigns settings to member variables</a>
<a name="1312"><span class="lineNum">    1312 </span>            :      * @param ThisParameters Parameters that are assigned to the member variables</a>
<a name="1313"><span class="lineNum">    1313 </span>            :      */</a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     void AssignSettings(const Parameters ThisParameters) override</span></a>
<a name="1315"><span class="lineNum">    1315 </span>            :     {</a>
<a name="1316"><span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         BaseType::AssignSettings(ThisParameters);</span></a>
<a name="1317"><span class="lineNum">    1317 </span>            : </a>
<a name="1318"><span class="lineNum">    1318 </span>            :         // Setting flags&lt;</a>
<a name="1319"><span class="lineNum">    1319 </span><span class="lineNoCov">          0 :         const std::string&amp; r_diagonal_values_for_dirichlet_dofs = ThisParameters[&quot;diagonal_values_for_dirichlet_dofs&quot;].GetString();</span></a>
<a name="1320"><span class="lineNum">    1320 </span>            : </a>
<a name="1321"><span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         std::set&lt;std::string&gt; available_options_for_diagonal = {&quot;no_scaling&quot;,&quot;use_max_diagonal&quot;,&quot;use_diagonal_norm&quot;,&quot;defined_in_process_info&quot;};</span></a>
<a name="1322"><span class="lineNum">    1322 </span>            : </a>
<a name="1323"><span class="lineNum">    1323 </span><span class="lineNoCov">          0 :         if (available_options_for_diagonal.find(r_diagonal_values_for_dirichlet_dofs) == available_options_for_diagonal.end()) {</span></a>
<a name="1324"><span class="lineNum">    1324 </span><span class="lineNoCov">          0 :             std::stringstream msg;</span></a>
<a name="1325"><span class="lineNum">    1325 </span><span class="lineNoCov">          0 :             msg &lt;&lt; &quot;Currently prescribed diagonal values for dirichlet dofs : &quot; &lt;&lt; r_diagonal_values_for_dirichlet_dofs &lt;&lt; &quot;\n&quot;;</span></a>
<a name="1326"><span class="lineNum">    1326 </span><span class="lineNoCov">          0 :             msg &lt;&lt; &quot;Admissible values for the diagonal scaling are : no_scaling, use_max_diagonal, use_diagonal_norm, or defined_in_process_info&quot; &lt;&lt; &quot;\n&quot;;</span></a>
<a name="1327"><span class="lineNum">    1327 </span><span class="lineNoCov">          0 :             KRATOS_ERROR &lt;&lt; msg.str() &lt;&lt; std::endl;</span></a>
<a name="1328"><span class="lineNum">    1328 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1329"><span class="lineNum">    1329 </span>            : </a>
<a name="1330"><span class="lineNum">    1330 </span>            :         // The first option will not consider any scaling (the diagonal values will be replaced with 1)</a>
<a name="1331"><span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         if (r_diagonal_values_for_dirichlet_dofs == &quot;no_scaling&quot;) {</span></a>
<a name="1332"><span class="lineNum">    1332 </span><span class="lineNoCov">          0 :             mScalingDiagonal = SCALING_DIAGONAL::NO_SCALING;</span></a>
<a name="1333"><span class="lineNum">    1333 </span><span class="lineNoCov">          0 :         } else if (r_diagonal_values_for_dirichlet_dofs == &quot;use_max_diagonal&quot;) {</span></a>
<a name="1334"><span class="lineNum">    1334 </span><span class="lineNoCov">          0 :             mScalingDiagonal = SCALING_DIAGONAL::CONSIDER_MAX_DIAGONAL;</span></a>
<a name="1335"><span class="lineNum">    1335 </span><span class="lineNoCov">          0 :         } else if (r_diagonal_values_for_dirichlet_dofs == &quot;use_diagonal_norm&quot;) { // On this case the norm of the diagonal will be considered</span></a>
<a name="1336"><span class="lineNum">    1336 </span><span class="lineNoCov">          0 :             mScalingDiagonal = SCALING_DIAGONAL::CONSIDER_NORM_DIAGONAL;</span></a>
<a name="1337"><span class="lineNum">    1337 </span>            :         } else { // Otherwise we will assume we impose a numerical value</a>
<a name="1338"><span class="lineNum">    1338 </span><span class="lineNoCov">          0 :             mScalingDiagonal = SCALING_DIAGONAL::CONSIDER_PRESCRIBED_DIAGONAL;</span></a>
<a name="1339"><span class="lineNum">    1339 </span>            :         }</a>
<a name="1340"><span class="lineNum">    1340 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1341"><span class="lineNum">    1341 </span>            : </a>
<a name="1342"><span class="lineNum">    1342 </span>            :     ///@}</a>
<a name="1343"><span class="lineNum">    1343 </span>            :     ///@name Protected  Access</a>
<a name="1344"><span class="lineNum">    1344 </span>            :     ///@{</a>
<a name="1345"><span class="lineNum">    1345 </span>            : </a>
<a name="1346"><span class="lineNum">    1346 </span>            :     ///@}</a>
<a name="1347"><span class="lineNum">    1347 </span>            :     ///@name Protected Inquiry</a>
<a name="1348"><span class="lineNum">    1348 </span>            :     ///@{</a>
<a name="1349"><span class="lineNum">    1349 </span>            : </a>
<a name="1350"><span class="lineNum">    1350 </span>            :     ///@}</a>
<a name="1351"><span class="lineNum">    1351 </span>            :     ///@name Protected LifeCycle</a>
<a name="1352"><span class="lineNum">    1352 </span>            :     ///@{</a>
<a name="1353"><span class="lineNum">    1353 </span>            : </a>
<a name="1354"><span class="lineNum">    1354 </span>            :     ///@}</a>
<a name="1355"><span class="lineNum">    1355 </span>            : </a>
<a name="1356"><span class="lineNum">    1356 </span>            : private:</a>
<a name="1357"><span class="lineNum">    1357 </span>            :     ///@name Static Member Variables</a>
<a name="1358"><span class="lineNum">    1358 </span>            :     ///@{</a>
<a name="1359"><span class="lineNum">    1359 </span>            : </a>
<a name="1360"><span class="lineNum">    1360 </span>            :     ///@}</a>
<a name="1361"><span class="lineNum">    1361 </span>            :     ///@name Member Variables</a>
<a name="1362"><span class="lineNum">    1362 </span>            :     ///@{</a>
<a name="1363"><span class="lineNum">    1363 </span>            : </a>
<a name="1364"><span class="lineNum">    1364 </span>            :     ///@}</a>
<a name="1365"><span class="lineNum">    1365 </span>            :     ///@name Private Operators</a>
<a name="1366"><span class="lineNum">    1366 </span>            :     ///@{</a>
<a name="1367"><span class="lineNum">    1367 </span>            : </a>
<a name="1368"><span class="lineNum">    1368 </span>            :     ///@}</a>
<a name="1369"><span class="lineNum">    1369 </span>            :     ///@name Private Operations</a>
<a name="1370"><span class="lineNum">    1370 </span>            :     ///@{</a>
<a name="1371"><span class="lineNum">    1371 </span>            : </a>
<a name="1372"><span class="lineNum">    1372 </span>            :     /**</a>
<a name="1373"><span class="lineNum">    1373 </span>            :      * @brief This method ensures that the contribution is unique</a>
<a name="1374"><span class="lineNum">    1374 </span>            :      */</a>
<a name="1375"><span class="lineNum">    1375 </span>            :     inline void AddUnique(std::vector&lt;std::size_t&gt;&amp; v, const std::size_t&amp; candidate)</a>
<a name="1376"><span class="lineNum">    1376 </span>            :     {</a>
<a name="1377"><span class="lineNum">    1377 </span>            :         std::vector&lt;std::size_t&gt;::iterator i = v.begin();</a>
<a name="1378"><span class="lineNum">    1378 </span>            :         std::vector&lt;std::size_t&gt;::iterator endit = v.end();</a>
<a name="1379"><span class="lineNum">    1379 </span>            :         while (i != endit &amp;&amp; (*i) != candidate) {</a>
<a name="1380"><span class="lineNum">    1380 </span>            :             i++;</a>
<a name="1381"><span class="lineNum">    1381 </span>            :         }</a>
<a name="1382"><span class="lineNum">    1382 </span>            :         if (i == endit) {</a>
<a name="1383"><span class="lineNum">    1383 </span>            :             v.push_back(candidate);</a>
<a name="1384"><span class="lineNum">    1384 </span>            :         }</a>
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<a name="1386"><span class="lineNum">    1386 </span>            :     }</a>
<a name="1387"><span class="lineNum">    1387 </span>            : </a>
<a name="1388"><span class="lineNum">    1388 </span>            :     /**</a>
<a name="1389"><span class="lineNum">    1389 </span>            :      * @brief This method assembles the RHS of the system</a>
<a name="1390"><span class="lineNum">    1390 </span>            :      * @param rb The RHS to assemble</a>
<a name="1391"><span class="lineNum">    1391 </span>            :      * @param rRHSContribution The local RHS contribution</a>
<a name="1392"><span class="lineNum">    1392 </span>            :      * @param rEquationId The equation id</a>
<a name="1393"><span class="lineNum">    1393 </span>            :      */</a>
<a name="1394"><span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     void AssembleRHS(</span></a>
<a name="1395"><span class="lineNum">    1395 </span>            :         TSystemVectorType&amp; rb,</a>
<a name="1396"><span class="lineNum">    1396 </span>            :         const LocalSystemVectorType&amp; rRHSContribution,</a>
<a name="1397"><span class="lineNum">    1397 </span>            :         const EquationIdVectorType&amp; rEquationId</a>
<a name="1398"><span class="lineNum">    1398 </span>            :         )</a>
<a name="1399"><span class="lineNum">    1399 </span>            :     {</a>
<a name="1400"><span class="lineNum">    1400 </span>            :         SizeType local_size = rRHSContribution.size();</a>
<a name="1401"><span class="lineNum">    1401 </span>            : </a>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineNoCov">          0 :         if (BaseType::mCalculateReactionsFlag == false) {</span></a>
<a name="1403"><span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             for (IndexType i_local = 0; i_local &lt; local_size; ++i_local) {</span></a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineNoCov">          0 :                 const IndexType i_global = rEquationId[i_local];</span></a>
<a name="1405"><span class="lineNum">    1405 </span>            : </a>
<a name="1406"><span class="lineNum">    1406 </span><span class="lineNoCov">          0 :                 if (i_global &lt; BaseType::mEquationSystemSize) { // Free dof</span></a>
<a name="1407"><span class="lineNum">    1407 </span>            :                     // ASSEMBLING THE SYSTEM VECTOR</a>
<a name="1408"><span class="lineNum">    1408 </span>            :                     double&amp; b_value = rb[i_global];</a>
<a name="1409"><span class="lineNum">    1409 </span>            :                     const double&amp; rhs_value = rRHSContribution[i_local];</a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                     AtomicAdd(b_value, rhs_value);</span></a>
<a name="1412"><span class="lineNum">    1412 </span>            :                 }</a>
<a name="1413"><span class="lineNum">    1413 </span>            :             }</a>
<a name="1414"><span class="lineNum">    1414 </span>            :         } else {</a>
<a name="1415"><span class="lineNum">    1415 </span>            :             TSystemVectorType&amp; r_reactions_vector = *BaseType::mpReactionsVector;</a>
<a name="1416"><span class="lineNum">    1416 </span><span class="lineNoCov">          0 :             for (IndexType i_local = 0; i_local &lt; local_size; ++i_local) {</span></a>
<a name="1417"><span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                 const IndexType i_global = rEquationId[i_local];</span></a>
<a name="1418"><span class="lineNum">    1418 </span>            : </a>
<a name="1419"><span class="lineNum">    1419 </span><span class="lineNoCov">          0 :                 if (i_global &lt; BaseType::mEquationSystemSize) { //free dof</span></a>
<a name="1420"><span class="lineNum">    1420 </span>            :                     // ASSEMBLING THE SYSTEM VECTOR</a>
<a name="1421"><span class="lineNum">    1421 </span>            :                     double&amp; b_value = rb[i_global];</a>
<a name="1422"><span class="lineNum">    1422 </span>            :                     const double&amp; rhs_value = rRHSContribution[i_local];</a>
<a name="1423"><span class="lineNum">    1423 </span>            : </a>
<a name="1424"><span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                     AtomicAdd(b_value, rhs_value);</span></a>
<a name="1425"><span class="lineNum">    1425 </span>            :                 } else { // Fixed dof</a>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineNoCov">          0 :                     double&amp; b_value = r_reactions_vector[i_global - BaseType::mEquationSystemSize];</span></a>
<a name="1427"><span class="lineNum">    1427 </span>            :                     const double&amp; rhs_value = rRHSContribution[i_local];</a>
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineNoCov">          0 :                     AtomicAdd(b_value, rhs_value);</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            :                 }</a>
<a name="1431"><span class="lineNum">    1431 </span>            :             }</a>
<a name="1432"><span class="lineNum">    1432 </span>            :         }</a>
<a name="1433"><span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1434"><span class="lineNum">    1434 </span>            : </a>
<a name="1435"><span class="lineNum">    1435 </span>            :     /**</a>
<a name="1436"><span class="lineNum">    1436 </span>            :      * @brief This method assembles the LHS of the system (on free rows)</a>
<a name="1437"><span class="lineNum">    1437 </span>            :      * @param rA The LHS to assemble</a>
<a name="1438"><span class="lineNum">    1438 </span>            :      * @param rLHSContribution The local LHS contribution</a>
<a name="1439"><span class="lineNum">    1439 </span>            :      * @param rEquationId The equation id</a>
<a name="1440"><span class="lineNum">    1440 </span>            :      */</a>
<a name="1441"><span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     void AssembleLHSCompleteOnFreeRows(</span></a>
<a name="1442"><span class="lineNum">    1442 </span>            :         TSystemMatrixType&amp; rA,</a>
<a name="1443"><span class="lineNum">    1443 </span>            :         LocalSystemMatrixType&amp; rLHSContribution,</a>
<a name="1444"><span class="lineNum">    1444 </span>            :         EquationIdVectorType&amp; rEquationId</a>
<a name="1445"><span class="lineNum">    1445 </span>            :         )</a>
<a name="1446"><span class="lineNum">    1446 </span>            :     {</a>
<a name="1447"><span class="lineNum">    1447 </span>            :         const SizeType local_size = rLHSContribution.size1();</a>
<a name="1448"><span class="lineNum">    1448 </span><span class="lineNoCov">          0 :         for (IndexType i_local = 0; i_local &lt; local_size; ++i_local) {</span></a>
<a name="1449"><span class="lineNum">    1449 </span><span class="lineNoCov">          0 :             const IndexType i_global = rEquationId[i_local];</span></a>
<a name="1450"><span class="lineNum">    1450 </span><span class="lineNoCov">          0 :             if (i_global &lt; BaseType::mEquationSystemSize) {</span></a>
<a name="1451"><span class="lineNum">    1451 </span><span class="lineNoCov">          0 :                 for (IndexType j_local = 0; j_local &lt; local_size; ++j_local) {</span></a>
<a name="1452"><span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                     const IndexType j_global = rEquationId[j_local];</span></a>
<a name="1453"><span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                     rA(i_global, j_global) += rLHSContribution(i_local, j_local);</span></a>
<a name="1454"><span class="lineNum">    1454 </span>            :                 }</a>
<a name="1455"><span class="lineNum">    1455 </span>            :             }</a>
<a name="1456"><span class="lineNum">    1456 </span>            :         }</a>
<a name="1457"><span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<a name="1459"><span class="lineNum">    1459 </span>            :     ///@}</a>
<a name="1460"><span class="lineNum">    1460 </span>            :     ///@name Private Operations</a>
<a name="1461"><span class="lineNum">    1461 </span>            :     ///@{</a>
<a name="1462"><span class="lineNum">    1462 </span>            : </a>
<a name="1463"><span class="lineNum">    1463 </span>            :     ///@}</a>
<a name="1464"><span class="lineNum">    1464 </span>            :     ///@name Private  Access</a>
<a name="1465"><span class="lineNum">    1465 </span>            :     ///@{</a>
<a name="1466"><span class="lineNum">    1466 </span>            : </a>
<a name="1467"><span class="lineNum">    1467 </span>            :     ///@}</a>
<a name="1468"><span class="lineNum">    1468 </span>            :     ///@name Private Inquiry</a>
<a name="1469"><span class="lineNum">    1469 </span>            :     ///@{</a>
<a name="1470"><span class="lineNum">    1470 </span>            : </a>
<a name="1471"><span class="lineNum">    1471 </span>            :     ///@}</a>
<a name="1472"><span class="lineNum">    1472 </span>            :     ///@name Un accessible methods</a>
<a name="1473"><span class="lineNum">    1473 </span>            :     ///@{</a>
<a name="1474"><span class="lineNum">    1474 </span>            : </a>
<a name="1475"><span class="lineNum">    1475 </span>            :     ///@}</a>
<a name="1476"><span class="lineNum">    1476 </span>            : </a>
<a name="1477"><span class="lineNum">    1477 </span>            : }; /* Class ResidualBasedEliminationBuilderAndSolver */</a>
<a name="1478"><span class="lineNum">    1478 </span>            : </a>
<a name="1479"><span class="lineNum">    1479 </span>            : ///@}</a>
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<a name="1481"><span class="lineNum">    1481 </span>            : ///@name Type Definitions</a>
<a name="1482"><span class="lineNum">    1482 </span>            : ///@{</a>
<a name="1483"><span class="lineNum">    1483 </span>            : </a>
<a name="1484"><span class="lineNum">    1484 </span>            : ///@}</a>
<a name="1485"><span class="lineNum">    1485 </span>            : </a>
<a name="1486"><span class="lineNum">    1486 </span>            : } /* namespace Kratos.*/</a>
<a name="1487"><span class="lineNum">    1487 </span>            : </a>
<a name="1488"><span class="lineNum">    1488 </span>            : #endif /* KRATOS_RESIDUAL_BASED_ELIMINATION_BUILDER_AND_SOLVER  defined */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
