<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - kratos/processes/simple_mortar_mapper_process.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">kratos/processes</a> - simple_mortar_mapper_process.h<span style="font-size: 80%;"> (source / <a href="simple_mortar_mapper_process.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">130</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-10 04:44:37</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">154</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //    |  /           |</a>
<a name="2"><span class="lineNum">       2 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="3"><span class="lineNum">       3 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="4"><span class="lineNum">       4 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="5"><span class="lineNum">       5 </span>            : //                   Multi-Physics</a>
<a name="6"><span class="lineNum">       6 </span>            : //</a>
<a name="7"><span class="lineNum">       7 </span>            : //  License:             BSD License</a>
<a name="8"><span class="lineNum">       8 </span>            : //                                       Kratos default license: kratos/license.txt</a>
<a name="9"><span class="lineNum">       9 </span>            : //</a>
<a name="10"><span class="lineNum">      10 </span>            : //  Main authors:    Vicente Mataix Ferrandiz</a>
<a name="11"><span class="lineNum">      11 </span>            : //</a>
<a name="12"><span class="lineNum">      12 </span>            : </a>
<a name="13"><span class="lineNum">      13 </span>            : #if !defined(KRATOS_SIMPLE_MORTAR_MAPPER_PROCESS)</a>
<a name="14"><span class="lineNum">      14 </span>            : #define KRATOS_SIMPLE_MORTAR_MAPPER_PROCESS</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            : // System includes</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &lt;unordered_map&gt;</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            : // External includes</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : // Project includes</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &quot;processes/process.h&quot;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &quot;includes/kratos_parameters.h&quot;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;spaces/ublas_space.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &quot;linear_solvers/linear_solver.h&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &quot;utilities/atomic_utilities.h&quot;</a>
<a name="28"><span class="lineNum">      28 </span>            : </a>
<a name="29"><span class="lineNum">      29 </span>            : /* Custom includes */</a>
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;includes/mortar_classes.h&quot;</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : /* Custom utilities */</a>
<a name="33"><span class="lineNum">      33 </span>            : #include &quot;utilities/exact_mortar_segmentation_utility.h&quot;</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : /* Tree structures */</a>
<a name="36"><span class="lineNum">      36 </span>            : // #include &quot;spatial_containers/bounding_volume_tree.h&quot; // k-DOP</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &quot;spatial_containers/spatial_containers.h&quot; // kd-tree</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : namespace Kratos</a>
<a name="40"><span class="lineNum">      40 </span>            : {</a>
<a name="41"><span class="lineNum">      41 </span>            : ///@name Kratos Globals</a>
<a name="42"><span class="lineNum">      42 </span>            : ///@{</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            : ///@}</a>
<a name="45"><span class="lineNum">      45 </span>            : ///@name Type Definitions</a>
<a name="46"><span class="lineNum">      46 </span>            : ///@{</a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span>            :     /// The definition of the size type</a>
<a name="49"><span class="lineNum">      49 </span>            :     typedef std::size_t SizeType;</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : ///@}</a>
<a name="52"><span class="lineNum">      52 </span>            : ///@name  Enum's</a>
<a name="53"><span class="lineNum">      53 </span>            : ///@{</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            : ///@}</a>
<a name="56"><span class="lineNum">      56 </span>            : ///@name  Functions</a>
<a name="57"><span class="lineNum">      57 </span>            : ///@{</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span>            : ///@}</a>
<a name="60"><span class="lineNum">      60 </span>            : ///@name Kratos Classes</a>
<a name="61"><span class="lineNum">      61 </span>            : ///@{</a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span>            : /**</a>
<a name="64"><span class="lineNum">      64 </span>            :  * @ingroup KratosCore</a>
<a name="65"><span class="lineNum">      65 </span>            :  * @class PointMapper</a>
<a name="66"><span class="lineNum">      66 </span>            :  * @brief Custom Point container to be used by the mapper</a>
<a name="67"><span class="lineNum">      67 </span>            :  * @details The main difference with this point and the base one is that it contains the pointer to geometrical object where the center of the points belongs</a>
<a name="68"><span class="lineNum">      68 </span>            :  * @author Vicente Mataix Ferrandiz</a>
<a name="69"><span class="lineNum">      69 </span>            :  */</a>
<a name="70"><span class="lineNum">      70 </span>            : class PointMapper</a>
<a name="71"><span class="lineNum">      71 </span>            :     : public Point</a>
<a name="72"><span class="lineNum">      72 </span>            : {</a>
<a name="73"><span class="lineNum">      73 </span>            : public:</a>
<a name="74"><span class="lineNum">      74 </span>            :     ///@name Type Definitions</a>
<a name="75"><span class="lineNum">      75 </span>            :     ///@{</a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            :     typedef Point BaseType;</a>
<a name="78"><span class="lineNum">      78 </span>            : </a>
<a name="79"><span class="lineNum">      79 </span>            :     /// Counted pointer of PointMapper</a>
<a name="80"><span class="lineNum">      80 </span>            :     KRATOS_CLASS_POINTER_DEFINITION( PointMapper );</a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            :     ///@}</a>
<a name="83"><span class="lineNum">      83 </span>            :     ///@name Life Cycle</a>
<a name="84"><span class="lineNum">      84 </span>            :     ///@{</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :     /// Default constructors</a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :     PointMapper():</span></a>
<a name="88"><span class="lineNum">      88 </span>            :         BaseType(),</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineNoCov">          0 :         mpOriginGeometricalObject(nullptr)</span></a>
<a name="90"><span class="lineNum">      90 </span>            :     {}</a>
<a name="91"><span class="lineNum">      91 </span>            : </a>
<a name="92"><span class="lineNum">      92 </span>            :     PointMapper(const array_1d&lt;double, 3&gt;&amp; Coords)</a>
<a name="93"><span class="lineNum">      93 </span>            :         :BaseType(Coords),</a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :          mpOriginGeometricalObject(nullptr)</span></a>
<a name="95"><span class="lineNum">      95 </span>            :     {}</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :     PointMapper(GeometricalObject::Pointer pGeometricalObject):</span></a>
<a name="98"><span class="lineNum">      98 </span><span class="lineNoCov">          0 :         mpOriginGeometricalObject(pGeometricalObject)</span></a>
<a name="99"><span class="lineNum">      99 </span>            :     {</a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :         UpdatePoint();</span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            :     PointMapper(</a>
<a name="104"><span class="lineNum">     104 </span>            :         const array_1d&lt;double, 3&gt;&amp; Coords,</a>
<a name="105"><span class="lineNum">     105 </span>            :         GeometricalObject::Pointer pGeometricalObject</a>
<a name="106"><span class="lineNum">     106 </span>            :     ):</a>
<a name="107"><span class="lineNum">     107 </span>            :         BaseType(Coords),</a>
<a name="108"><span class="lineNum">     108 </span>            :         mpOriginGeometricalObject(pGeometricalObject)</a>
<a name="109"><span class="lineNum">     109 </span>            :     {}</a>
<a name="110"><span class="lineNum">     110 </span>            : </a>
<a name="111"><span class="lineNum">     111 </span>            :     ///Copy constructor  (not really required)</a>
<a name="112"><span class="lineNum">     112 </span>            :     PointMapper(const PointMapper&amp; rhs):</a>
<a name="113"><span class="lineNum">     113 </span>            :         BaseType(rhs),</a>
<a name="114"><span class="lineNum">     114 </span>            :         mpOriginGeometricalObject(rhs.mpOriginGeometricalObject)</a>
<a name="115"><span class="lineNum">     115 </span>            :     {</a>
<a name="116"><span class="lineNum">     116 </span>            :     }</a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span>            :     /// Destructor.</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineNoCov">          0 :     ~PointMapper() override= default;</span></a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            :     ///@}</a>
<a name="122"><span class="lineNum">     122 </span>            :     ///@name Operations</a>
<a name="123"><span class="lineNum">     123 </span>            :     ///@{</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span>            :     /**</a>
<a name="126"><span class="lineNum">     126 </span>            :      * @brief Returns the point</a>
<a name="127"><span class="lineNum">     127 </span>            :      * @return The point</a>
<a name="128"><span class="lineNum">     128 </span>            :      */</a>
<a name="129"><span class="lineNum">     129 </span>            :     BaseType GetPoint()</a>
<a name="130"><span class="lineNum">     130 </span>            :     {</a>
<a name="131"><span class="lineNum">     131 </span>            :         BaseType Point(this-&gt;Coordinates());</a>
<a name="132"><span class="lineNum">     132 </span>            :         return Point;</a>
<a name="133"><span class="lineNum">     133 </span>            :     }</a>
<a name="134"><span class="lineNum">     134 </span>            : </a>
<a name="135"><span class="lineNum">     135 </span>            :     /**</a>
<a name="136"><span class="lineNum">     136 </span>            :      * @brief Set the point</a>
<a name="137"><span class="lineNum">     137 </span>            :      * @param Point The point</a>
<a name="138"><span class="lineNum">     138 </span>            :      */</a>
<a name="139"><span class="lineNum">     139 </span>            :     void SetPoint(const BaseType Point)</a>
<a name="140"><span class="lineNum">     140 </span>            :     {</a>
<a name="141"><span class="lineNum">     141 </span>            :         this-&gt;Coordinates() = Point.Coordinates();</a>
<a name="142"><span class="lineNum">     142 </span>            :     }</a>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<a name="144"><span class="lineNum">     144 </span>            :     /**</a>
<a name="145"><span class="lineNum">     145 </span>            :      * @brief Sets the geometrical object associated to the point</a>
<a name="146"><span class="lineNum">     146 </span>            :      * @param pGeometricalObject The pointer to the geometrical object</a>
<a name="147"><span class="lineNum">     147 </span>            :      */</a>
<a name="148"><span class="lineNum">     148 </span>            :     void SetCondition(GeometricalObject::Pointer pGeometricalObject)</a>
<a name="149"><span class="lineNum">     149 </span>            :     {</a>
<a name="150"><span class="lineNum">     150 </span>            :         mpOriginGeometricalObject = pGeometricalObject;</a>
<a name="151"><span class="lineNum">     151 </span>            :     }</a>
<a name="152"><span class="lineNum">     152 </span>            : </a>
<a name="153"><span class="lineNum">     153 </span>            :     /**</a>
<a name="154"><span class="lineNum">     154 </span>            :      * @brief Returns the geometrical object associated to the point</a>
<a name="155"><span class="lineNum">     155 </span>            :      * @return mpOriginGeometricalObject The pointer to the geometrical object associated to the point</a>
<a name="156"><span class="lineNum">     156 </span>            :      */</a>
<a name="157"><span class="lineNum">     157 </span>            :     GeometricalObject::Pointer GetGeometricalObject()</a>
<a name="158"><span class="lineNum">     158 </span>            :     {</a>
<a name="159"><span class="lineNum">     159 </span>            :         KRATOS_DEBUG_ERROR_IF(mpOriginGeometricalObject.get() == nullptr) &lt;&lt; &quot;GeometricalObject no initialized in the PointMapper class&quot; &lt;&lt; std::endl;</a>
<a name="160"><span class="lineNum">     160 </span>            :         return mpOriginGeometricalObject;</a>
<a name="161"><span class="lineNum">     161 </span>            :     }</a>
<a name="162"><span class="lineNum">     162 </span>            : </a>
<a name="163"><span class="lineNum">     163 </span>            :     /**</a>
<a name="164"><span class="lineNum">     164 </span>            :      * @brief This method checks everything is right</a>
<a name="165"><span class="lineNum">     165 </span>            :      */</a>
<a name="166"><span class="lineNum">     166 </span>            :     void Check()</a>
<a name="167"><span class="lineNum">     167 </span>            :     {</a>
<a name="168"><span class="lineNum">     168 </span>            :         KRATOS_TRY;</a>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<a name="170"><span class="lineNum">     170 </span>            :         auto aux_coord = Kratos::make_shared&lt;array_1d&lt;double, 3&gt;&gt;(this-&gt;Coordinates());</a>
<a name="171"><span class="lineNum">     171 </span>            :         KRATOS_ERROR_IF(!aux_coord) &lt;&lt; &quot;Coordinates no initialized in the PointMapper class&quot; &lt;&lt; std::endl;</a>
<a name="172"><span class="lineNum">     172 </span>            :         KRATOS_ERROR_IF(mpOriginGeometricalObject-&gt;use_count() == 0) &lt;&lt; &quot;GeometricalObject no initialized in the PointMapper class&quot; &lt;&lt; std::endl;</a>
<a name="173"><span class="lineNum">     173 </span>            : </a>
<a name="174"><span class="lineNum">     174 </span>            :         KRATOS_CATCH(&quot;&quot;);</a>
<a name="175"><span class="lineNum">     175 </span>            :     }</a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span>            :     /**</a>
<a name="178"><span class="lineNum">     178 </span>            :      * @brief This function updates the database, using as base for the coordinates the geometrical object center</a>
<a name="179"><span class="lineNum">     179 </span>            :      */</a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 :     void UpdatePoint()</span></a>
<a name="181"><span class="lineNum">     181 </span>            :     {</a>
<a name="182"><span class="lineNum">     182 </span>            : #ifdef KRATOS_USE_AMATRIX   // This macro definition is for the migration period and to be removed afterward please do not use it</a>
<a name="183"><span class="lineNum">     183 </span>            :         this-&gt;Coordinates() = mpOriginGeometricalObject-&gt;GetGeometry().Center().Coordinates();</a>
<a name="184"><span class="lineNum">     184 </span>            : #else</a>
<a name="185"><span class="lineNum">     185 </span><span class="lineNoCov">          0 :         noalias(this-&gt;Coordinates()) = mpOriginGeometricalObject-&gt;GetGeometry().Center().Coordinates();</span></a>
<a name="186"><span class="lineNum">     186 </span>            : #endif // ifdef KRATOS_USE_AMATRIX</a>
<a name="187"><span class="lineNum">     187 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            : private:</a>
<a name="190"><span class="lineNum">     190 </span>            :     ///@name Member Variables</a>
<a name="191"><span class="lineNum">     191 </span>            :     ///@{</a>
<a name="192"><span class="lineNum">     192 </span>            :     GeometricalObject::Pointer mpOriginGeometricalObject; /// GeometricalObject pointer</a>
<a name="193"><span class="lineNum">     193 </span>            :     ///@}</a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span>            : }; // Class PointMapper</a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            : /**</a>
<a name="198"><span class="lineNum">     198 </span>            :  * @ingroup KratosCore</a>
<a name="199"><span class="lineNum">     199 </span>            :  * @class SimpleMortarMapperProcess</a>
<a name="200"><span class="lineNum">     200 </span>            :  * @brief This is basic mapper of values between domains using mortar formulation</a>
<a name="201"><span class="lineNum">     201 </span>            :  * @details Using the dual mortar formulation the resolution of the system of equations is not needed.</a>
<a name="202"><span class="lineNum">     202 </span>            :  * Several types of constructors are avaible depending of the needs.</a>
<a name="203"><span class="lineNum">     203 </span>            :  * If the pairs sets are not provided a search will be performed using a KDTree</a>
<a name="204"><span class="lineNum">     204 </span>            :  * @author Vicente Mataix Ferrandiz</a>
<a name="205"><span class="lineNum">     205 </span>            :  * @tparam TDim The dimension of work</a>
<a name="206"><span class="lineNum">     206 </span>            :  * @tparam TNumNodes The number of nodes of the slave</a>
<a name="207"><span class="lineNum">     207 </span>            :  * @tparam TNumNodesMaster The number of nodes of the master</a>
<a name="208"><span class="lineNum">     208 </span>            :  */</a>
<a name="209"><span class="lineNum">     209 </span>            : template&lt; const SizeType TDim, const SizeType TNumNodes, class TVarType, const SizeType TNumNodesMaster = TNumNodes&gt;</a>
<a name="210"><span class="lineNum">     210 </span>            : class KRATOS_API(KRATOS_CORE) SimpleMortarMapperProcess</a>
<a name="211"><span class="lineNum">     211 </span>            :         : public Process</a>
<a name="212"><span class="lineNum">     212 </span>            : {</a>
<a name="213"><span class="lineNum">     213 </span>            : public:</a>
<a name="214"><span class="lineNum">     214 </span>            :     ///@name Type Definitions</a>
<a name="215"><span class="lineNum">     215 </span>            :     ///@{</a>
<a name="216"><span class="lineNum">     216 </span>            : </a>
<a name="217"><span class="lineNum">     217 </span>            :     // DEFINITION OF FLAGS TO CONTROL THE BEHAVIOUR</a>
<a name="218"><span class="lineNum">     218 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(AVERAGE_NORMAL);                      /// If using average normal</a>
<a name="219"><span class="lineNum">     219 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(DISCONTINOUS_INTERFACE);              /// If interface is discontinous</a>
<a name="220"><span class="lineNum">     220 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(ORIGIN_IS_HISTORICAL);                /// If the origin variables is historical</a>
<a name="221"><span class="lineNum">     221 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(DESTINATION_IS_HISTORICAL);           /// If the destination variables is historical</a>
<a name="222"><span class="lineNum">     222 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(ORIGIN_SKIN_IS_CONDITION_BASED);      /// If the entities to take into account on the origin model part are the conditions, otherwise we will take elements into consideration</a>
<a name="223"><span class="lineNum">     223 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(DESTINATION_SKIN_IS_CONDITION_BASED); /// If the entities to take into account on the destination model part are the conditions, otherwise we will take elements into consideration</a>
<a name="224"><span class="lineNum">     224 </span>            :     KRATOS_DEFINE_LOCAL_FLAG(CONSIDER_TESELLATION);                /// If we consider the tesellation in the mortar integration</a>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<a name="226"><span class="lineNum">     226 </span>            :     /// Pointer definition of SimpleMortarMapperProcess</a>
<a name="227"><span class="lineNum">     227 </span>            :     KRATOS_CLASS_POINTER_DEFINITION(SimpleMortarMapperProcess);</a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span>            :     typedef Point                                        PointType;</a>
<a name="230"><span class="lineNum">     230 </span>            :     typedef Node&lt;3&gt;                                       NodeType;</a>
<a name="231"><span class="lineNum">     231 </span>            :     typedef Geometry&lt;NodeType&gt;                        GeometryType;</a>
<a name="232"><span class="lineNum">     232 </span>            :     typedef Geometry&lt;PointType&gt;                  GeometryPointType;</a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span>            :     /// Type definition for integration methods</a>
<a name="235"><span class="lineNum">     235 </span>            :     typedef GeometryData::IntegrationMethod      IntegrationMethod;</a>
<a name="236"><span class="lineNum">     236 </span>            : </a>
<a name="237"><span class="lineNum">     237 </span>            :     /// Auxiliar geometries</a>
<a name="238"><span class="lineNum">     238 </span>            :     typedef Line2D2&lt;PointType&gt;                            LineType;</a>
<a name="239"><span class="lineNum">     239 </span>            :     typedef Triangle3D3&lt;PointType&gt;                    TriangleType;</a>
<a name="240"><span class="lineNum">     240 </span>            :     typedef typename std::conditional&lt;TDim == 2, LineType, TriangleType &gt;::type DecompositionType;</a>
<a name="241"><span class="lineNum">     241 </span>            : </a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span>            :     /// Linear solver</a>
<a name="244"><span class="lineNum">     244 </span>            :     typedef UblasSpace&lt;double, CompressedMatrix, Vector&gt;    SparseSpaceType;</a>
<a name="245"><span class="lineNum">     245 </span>            :     typedef UblasSpace&lt;double, Matrix, Vector&gt;               LocalSpaceType;</a>
<a name="246"><span class="lineNum">     246 </span>            :     typedef typename SparseSpaceType::MatrixType                 MatrixType;</a>
<a name="247"><span class="lineNum">     247 </span>            :     typedef typename SparseSpaceType::VectorType                 VectorType;</a>
<a name="248"><span class="lineNum">     248 </span>            :     typedef LinearSolver&lt;SparseSpaceType, LocalSpaceType &gt; LinearSolverType;</a>
<a name="249"><span class="lineNum">     249 </span>            : </a>
<a name="250"><span class="lineNum">     250 </span>            : </a>
<a name="251"><span class="lineNum">     251 </span>            :     /// Index type definition</a>
<a name="252"><span class="lineNum">     252 </span>            :     typedef std::size_t                                          IndexType;</a>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<a name="254"><span class="lineNum">     254 </span>            :     /// A map for integers</a>
<a name="255"><span class="lineNum">     255 </span>            :     typedef std::unordered_map&lt;IndexType, IndexType&gt;                IntMap;</a>
<a name="256"><span class="lineNum">     256 </span>            : </a>
<a name="257"><span class="lineNum">     257 </span>            :     /// BoundedMatrix</a>
<a name="258"><span class="lineNum">     258 </span>            :     typedef BoundedMatrix&lt;double, TNumNodes, TNumNodes&gt;  BoundedMatrixType;</a>
<a name="259"><span class="lineNum">     259 </span>            : </a>
<a name="260"><span class="lineNum">     260 </span>            :     // Type definitions for the tree</a>
<a name="261"><span class="lineNum">     261 </span>            :     typedef PointMapper                                     PointMapperType;</a>
<a name="262"><span class="lineNum">     262 </span>            :     typedef PointMapperType::Pointer                       PointTypePointer;</a>
<a name="263"><span class="lineNum">     263 </span>            :     typedef std::vector&lt;PointTypePointer&gt;                       PointVector;</a>
<a name="264"><span class="lineNum">     264 </span>            :     typedef PointVector::iterator                             PointIterator;</a>
<a name="265"><span class="lineNum">     265 </span>            :     typedef std::vector&lt;double&gt;                              DistanceVector;</a>
<a name="266"><span class="lineNum">     266 </span>            :     typedef DistanceVector::iterator                       DistanceIterator;</a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span>            :     // KDtree definitions</a>
<a name="269"><span class="lineNum">     269 </span>            :     typedef Bucket&lt; 3ul, PointMapperType, PointVector, PointTypePointer, PointIterator, DistanceIterator &gt; BucketType;</a>
<a name="270"><span class="lineNum">     270 </span>            :     typedef Tree&lt; KDTreePartition&lt;BucketType&gt; &gt; KDTreeType;</a>
<a name="271"><span class="lineNum">     271 </span>            : </a>
<a name="272"><span class="lineNum">     272 </span>            :     /// Mortar definition</a>
<a name="273"><span class="lineNum">     273 </span>            :     typedef MortarKinematicVariables&lt;TNumNodes, TNumNodesMaster&gt;                        MortarKinematicVariablesType;</a>
<a name="274"><span class="lineNum">     274 </span>            :     typedef MortarOperator&lt;TNumNodes, TNumNodesMaster&gt;                                            MortarOperatorType;</a>
<a name="275"><span class="lineNum">     275 </span>            :     typedef DualLagrangeMultiplierOperators&lt;TNumNodes, TNumNodesMaster&gt;          DualLagrangeMultiplierOperatorsType;</a>
<a name="276"><span class="lineNum">     276 </span>            :     typedef ExactMortarIntegrationUtility&lt;TDim, TNumNodes, false, TNumNodesMaster&gt; ExactMortarIntegrationUtilityType;</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            :     /// Auxiliar struct for mapping</a>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :     struct TLS {</span></a>
<a name="280"><span class="lineNum">     280 </span>            :         MortarKinematicVariablesType this_kinematic_variables;    // Create and initialize condition variables:</a>
<a name="281"><span class="lineNum">     281 </span>            :         MortarOperatorType this_mortar_operators;                 // Create the mortar operators</a>
<a name="282"><span class="lineNum">     282 </span>            :         ExactMortarIntegrationUtilityType integration_utility;    // We call the exact integration utility</a>
<a name="283"><span class="lineNum">     283 </span>            :     };</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            :     ///@}</a>
<a name="286"><span class="lineNum">     286 </span>            :     ///@name Life Cycle</a>
<a name="287"><span class="lineNum">     287 </span>            :     ///@{</a>
<a name="288"><span class="lineNum">     288 </span>            : </a>
<a name="289"><span class="lineNum">     289 </span>            :     /**</a>
<a name="290"><span class="lineNum">     290 </span>            :      * @brief Default constructor</a>
<a name="291"><span class="lineNum">     291 </span>            :      * @param rOriginModelPart The origin model part to compute</a>
<a name="292"><span class="lineNum">     292 </span>            :      * @param rDestinationModelPart The destination model part to compute</a>
<a name="293"><span class="lineNum">     293 </span>            :      * @param ThisParameters The configuration parameters</a>
<a name="294"><span class="lineNum">     294 </span>            :      * @param pThisLinearSolver The pointer to the linear to be used (in case of implicit resolution)</a>
<a name="295"><span class="lineNum">     295 </span>            :      */</a>
<a name="296"><span class="lineNum">     296 </span>            :     SimpleMortarMapperProcess(</a>
<a name="297"><span class="lineNum">     297 </span>            :         ModelPart&amp; rOriginModelPart,</a>
<a name="298"><span class="lineNum">     298 </span>            :         ModelPart&amp; rDestinationModelPart,</a>
<a name="299"><span class="lineNum">     299 </span>            :         Parameters ThisParameters = Parameters(R&quot;({})&quot; ),</a>
<a name="300"><span class="lineNum">     300 </span>            :         LinearSolverType::Pointer pThisLinearSolver = nullptr</a>
<a name="301"><span class="lineNum">     301 </span>            :         );</a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span>            :     /**</a>
<a name="304"><span class="lineNum">     304 </span>            :      * @brief Default constructor</a>
<a name="305"><span class="lineNum">     305 </span>            :      * @param rOriginModelPart The origin model part to compute</a>
<a name="306"><span class="lineNum">     306 </span>            :      * @param rDestinationModelPart The destination model part to compute</a>
<a name="307"><span class="lineNum">     307 </span>            :      * @param rThisVariable The variable to transfer and be transfered</a>
<a name="308"><span class="lineNum">     308 </span>            :      * @param ThisParameters The configuration parameters</a>
<a name="309"><span class="lineNum">     309 </span>            :      * @param pThisLinearSolver The pointer to the linear to be used (in case of implicit resolution)</a>
<a name="310"><span class="lineNum">     310 </span>            :      */</a>
<a name="311"><span class="lineNum">     311 </span>            :     SimpleMortarMapperProcess(</a>
<a name="312"><span class="lineNum">     312 </span>            :         ModelPart&amp; rOriginModelPart,</a>
<a name="313"><span class="lineNum">     313 </span>            :         ModelPart&amp; rDestinationModelPart,</a>
<a name="314"><span class="lineNum">     314 </span>            :         TVarType&amp; rThisVariable,</a>
<a name="315"><span class="lineNum">     315 </span>            :         Parameters ThisParameters = Parameters(R&quot;({})&quot; ),</a>
<a name="316"><span class="lineNum">     316 </span>            :         LinearSolverType::Pointer pThisLinearSolver = nullptr</a>
<a name="317"><span class="lineNum">     317 </span>            :         );</a>
<a name="318"><span class="lineNum">     318 </span>            : </a>
<a name="319"><span class="lineNum">     319 </span>            :     /**</a>
<a name="320"><span class="lineNum">     320 </span>            :      * @brief A constructor where two different variables can be considered for each subdomain</a>
<a name="321"><span class="lineNum">     321 </span>            :      * @param rOriginModelPart The origin model part to compute</a>
<a name="322"><span class="lineNum">     322 </span>            :      * @param rDestinationModelPart The destination model part to compute</a>
<a name="323"><span class="lineNum">     323 </span>            :      * @param rOriginVariable The variable to transfer</a>
<a name="324"><span class="lineNum">     324 </span>            :      * @param rDestinationVariable The variable to be transfered</a>
<a name="325"><span class="lineNum">     325 </span>            :      * @param ThisParameters The configuration parameters</a>
<a name="326"><span class="lineNum">     326 </span>            :      * @param pThisLinearSolver The pointer to the linear to be used (in case of implicit resolution)</a>
<a name="327"><span class="lineNum">     327 </span>            :      */</a>
<a name="328"><span class="lineNum">     328 </span>            :     SimpleMortarMapperProcess(</a>
<a name="329"><span class="lineNum">     329 </span>            :         ModelPart&amp; rOriginModelPart,</a>
<a name="330"><span class="lineNum">     330 </span>            :         ModelPart&amp; rDestinationModelPart,</a>
<a name="331"><span class="lineNum">     331 </span>            :         TVarType&amp; rOriginVariable,</a>
<a name="332"><span class="lineNum">     332 </span>            :         TVarType&amp; rDestinationVariable,</a>
<a name="333"><span class="lineNum">     333 </span>            :         Parameters ThisParameters = Parameters(R&quot;({})&quot; ),</a>
<a name="334"><span class="lineNum">     334 </span>            :         LinearSolverType::Pointer pThisLinearSolver = nullptr</a>
<a name="335"><span class="lineNum">     335 </span>            :         );</a>
<a name="336"><span class="lineNum">     336 </span>            : </a>
<a name="337"><span class="lineNum">     337 </span>            :     /// Destructor.</a>
<a name="338"><span class="lineNum">     338 </span><span class="lineNoCov">          0 :     ~SimpleMortarMapperProcess() override = default;</span></a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span>            :     ///@}</a>
<a name="341"><span class="lineNum">     341 </span>            :     ///@name Access</a>
<a name="342"><span class="lineNum">     342 </span>            :     ///@{</a>
<a name="343"><span class="lineNum">     343 </span>            : </a>
<a name="344"><span class="lineNum">     344 </span>            :     ///@}</a>
<a name="345"><span class="lineNum">     345 </span>            :     ///@name Inquiry</a>
<a name="346"><span class="lineNum">     346 </span>            :     ///@{</a>
<a name="347"><span class="lineNum">     347 </span>            : </a>
<a name="348"><span class="lineNum">     348 </span>            :     ///@}</a>
<a name="349"><span class="lineNum">     349 </span>            :     ///@name Input and output</a>
<a name="350"><span class="lineNum">     350 </span>            :     ///@{</a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span>            :     ///@}</a>
<a name="353"><span class="lineNum">     353 </span>            :     ///@name Friends</a>
<a name="354"><span class="lineNum">     354 </span>            :     ///@{</a>
<a name="355"><span class="lineNum">     355 </span>            : </a>
<a name="356"><span class="lineNum">     356 </span>            :     ///@}</a>
<a name="357"><span class="lineNum">     357 </span>            :     ///@name Operators</a>
<a name="358"><span class="lineNum">     358 </span>            :     ///@{</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :     void operator()()</span></a>
<a name="361"><span class="lineNum">     361 </span>            :     {</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 :         Execute();</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            :     ///@}</a>
<a name="366"><span class="lineNum">     366 </span>            :     ///@name Operations</a>
<a name="367"><span class="lineNum">     367 </span>            :     ///@{</a>
<a name="368"><span class="lineNum">     368 </span>            : </a>
<a name="369"><span class="lineNum">     369 </span>            :     /**</a>
<a name="370"><span class="lineNum">     370 </span>            :      * @brief Execute method is used to execute the Process algorithms.</a>
<a name="371"><span class="lineNum">     371 </span>            :      */</a>
<a name="372"><span class="lineNum">     372 </span>            :     void Execute() override;</a>
<a name="373"><span class="lineNum">     373 </span>            : </a>
<a name="374"><span class="lineNum">     374 </span>            :     /**</a>
<a name="375"><span class="lineNum">     375 </span>            :      * @details This function will be executed at every time step BEFORE performing the solve phase</a>
<a name="376"><span class="lineNum">     376 </span>            :      */</a>
<a name="377"><span class="lineNum">     377 </span>            :     void ExecuteInitializeSolutionStep() override;</a>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<a name="379"><span class="lineNum">     379 </span>            :     /**</a>
<a name="380"><span class="lineNum">     380 </span>            :      * @brief This method is a direct map between the origin and destination modelpart with custom variables</a>
<a name="381"><span class="lineNum">     381 </span>            :      * @param rOriginVariable The origin model part</a>
<a name="382"><span class="lineNum">     382 </span>            :      * @param rDestinationVariable The destination model part</a>
<a name="383"><span class="lineNum">     383 </span>            :      * @param Flag The flags to special settings. Right now does nothing</a>
<a name="384"><span class="lineNum">     384 </span>            :      */</a>
<a name="385"><span class="lineNum">     385 </span><span class="lineNoCov">          0 :     void Map(</span></a>
<a name="386"><span class="lineNum">     386 </span>            :         TVarType&amp; rOriginVariable,</a>
<a name="387"><span class="lineNum">     387 </span>            :         TVarType&amp; rDestinationVariable,</a>
<a name="388"><span class="lineNum">     388 </span>            :         const Flags Flag = Flags()</a>
<a name="389"><span class="lineNum">     389 </span>            :         )</a>
<a name="390"><span class="lineNum">     390 </span>            :     {</a>
<a name="391"><span class="lineNum">     391 </span>            :         // Reassign the variables</a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :         mpOriginVariable = &amp;rOriginVariable;</span></a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :         mpDestinationVariable = &amp;rDestinationVariable;</span></a>
<a name="394"><span class="lineNum">     394 </span>            : </a>
<a name="395"><span class="lineNum">     395 </span>            :         // Execute the process</a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :         Execute();</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="398"><span class="lineNum">     398 </span>            : </a>
<a name="399"><span class="lineNum">     399 </span>            :     /**</a>
<a name="400"><span class="lineNum">     400 </span>            :      * @brief This method provides the defaults parameters to avoid conflicts between the different constructors</a>
<a name="401"><span class="lineNum">     401 </span>            :      */</a>
<a name="402"><span class="lineNum">     402 </span>            :     const Parameters GetDefaultParameters() const override;</a>
<a name="403"><span class="lineNum">     403 </span>            : </a>
<a name="404"><span class="lineNum">     404 </span>            :     ///@}</a>
<a name="405"><span class="lineNum">     405 </span>            :     ///@name Access</a>
<a name="406"><span class="lineNum">     406 </span>            :     ///@{</a>
<a name="407"><span class="lineNum">     407 </span>            : </a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span>            :     ///@}</a>
<a name="410"><span class="lineNum">     410 </span>            :     ///@name Inquiry</a>
<a name="411"><span class="lineNum">     411 </span>            :     ///@{</a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span>            : </a>
<a name="414"><span class="lineNum">     414 </span>            :     ///@}</a>
<a name="415"><span class="lineNum">     415 </span>            :     ///@name Input and output</a>
<a name="416"><span class="lineNum">     416 </span>            :     ///@{</a>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<a name="418"><span class="lineNum">     418 </span>            :     /// Turn back information as a string.</a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :     std::string Info() const override</span></a>
<a name="420"><span class="lineNum">     420 </span>            :     {</a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :         return &quot;SimpleMortarMapperProcess&quot;;</span></a>
<a name="422"><span class="lineNum">     422 </span>            :     }</a>
<a name="423"><span class="lineNum">     423 </span>            : </a>
<a name="424"><span class="lineNum">     424 </span>            :     /// Print information about this object.</a>
<a name="425"><span class="lineNum">     425 </span><span class="lineNoCov">          0 :     void PrintInfo(std::ostream&amp; rOStream) const override</span></a>
<a name="426"><span class="lineNum">     426 </span>            :     {</a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :         rOStream &lt;&lt; &quot;SimpleMortarMapperProcess&quot;;</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<a name="430"><span class="lineNum">     430 </span>            :     /// Print object's data.</a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :     void PrintData(std::ostream&amp; rOStream) const override</span></a>
<a name="432"><span class="lineNum">     432 </span>            :     {</a>
<a name="433"><span class="lineNum">     433 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="434"><span class="lineNum">     434 </span>            : </a>
<a name="435"><span class="lineNum">     435 </span>            :     ///@}</a>
<a name="436"><span class="lineNum">     436 </span>            :     ///@name Friends</a>
<a name="437"><span class="lineNum">     437 </span>            :     ///@{</a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span>            :     ///@}</a>
<a name="440"><span class="lineNum">     440 </span>            : protected:</a>
<a name="441"><span class="lineNum">     441 </span>            : </a>
<a name="442"><span class="lineNum">     442 </span>            :     ///@name Protected static Member Variables</a>
<a name="443"><span class="lineNum">     443 </span>            :     ///@{</a>
<a name="444"><span class="lineNum">     444 </span>            : </a>
<a name="445"><span class="lineNum">     445 </span>            :     ///@}</a>
<a name="446"><span class="lineNum">     446 </span>            :     ///@name Protected member Variables</a>
<a name="447"><span class="lineNum">     447 </span>            :     ///@{</a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span>            :     ///@}</a>
<a name="450"><span class="lineNum">     450 </span>            :     ///@name Protected Operators</a>
<a name="451"><span class="lineNum">     451 </span>            :     ///@{</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            :     ///@}</a>
<a name="454"><span class="lineNum">     454 </span>            :     ///@name Protected Operations</a>
<a name="455"><span class="lineNum">     455 </span>            :     ///@{</a>
<a name="456"><span class="lineNum">     456 </span>            : </a>
<a name="457"><span class="lineNum">     457 </span>            :     ///@}</a>
<a name="458"><span class="lineNum">     458 </span>            :     ///@name Protected  Access</a>
<a name="459"><span class="lineNum">     459 </span>            :     ///@{</a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span>            :     ///@}</a>
<a name="462"><span class="lineNum">     462 </span>            :     ///@name Protected Inquiry</a>
<a name="463"><span class="lineNum">     463 </span>            :     ///@{</a>
<a name="464"><span class="lineNum">     464 </span>            : </a>
<a name="465"><span class="lineNum">     465 </span>            :     ///@}</a>
<a name="466"><span class="lineNum">     466 </span>            :     ///@name Protected LifeCycle</a>
<a name="467"><span class="lineNum">     467 </span>            :     ///@{</a>
<a name="468"><span class="lineNum">     468 </span>            :     ///@}</a>
<a name="469"><span class="lineNum">     469 </span>            : </a>
<a name="470"><span class="lineNum">     470 </span>            : private:</a>
<a name="471"><span class="lineNum">     471 </span>            :     ///@name Static Member Variables</a>
<a name="472"><span class="lineNum">     472 </span>            :     ///@{</a>
<a name="473"><span class="lineNum">     473 </span>            :     ///@}</a>
<a name="474"><span class="lineNum">     474 </span>            :     ///@name Member Variables</a>
<a name="475"><span class="lineNum">     475 </span>            :     ///@{</a>
<a name="476"><span class="lineNum">     476 </span>            : </a>
<a name="477"><span class="lineNum">     477 </span>            :     ModelPart&amp; mOriginModelPart;                  /// The origin model part to compute</a>
<a name="478"><span class="lineNum">     478 </span>            :     ModelPart&amp; mDestinationModelPart;             /// The destination model part to compute</a>
<a name="479"><span class="lineNum">     479 </span>            :     const TVarType* mpOriginVariable;             /// The origin variable to map</a>
<a name="480"><span class="lineNum">     480 </span>            :     const TVarType* mpDestinationVariable;        /// The destiny variable to map</a>
<a name="481"><span class="lineNum">     481 </span>            : </a>
<a name="482"><span class="lineNum">     482 </span>            :     double mMappingCoefficient = 1.0;             /// The mapping coefficient</a>
<a name="483"><span class="lineNum">     483 </span>            :     Flags mOptions;                               /// Local flags</a>
<a name="484"><span class="lineNum">     484 </span>            : </a>
<a name="485"><span class="lineNum">     485 </span>            :     unsigned int mEchoLevel = 0;                  /// The verbosity level</a>
<a name="486"><span class="lineNum">     486 </span>            :     Parameters mThisParameters;                   /// The configuration parameters</a>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span>            :     LinearSolverType::Pointer mpThisLinearSolver; /// The linear solver used to compute the solution</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span>            :     ///@}</a>
<a name="491"><span class="lineNum">     491 </span>            :     ///@name Private Operators</a>
<a name="492"><span class="lineNum">     492 </span>            :     ///@{</a>
<a name="493"><span class="lineNum">     493 </span>            : </a>
<a name="494"><span class="lineNum">     494 </span>            :     ///@}</a>
<a name="495"><span class="lineNum">     495 </span>            :     ///@name Private Operations</a>
<a name="496"><span class="lineNum">     496 </span>            :     ///@{</a>
<a name="497"><span class="lineNum">     497 </span>            : </a>
<a name="498"><span class="lineNum">     498 </span>            :     /**</a>
<a name="499"><span class="lineNum">     499 </span>            :      * @brief Check if the pairs has been created</a>
<a name="500"><span class="lineNum">     500 </span>            :      */</a>
<a name="501"><span class="lineNum">     501 </span>            :     void CheckAndPerformSearch();</a>
<a name="502"><span class="lineNum">     502 </span>            : </a>
<a name="503"><span class="lineNum">     503 </span>            :     /**</a>
<a name="504"><span class="lineNum">     504 </span>            :      * @brief This method resets the nodal area</a>
<a name="505"><span class="lineNum">     505 </span>            :      */</a>
<a name="506"><span class="lineNum">     506 </span>            :     void ResetNodalArea();</a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :     /**</a>
<a name="509"><span class="lineNum">     509 </span>            :      * @brief This method gets the max area of the conditions from the modelpart</a>
<a name="510"><span class="lineNum">     510 </span>            :      */</a>
<a name="511"><span class="lineNum">     511 </span>            :     double GetReferenceArea();</a>
<a name="512"><span class="lineNum">     512 </span>            : </a>
<a name="513"><span class="lineNum">     513 </span>            :     /**</a>
<a name="514"><span class="lineNum">     514 </span>            :      * @brief This method assemble locally the mortar operators</a>
<a name="515"><span class="lineNum">     515 </span>            :      * @param rGeometricalObjectsPointSlave The list of points that form the triangle decomposition</a>
<a name="516"><span class="lineNum">     516 </span>            :      * @param rSlaveGeometry The slave geometry</a>
<a name="517"><span class="lineNum">     517 </span>            :      * @param rMasterGeometry The master geometry</a>
<a name="518"><span class="lineNum">     518 </span>            :      * @param rMasterNormal The normal vector of the master geometry</a>
<a name="519"><span class="lineNum">     519 </span>            :      * @param rThisKinematicVariables The kinematic variables of the geometries, needed to integrate the mortar operators</a>
<a name="520"><span class="lineNum">     520 </span>            :      * @param rThisMortarOperators The mortar operators</a>
<a name="521"><span class="lineNum">     521 </span>            :      * @param rThisIntegrationMethod The integration method used, determines the integration order</a>
<a name="522"><span class="lineNum">     522 </span>            :      * @param Ae The dual lagrange multiplier operator</a>
<a name="523"><span class="lineNum">     523 </span>            :      */</a>
<a name="524"><span class="lineNum">     524 </span>            :     void AssemblyMortarOperators(</a>
<a name="525"><span class="lineNum">     525 </span>            :         const std::vector&lt;array_1d&lt;PointType,TDim&gt;&gt;&amp; rGeometricalObjectsPointSlave,</a>
<a name="526"><span class="lineNum">     526 </span>            :         const GeometryType&amp; rSlaveGeometry,</a>
<a name="527"><span class="lineNum">     527 </span>            :         const GeometryType&amp; rMasterGeometry,</a>
<a name="528"><span class="lineNum">     528 </span>            :         const array_1d&lt;double, 3&gt;&amp; rMasterNormal,</a>
<a name="529"><span class="lineNum">     529 </span>            :         MortarKinematicVariablesType&amp; rThisKinematicVariables,</a>
<a name="530"><span class="lineNum">     530 </span>            :         MortarOperatorType&amp; rThisMortarOperators,</a>
<a name="531"><span class="lineNum">     531 </span>            :         const IntegrationMethod&amp; rThisIntegrationMethod,</a>
<a name="532"><span class="lineNum">     532 </span>            :         const BoundedMatrixType Ae = IdentityMatrix(TNumNodes)</a>
<a name="533"><span class="lineNum">     533 </span>            :         );</a>
<a name="534"><span class="lineNum">     534 </span>            : </a>
<a name="535"><span class="lineNum">     535 </span>            :     /**</a>
<a name="536"><span class="lineNum">     536 </span>            :      * @brief This method computes the Ae matrix</a>
<a name="537"><span class="lineNum">     537 </span>            :      * @param rSlaveGeometry The slave geometry</a>
<a name="538"><span class="lineNum">     538 </span>            :      * @param rThisKinematicVariables The kinematic variables</a>
<a name="539"><span class="lineNum">     539 </span>            :      * @param rConditionsPointsSlave The list of decomposed triangles</a>
<a name="540"><span class="lineNum">     540 </span>            :      * @param rThisIntegrationMethod The integration method considered</a>
<a name="541"><span class="lineNum">     541 </span>            :      * @return Ae: The matrix of dual LM</a>
<a name="542"><span class="lineNum">     542 </span>            :      */</a>
<a name="543"><span class="lineNum">     543 </span>            :     static inline BoundedMatrixType CalculateAe(</a>
<a name="544"><span class="lineNum">     544 </span>            :         GeometryType&amp; rSlaveGeometry,</a>
<a name="545"><span class="lineNum">     545 </span>            :         MortarKinematicVariablesType&amp; rThisKinematicVariables,</a>
<a name="546"><span class="lineNum">     546 </span>            :         std::vector&lt;array_1d&lt;PointType,TDim&gt;&gt;&amp; rConditionsPointsSlave,</a>
<a name="547"><span class="lineNum">     547 </span>            :         const IntegrationMethod&amp; rThisIntegrationMethod</a>
<a name="548"><span class="lineNum">     548 </span>            :         );</a>
<a name="549"><span class="lineNum">     549 </span>            : </a>
<a name="550"><span class="lineNum">     550 </span>            :     /**</a>
<a name="551"><span class="lineNum">     551 </span>            :      * @brief This method inverts a diagonal matrix</a>
<a name="552"><span class="lineNum">     552 </span>            :      * @param rInputMatrix The matrix to invert</a>
<a name="553"><span class="lineNum">     553 </span>            :      * @return The matrix inverted</a>
<a name="554"><span class="lineNum">     554 </span>            :      */</a>
<a name="555"><span class="lineNum">     555 </span>            :     static inline BoundedMatrixType InvertDiagonalMatrix(const BoundedMatrixType&amp; rInputMatrix);</a>
<a name="556"><span class="lineNum">     556 </span>            : </a>
<a name="557"><span class="lineNum">     557 </span>            :     /**</a>
<a name="558"><span class="lineNum">     558 </span>            :      * @brief This method inverts a diagonal matrix</a>
<a name="559"><span class="lineNum">     559 </span>            :      * @param rInputMatrix The matrix to invert</a>
<a name="560"><span class="lineNum">     560 </span>            :      * @param rInvertedMatrix The matrix inverted</a>
<a name="561"><span class="lineNum">     561 </span>            :      */</a>
<a name="562"><span class="lineNum">     562 </span>            :     static inline void InvertDiagonalMatrix(</a>
<a name="563"><span class="lineNum">     563 </span>            :         const BoundedMatrixType&amp; rInputMatrix,</a>
<a name="564"><span class="lineNum">     564 </span>            :         BoundedMatrixType&amp; rInvertedMatrix</a>
<a name="565"><span class="lineNum">     565 </span>            :         );</a>
<a name="566"><span class="lineNum">     566 </span>            : </a>
<a name="567"><span class="lineNum">     567 </span>            :     /**</a>
<a name="568"><span class="lineNum">     568 </span>            :      * @brief This method lumps a matrix</a>
<a name="569"><span class="lineNum">     569 </span>            :      * @param rInputMatrix The matrix to lump</a>
<a name="570"><span class="lineNum">     570 </span>            :      */</a>
<a name="571"><span class="lineNum">     571 </span>            :     void LumpMatrix(BoundedMatrixType&amp; rInputMatrix);</a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span>            :     /**</a>
<a name="574"><span class="lineNum">     574 </span>            :      * @brief This method computes the size of the system</a>
<a name="575"><span class="lineNum">     575 </span>            :      * @param rSizeSystem The size of the system</a>
<a name="576"><span class="lineNum">     576 </span>            :      */</a>
<a name="577"><span class="lineNum">     577 </span>            :     void GetSystemSize(SizeType&amp; rSizeSystem);</a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span>            :     /**</a>
<a name="580"><span class="lineNum">     580 </span>            :      * @brief This method creates a slave database needed to assemble the system</a>
<a name="581"><span class="lineNum">     581 </span>            :      * @param rSizeSystem The size of the system</a>
<a name="582"><span class="lineNum">     582 </span>            :      * @param rConectivityDatabase The database that will be used to assemble the system</a>
<a name="583"><span class="lineNum">     583 </span>            :      * @param rInverseConectivityDatabase The inverse database that will be used to assemble the system</a>
<a name="584"><span class="lineNum">     584 </span>            :      */</a>
<a name="585"><span class="lineNum">     585 </span>            :     void CreateSlaveConectivityDatabase(</a>
<a name="586"><span class="lineNum">     586 </span>            :         SizeType&amp; rSizeSystem,</a>
<a name="587"><span class="lineNum">     587 </span>            :         IntMap&amp; rConectivityDatabase,</a>
<a name="588"><span class="lineNum">     588 </span>            :         IntMap&amp; rInverseConectivityDatabase</a>
<a name="589"><span class="lineNum">     589 </span>            :         );</a>
<a name="590"><span class="lineNum">     590 </span>            : </a>
<a name="591"><span class="lineNum">     591 </span>            :     /**</a>
<a name="592"><span class="lineNum">     592 </span>            :      * @brief This method returns the corresponding integration order considered</a>
<a name="593"><span class="lineNum">     593 </span>            :      * @return The integration order considered</a>
<a name="594"><span class="lineNum">     594 </span>            :      */</a>
<a name="595"><span class="lineNum">     595 </span>            :     IntegrationMethod GetIntegrationMethod();</a>
<a name="596"><span class="lineNum">     596 </span>            : </a>
<a name="597"><span class="lineNum">     597 </span>            :     /**</a>
<a name="598"><span class="lineNum">     598 </span>            :      * @brief This method checks if all components of a vector are true</a>
<a name="599"><span class="lineNum">     599 </span>            :      * @param rVectorToCheck The vector to check</a>
<a name="600"><span class="lineNum">     600 </span>            :      * @return result True if all componets are true</a>
<a name="601"><span class="lineNum">     601 </span>            :      */</a>
<a name="602"><span class="lineNum">     602 </span>            :     bool CheckWholeVector(std::vector&lt;bool&gt;&amp; rVectorToCheck);</a>
<a name="603"><span class="lineNum">     603 </span>            : </a>
<a name="604"><span class="lineNum">     604 </span>            :     /**</a>
<a name="605"><span class="lineNum">     605 </span>            :      * @brief This method computes the residual matrix of the mapping</a>
<a name="606"><span class="lineNum">     606 </span>            :      * @param rResidualMatrix The matrix containing the residual of the mappping</a>
<a name="607"><span class="lineNum">     607 </span>            :      * @param rSlaveGeometry The slave geometry</a>
<a name="608"><span class="lineNum">     608 </span>            :      * @param rMasterGeometry The master geometry</a>
<a name="609"><span class="lineNum">     609 </span>            :      * @param rThisMortarOperators The mortar operators</a>
<a name="610"><span class="lineNum">     610 </span>            :      */</a>
<a name="611"><span class="lineNum">     611 </span>            :     void ComputeResidualMatrix(</a>
<a name="612"><span class="lineNum">     612 </span>            :         Matrix&amp; rResidualMatrix,</a>
<a name="613"><span class="lineNum">     613 </span>            :         const GeometryType&amp; rSlaveGeometry,</a>
<a name="614"><span class="lineNum">     614 </span>            :         const GeometryType&amp; rMasterGeometry,</a>
<a name="615"><span class="lineNum">     615 </span>            :         const MortarOperatorType&amp; rThisMortarOperators</a>
<a name="616"><span class="lineNum">     616 </span>            :         );</a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span>            :     /**</a>
<a name="619"><span class="lineNum">     619 </span>            :      * @brief This method assembles the LHS and the RHS</a>
<a name="620"><span class="lineNum">     620 </span>            :      * @param rA The LHS of the system</a>
<a name="621"><span class="lineNum">     621 </span>            :      * @param rb The RHS of the system</a>
<a name="622"><span class="lineNum">     622 </span>            :      * @param VariableSize The size of the variable</a>
<a name="623"><span class="lineNum">     623 </span>            :      * @param rResidualMatrix The matrix containing the residual of the mappping</a>
<a name="624"><span class="lineNum">     624 </span>            :      * @param rSlaveGeometry The slave geometry</a>
<a name="625"><span class="lineNum">     625 </span>            :      * @param rInverseConectivityDatabase The inverse database that will be used to assemble the system</a>
<a name="626"><span class="lineNum">     626 </span>            :      * @param rThisMortarOperators The mortar operators</a>
<a name="627"><span class="lineNum">     627 </span>            :      */</a>
<a name="628"><span class="lineNum">     628 </span>            :     void AssembleRHSAndLHS(</a>
<a name="629"><span class="lineNum">     629 </span>            :         MatrixType&amp; rA,</a>
<a name="630"><span class="lineNum">     630 </span>            :         std::vector&lt;VectorType&gt;&amp; rb,</a>
<a name="631"><span class="lineNum">     631 </span>            :         const SizeType VariableSize,</a>
<a name="632"><span class="lineNum">     632 </span>            :         const Matrix&amp; rResidualMatrix,</a>
<a name="633"><span class="lineNum">     633 </span>            :         const GeometryType&amp; rSlaveGeometry,</a>
<a name="634"><span class="lineNum">     634 </span>            :         IntMap&amp; rInverseConectivityDatabase,</a>
<a name="635"><span class="lineNum">     635 </span>            :         const MortarOperatorType&amp; rThisMortarOperators</a>
<a name="636"><span class="lineNum">     636 </span>            :         );</a>
<a name="637"><span class="lineNum">     637 </span>            : </a>
<a name="638"><span class="lineNum">     638 </span>            :     /**</a>
<a name="639"><span class="lineNum">     639 </span>            :      * @brief This method assembles the RHS</a>
<a name="640"><span class="lineNum">     640 </span>            :      * @param rb The RHS of the system</a>
<a name="641"><span class="lineNum">     641 </span>            :      * @param VariableSize The size of the variable</a>
<a name="642"><span class="lineNum">     642 </span>            :      * @param rResidualMatrix The matrix containing the residual of the mappping</a>
<a name="643"><span class="lineNum">     643 </span>            :      * @param rSlaveGeometry The slave geometry</a>
<a name="644"><span class="lineNum">     644 </span>            :      * @param rInverseConectivityDatabase The inverse database that will be used to assemble the system</a>
<a name="645"><span class="lineNum">     645 </span>            :      */</a>
<a name="646"><span class="lineNum">     646 </span>            :     void AssembleRHS(</a>
<a name="647"><span class="lineNum">     647 </span>            :         std::vector&lt;VectorType&gt;&amp; rb,</a>
<a name="648"><span class="lineNum">     648 </span>            :         const SizeType VariableSize,</a>
<a name="649"><span class="lineNum">     649 </span>            :         const Matrix&amp; rResidualMatrix,</a>
<a name="650"><span class="lineNum">     650 </span>            :         const GeometryType&amp; rSlaveGeometry,</a>
<a name="651"><span class="lineNum">     651 </span>            :         IntMap&amp; rInverseConectivityDatabase</a>
<a name="652"><span class="lineNum">     652 </span>            :         );</a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span>            :     /**</a>
<a name="655"><span class="lineNum">     655 </span>            :      * @brief This method executes the explicit mapping (when no linear solver is avalaible)</a>
<a name="656"><span class="lineNum">     656 </span>            :      */</a>
<a name="657"><span class="lineNum">     657 </span>            :     void ExecuteExplicitMapping();</a>
<a name="658"><span class="lineNum">     658 </span>            : </a>
<a name="659"><span class="lineNum">     659 </span>            :     /**</a>
<a name="660"><span class="lineNum">     660 </span>            :      * @brief This method executes the mapping when a linear solver is avalaible and a system of equations can be solved</a>
<a name="661"><span class="lineNum">     661 </span>            :      */</a>
<a name="662"><span class="lineNum">     662 </span>            :     void ExecuteImplicitMapping();</a>
<a name="663"><span class="lineNum">     663 </span>            : </a>
<a name="664"><span class="lineNum">     664 </span>            :     /**</a>
<a name="665"><span class="lineNum">     665 </span>            :      * @brief This method computes common methods between the implicit and explicit formulation</a>
<a name="666"><span class="lineNum">     666 </span>            :      * @param rA The LHS of the system</a>
<a name="667"><span class="lineNum">     667 </span>            :      * @param rb The RHS of the system</a>
<a name="668"><span class="lineNum">     668 </span>            :      * @param rInverseConectivityDatabase The inverse database that will be used to assemble the system</a>
<a name="669"><span class="lineNum">     669 </span>            :      * @param pIndexesPairs The pointer to indexed objects</a>
<a name="670"><span class="lineNum">     670 </span>            :      * @param rGeometricalObject Reference of a geometrical object</a>
<a name="671"><span class="lineNum">     671 </span>            :      * @param rIntegrationUtility An integration utility for mortar</a>
<a name="672"><span class="lineNum">     672 </span>            :      * @param rThisKineticVariables Kinematic variables (shape functions)</a>
<a name="673"><span class="lineNum">     673 </span>            :      * @param rThisMortarOperators The mortar operators</a>
<a name="674"><span class="lineNum">     674 </span>            :      * @param Iteration The current non-linear iteration</a>
<a name="675"><span class="lineNum">     675 </span>            :      * @tparam TClassType The class of index pairs considered</a>
<a name="676"><span class="lineNum">     676 </span>            :      * @tparam TImplicit If we solve with lamping or we use a linear solver</a>
<a name="677"><span class="lineNum">     677 </span>            :      */</a>
<a name="678"><span class="lineNum">     678 </span>            :     template&lt;class TClassType, bool TImplicit = false&gt;</a>
<a name="679"><span class="lineNum">     679 </span><span class="lineNoCov">          0 :     void PerformMortarOperations(</span></a>
<a name="680"><span class="lineNum">     680 </span>            :         MatrixType&amp; rA,</a>
<a name="681"><span class="lineNum">     681 </span>            :         std::vector&lt;VectorType&gt;&amp; rb,</a>
<a name="682"><span class="lineNum">     682 </span>            :         IntMap&amp; rInverseConectivityDatabase,</a>
<a name="683"><span class="lineNum">     683 </span>            :         typename TClassType::Pointer pIndexesPairs,</a>
<a name="684"><span class="lineNum">     684 </span>            :         GeometricalObject&amp; rGeometricalObject,</a>
<a name="685"><span class="lineNum">     685 </span>            :         ExactMortarIntegrationUtilityType&amp; rIntegrationUtility,</a>
<a name="686"><span class="lineNum">     686 </span>            :         MortarKinematicVariablesType&amp; rThisKineticVariables,</a>
<a name="687"><span class="lineNum">     687 </span>            :         MortarOperatorType&amp; rThisMortarOperators,</a>
<a name="688"><span class="lineNum">     688 </span>            :         const IndexType Iteration</a>
<a name="689"><span class="lineNum">     689 </span>            :         )</a>
<a name="690"><span class="lineNum">     690 </span>            :     {</a>
<a name="691"><span class="lineNum">     691 </span>            :         // The root model part</a>
<a name="692"><span class="lineNum">     692 </span><span class="lineNoCov">          0 :         ModelPart&amp; r_root_model_part = mOriginModelPart.GetRootModelPart();</span></a>
<a name="693"><span class="lineNum">     693 </span>            : </a>
<a name="694"><span class="lineNum">     694 </span>            :         // Getting the auxiliar variable</a>
<a name="695"><span class="lineNum">     695 </span><span class="lineNoCov">          0 :         const TVarType&amp; r_aux_variable = KratosComponents&lt;TVarType&gt;::Get(MortarUtilities::GetAuxiliarVariable&lt;TVarType&gt;());</span></a>
<a name="696"><span class="lineNum">     696 </span>            : </a>
<a name="697"><span class="lineNum">     697 </span>            :         // Indexes of the pair to be removed</a>
<a name="698"><span class="lineNum">     698 </span>            :         std::vector&lt;IndexType&gt; indexes_to_remove, geometrical_objects_to_erase;</a>
<a name="699"><span class="lineNum">     699 </span>            : </a>
<a name="700"><span class="lineNum">     700 </span>            :         // Getting discontinous factor</a>
<a name="701"><span class="lineNum">     701 </span><span class="lineNoCov">          0 :         const double discontinous_interface_factor = mOptions.Is(DISCONTINOUS_INTERFACE) ? mThisParameters[&quot;discontinous_interface_factor&quot;].GetDouble() : 1.0;</span></a>
<a name="702"><span class="lineNum">     702 </span>            : </a>
<a name="703"><span class="lineNum">     703 </span>            :         // Declare auxiliar coordinates</a>
<a name="704"><span class="lineNum">     704 </span>            :         GeometryType::CoordinatesArrayType aux_coords;</a>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<a name="706"><span class="lineNum">     706 </span>            :         // Geometrical values</a>
<a name="707"><span class="lineNum">     707 </span>            :         auto&amp; r_slave_geometry = rGeometricalObject.GetGeometry();</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineNoCov">          0 :         r_slave_geometry.PointLocalCoordinates(aux_coords, r_slave_geometry.Center());</span></a>
<a name="709"><span class="lineNum">     709 </span><span class="lineNoCov">          0 :         const array_1d&lt;double, 3&gt; slave_normal = r_slave_geometry.UnitNormal(aux_coords);</span></a>
<a name="710"><span class="lineNum">     710 </span>            : </a>
<a name="711"><span class="lineNum">     711 </span>            :         // The model part as const to avoid race conditions</a>
<a name="712"><span class="lineNum">     712 </span><span class="lineNoCov">          0 :         const auto&amp; r_const_origin_model_part = mOriginModelPart;</span></a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 :         const auto&amp; r_const_destination_model_part = mDestinationModelPart;</span></a>
<a name="714"><span class="lineNum">     714 </span>            : </a>
<a name="715"><span class="lineNum">     715 </span><span class="lineNoCov">          0 :         for (auto it_pair = pIndexesPairs-&gt;begin(); it_pair != pIndexesPairs-&gt;end(); ++it_pair ) {</span></a>
<a name="716"><span class="lineNum">     716 </span><span class="lineNoCov">          0 :             const IndexType master_id = pIndexesPairs-&gt;GetId(it_pair); // MASTER</span></a>
<a name="717"><span class="lineNum">     717 </span>            : </a>
<a name="718"><span class="lineNum">     718 </span><span class="lineNoCov">          0 :             const auto&amp; r_master_geometry = mOptions.Is(ORIGIN_SKIN_IS_CONDITION_BASED) ? r_const_origin_model_part.GetCondition(master_id).GetGeometry() : r_const_origin_model_part.GetElement(master_id).GetGeometry();</span></a>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 :             r_master_geometry.PointLocalCoordinates(aux_coords, r_master_geometry.Center());</span></a>
<a name="720"><span class="lineNum">     720 </span><span class="lineNoCov">          0 :             const array_1d&lt;double, 3&gt; master_normal = r_master_geometry.UnitNormal(aux_coords);</span></a>
<a name="721"><span class="lineNum">     721 </span>            : </a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :             const IntegrationMethod&amp; r_integration_method = GetIntegrationMethod();</span></a>
<a name="723"><span class="lineNum">     723 </span>            : </a>
<a name="724"><span class="lineNum">     724 </span>            :             // Reading integration points</a>
<a name="725"><span class="lineNum">     725 </span>            :             std::vector&lt;array_1d&lt;PointType,TDim&gt;&gt; geometrical_objects_points_slave; // These are the segmentation points, with this points it is possible to create the lines or triangles used on the mapping</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 :             const bool is_inside = rIntegrationUtility.GetExactIntegration(r_slave_geometry, slave_normal, r_master_geometry, master_normal, geometrical_objects_points_slave);</span></a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span><span class="lineNoCov">          0 :             if (is_inside) {</span></a>
<a name="729"><span class="lineNum">     729 </span>            :                 // Initialize general variables for the current master element</a>
<a name="730"><span class="lineNum">     730 </span><span class="lineNoCov">          0 :                 rThisKineticVariables.Initialize();</span></a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span>            :                 // Initialize the mortar operators</a>
<a name="733"><span class="lineNum">     733 </span>            :                 rThisMortarOperators.Initialize();</a>
<a name="734"><span class="lineNum">     734 </span>            : </a>
<a name="735"><span class="lineNum">     735 </span><span class="lineNoCov">          0 :                 const BoundedMatrixType Ae = CalculateAe(r_slave_geometry, rThisKineticVariables, geometrical_objects_points_slave, r_integration_method);</span></a>
<a name="736"><span class="lineNum">     736 </span>            : </a>
<a name="737"><span class="lineNum">     737 </span><span class="lineNoCov">          0 :                 AssemblyMortarOperators( geometrical_objects_points_slave, r_slave_geometry, r_master_geometry,master_normal, rThisKineticVariables, rThisMortarOperators, r_integration_method, Ae);</span></a>
<a name="738"><span class="lineNum">     738 </span>            : </a>
<a name="739"><span class="lineNum">     739 </span>            :                 /* We compute the residual */</a>
<a name="740"><span class="lineNum">     740 </span><span class="lineNoCov">          0 :                 const IndexType size_to_compute = MortarUtilities::SizeToCompute&lt;TDim, TVarType&gt;();</span></a>
<a name="741"><span class="lineNum">     741 </span>            :                 Matrix residual_matrix(TNumNodes, size_to_compute);</a>
<a name="742"><span class="lineNum">     742 </span><span class="lineNoCov">          0 :                 ComputeResidualMatrix(residual_matrix, r_slave_geometry, r_master_geometry, rThisMortarOperators);</span></a>
<a name="743"><span class="lineNum">     743 </span>            : </a>
<a name="744"><span class="lineNum">     744 </span>            :                 if (!TImplicit) {</a>
<a name="745"><span class="lineNum">     745 </span><span class="lineNoCov">          0 :                     MortarUtilities::AddValue&lt;TVarType, MortarUtilitiesSettings::SaveAsNonHistoricalVariable&gt;(r_slave_geometry, r_aux_variable, residual_matrix);</span></a>
<a name="746"><span class="lineNum">     746 </span>            :                 }</a>
<a name="747"><span class="lineNum">     747 </span>            : </a>
<a name="748"><span class="lineNum">     748 </span>            :                 // We check if DOperator is diagonal</a>
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :                 if (mEchoLevel &gt; 1) {</span></a>
<a name="750"><span class="lineNum">     750 </span>            :                     BoundedMatrixType aux_copy_D = rThisMortarOperators.DOperator;</a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :                     LumpMatrix(aux_copy_D);</span></a>
<a name="752"><span class="lineNum">     752 </span><span class="lineNoCov">          0 :                     const BoundedMatrixType aux_diff = aux_copy_D - rThisMortarOperators.DOperator;</span></a>
<a name="753"><span class="lineNum">     753 </span><span class="lineNoCov">          0 :                     const double norm_diff = norm_frobenius(aux_diff);</span></a>
<a name="754"><span class="lineNum">     754 </span><span class="lineNoCov">          0 :                     if (norm_diff &gt; 1.0e-4)</span></a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :                         KRATOS_WARNING(&quot;D OPERATOR&quot;) &lt;&lt; &quot; THE MORTAR OPERATOR D IS NOT DIAGONAL&quot; &lt;&lt; std::endl;</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :                     if (mEchoLevel == 3) {</span></a>
<a name="757"><span class="lineNum">     757 </span>            :                         KRATOS_WATCH(norm_diff);</a>
<a name="758"><span class="lineNum">     758 </span><span class="lineNoCov">          0 :                         KRATOS_WATCH(rThisMortarOperators.DOperator);</span></a>
<a name="759"><span class="lineNum">     759 </span>            :                     }</a>
<a name="760"><span class="lineNum">     760 </span>            :                 }</a>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<a name="762"><span class="lineNum">     762 </span><span class="lineNoCov">          0 :                 if (Iteration == 0) { // Just assembled the first iteration</span></a>
<a name="763"><span class="lineNum">     763 </span>            :                     if constexpr (TImplicit) {</a>
<a name="764"><span class="lineNum">     764 </span>            :                         /* We compute the residual and assemble */</a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :                         const SizeType variable_size = MortarUtilities::SizeToCompute&lt;TDim, TVarType&gt;();</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :                         AssembleRHSAndLHS(rA, rb, variable_size, residual_matrix, r_slave_geometry, rInverseConectivityDatabase, rThisMortarOperators);</span></a>
<a name="767"><span class="lineNum">     767 </span>            :                     } else {</a>
<a name="768"><span class="lineNum">     768 </span><span class="lineNoCov">          0 :                         for (IndexType i_node = 0; i_node &lt; TNumNodes; ++i_node) {</span></a>
<a name="769"><span class="lineNum">     769 </span>            :                             double&amp; r_nodal_area = r_slave_geometry[i_node].GetValue(NODAL_AREA);</a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :                             AtomicAdd(r_nodal_area, rThisMortarOperators.DOperator(i_node, i_node));</span></a>
<a name="771"><span class="lineNum">     771 </span>            :                         }</a>
<a name="772"><span class="lineNum">     772 </span>            :                         // In case of discontinous interface we add contribution to near nodes</a>
<a name="773"><span class="lineNum">     773 </span><span class="lineNoCov">          0 :                         if (mOptions.Is(DISCONTINOUS_INTERFACE)) {</span></a>
<a name="774"><span class="lineNum">     774 </span><span class="lineNoCov">          0 :                             const double element_length = r_slave_geometry.Length();</span></a>
<a name="775"><span class="lineNum">     775 </span>            : </a>
<a name="776"><span class="lineNum">     776 </span>            :                             // Iterating over nodes</a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :                             for (IndexType i_node = 0; i_node &lt; TNumNodes; ++i_node) {</span></a>
<a name="778"><span class="lineNum">     778 </span><span class="lineNoCov">          0 :                                 const double nodal_area_contribution = rThisMortarOperators.DOperator(i_node, i_node);</span></a>
<a name="779"><span class="lineNum">     779 </span>            : </a>
<a name="780"><span class="lineNum">     780 </span>            :                                 // The original node coordinates</a>
<a name="781"><span class="lineNum">     781 </span>            :                                 const auto&amp; r_slave_node = r_slave_geometry[i_node];</a>
<a name="782"><span class="lineNum">     782 </span>            : </a>
<a name="783"><span class="lineNum">     783 </span>            :                                 // Iterating over other paired geometrical objects</a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :                                 const auto&amp; r_index_masp_master = mOptions.Is(ORIGIN_SKIN_IS_CONDITION_BASED) ? r_const_origin_model_part.GetCondition(master_id).GetValue(INDEX_SET) : r_const_origin_model_part.GetElement(master_id).GetValue(INDEX_SET);</span></a>
<a name="785"><span class="lineNum">     785 </span><span class="lineNoCov">          0 :                                 for (auto it_master_pair = r_index_masp_master-&gt;begin(); it_master_pair != r_index_masp_master-&gt;end(); ++it_master_pair ) {</span></a>
<a name="786"><span class="lineNum">     786 </span>            : </a>
<a name="787"><span class="lineNum">     787 </span>            :                                     const IndexType auxiliar_slave_id = r_index_masp_master-&gt;GetId(it_master_pair);</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :                                     if (rGeometricalObject.Id() != auxiliar_slave_id) {</span></a>
<a name="789"><span class="lineNum">     789 </span><span class="lineNoCov">          0 :                                         GeometryType&amp; r_auxiliar_slave_geometry =  const_cast&lt;GeometryType&amp;&gt;(mOptions.Is(DESTINATION_SKIN_IS_CONDITION_BASED) ? r_const_destination_model_part.GetCondition(auxiliar_slave_id).GetGeometry() : r_const_destination_model_part.GetElement(auxiliar_slave_id).GetGeometry());</span></a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span><span class="lineNoCov">          0 :                                         for (IndexType j_node = 0; j_node &lt; TNumNodes; ++j_node) {</span></a>
<a name="792"><span class="lineNum">     792 </span>            :                                             // The auxiliary node distance</a>
<a name="793"><span class="lineNum">     793 </span>            :                                             auto&amp; r_auxiliary_slave_node = r_auxiliar_slave_geometry[j_node];</a>
<a name="794"><span class="lineNum">     794 </span>            :                                             const double distance = r_auxiliary_slave_node.Distance(r_slave_node);</a>
<a name="795"><span class="lineNum">     795 </span><span class="lineNoCov">          0 :                                             const double contribution_coeff = 1.0/std::pow((1.0 + distance/(discontinous_interface_factor * element_length)), 2);</span></a>
<a name="796"><span class="lineNum">     796 </span>            : </a>
<a name="797"><span class="lineNum">     797 </span>            :                                             double&amp; r_nodal_area = r_auxiliary_slave_node.GetValue(NODAL_AREA);</a>
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :                                             AtomicAdd(r_nodal_area, contribution_coeff * nodal_area_contribution);</span></a>
<a name="799"><span class="lineNum">     799 </span>            :                                         }</a>
<a name="800"><span class="lineNum">     800 </span>            :                                     }</a>
<a name="801"><span class="lineNum">     801 </span>            :                                 }</a>
<a name="802"><span class="lineNum">     802 </span>            :                             }</a>
<a name="803"><span class="lineNum">     803 </span>            :                         }</a>
<a name="804"><span class="lineNum">     804 </span>            :                     }</a>
<a name="805"><span class="lineNum">     805 </span>            :                 } else if constexpr (TImplicit) {</a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :                     const SizeType variable_size = MortarUtilities::SizeToCompute&lt;TDim, TVarType&gt;();</span></a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 :                     AssembleRHS(rb, variable_size, residual_matrix, r_slave_geometry, rInverseConectivityDatabase);</span></a>
<a name="808"><span class="lineNum">     808 </span>            :                 }</a>
<a name="809"><span class="lineNum">     809 </span>            :             } else { // NOTE: The geometrical object considered maybe is to tight</a>
<a name="810"><span class="lineNum">     810 </span><span class="lineNoCov">          0 :                 indexes_to_remove.push_back(master_id);</span></a>
<a name="811"><span class="lineNum">     811 </span><span class="lineNoCov">          0 :                 const IndexType other_id = pIndexesPairs-&gt;GetOtherId(it_pair);</span></a>
<a name="812"><span class="lineNum">     812 </span><span class="lineNoCov">          0 :                 if (std::is_same&lt;TClassType, IndexMap&gt;::value &amp;&amp; other_id != 0) {</span></a>
<a name="813"><span class="lineNum">     813 </span><span class="lineNoCov">          0 :                     geometrical_objects_to_erase.push_back(other_id);</span></a>
<a name="814"><span class="lineNum">     814 </span>            :                 }</a>
<a name="815"><span class="lineNum">     815 </span>            :             }</a>
<a name="816"><span class="lineNum">     816 </span>            :         }</a>
<a name="817"><span class="lineNum">     817 </span>            : </a>
<a name="818"><span class="lineNum">     818 </span>            :         // Clear indexes</a>
<a name="819"><span class="lineNum">     819 </span><span class="lineNoCov">          0 :         for (IndexType i_to_remove = 0; i_to_remove &lt; indexes_to_remove.size(); ++i_to_remove) {</span></a>
<a name="820"><span class="lineNum">     820 </span><span class="lineNoCov">          0 :             if (mOptions.Is(ORIGIN_SKIN_IS_CONDITION_BASED)) {</span></a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :                 for (auto&amp; id : geometrical_objects_to_erase ) {</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineNoCov">          0 :                     auto&amp; r_cond = r_root_model_part.GetCondition(id);</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :                     r_cond.Set(TO_ERASE, true);</span></a>
<a name="824"><span class="lineNum">     824 </span>            :                 }</a>
<a name="825"><span class="lineNum">     825 </span>            :             } else {</a>
<a name="826"><span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 for (auto&amp; id : geometrical_objects_to_erase ) {</span></a>
<a name="827"><span class="lineNum">     827 </span><span class="lineNoCov">          0 :                     auto&amp; r_elem = r_root_model_part.GetElement(id);</span></a>
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 :                     r_elem.Set(TO_ERASE, true);</span></a>
<a name="829"><span class="lineNum">     829 </span>            :                 }</a>
<a name="830"><span class="lineNum">     830 </span>            :             }</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 :             pIndexesPairs-&gt;RemoveId(indexes_to_remove[i_to_remove]);</span></a>
<a name="832"><span class="lineNum">     832 </span>            :         }</a>
<a name="833"><span class="lineNum">     833 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="834"><span class="lineNum">     834 </span>            : </a>
<a name="835"><span class="lineNum">     835 </span>            :     /**</a>
<a name="836"><span class="lineNum">     836 </span>            :      * @brief This method can be used to clear the unused indexes</a>
<a name="837"><span class="lineNum">     837 </span>            :      * @param pIndexesPairs The pointer to indexed objects</a>
<a name="838"><span class="lineNum">     838 </span>            :      * @param rGeometricalObject Reference of a geometrical object</a>
<a name="839"><span class="lineNum">     839 </span>            :      * @param rIntegrationUtility An integration utility for mortar</a>
<a name="840"><span class="lineNum">     840 </span>            :      * @tparam TClassType The class of index pairs considered</a>
<a name="841"><span class="lineNum">     841 </span>            :      */</a>
<a name="842"><span class="lineNum">     842 </span>            :     template&lt;class TClassType&gt;</a>
<a name="843"><span class="lineNum">     843 </span><span class="lineNoCov">          0 :     void ClearIndexes(</span></a>
<a name="844"><span class="lineNum">     844 </span>            :         typename TClassType::Pointer pIndexesPairs,</a>
<a name="845"><span class="lineNum">     845 </span>            :         GeometricalObject&amp; rGeometricalObject,</a>
<a name="846"><span class="lineNum">     846 </span>            :         ExactMortarIntegrationUtilityType&amp; rIntegrationUtility</a>
<a name="847"><span class="lineNum">     847 </span>            :         )</a>
<a name="848"><span class="lineNum">     848 </span>            :     {</a>
<a name="849"><span class="lineNum">     849 </span>            :         // The root model part</a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :         ModelPart&amp; r_root_model_part = mOriginModelPart.GetRootModelPart();</span></a>
<a name="851"><span class="lineNum">     851 </span>            : </a>
<a name="852"><span class="lineNum">     852 </span>            :         // Indexes of the pair to be removed</a>
<a name="853"><span class="lineNum">     853 </span>            :         std::vector&lt;IndexType&gt; indexes_to_remove, geometrical_objects_to_erase;</a>
<a name="854"><span class="lineNum">     854 </span>            : </a>
<a name="855"><span class="lineNum">     855 </span>            :         // Declare auxiliar coordinates</a>
<a name="856"><span class="lineNum">     856 </span>            :         GeometryType::CoordinatesArrayType aux_coords;</a>
<a name="857"><span class="lineNum">     857 </span>            : </a>
<a name="858"><span class="lineNum">     858 </span>            :         // Geometrical values</a>
<a name="859"><span class="lineNum">     859 </span>            :         auto&amp; r_slave_geometry = rGeometricalObject.GetGeometry();</a>
<a name="860"><span class="lineNum">     860 </span><span class="lineNoCov">          0 :         r_slave_geometry.PointLocalCoordinates(aux_coords, r_slave_geometry.Center());</span></a>
<a name="861"><span class="lineNum">     861 </span><span class="lineNoCov">          0 :         const array_1d&lt;double, 3&gt; slave_normal = r_slave_geometry.UnitNormal(aux_coords);</span></a>
<a name="862"><span class="lineNum">     862 </span>            : </a>
<a name="863"><span class="lineNum">     863 </span>            :         // The model part as const to avoid race conditions</a>
<a name="864"><span class="lineNum">     864 </span><span class="lineNoCov">          0 :         const auto&amp; r_const_origin_model_part = mOriginModelPart;</span></a>
<a name="865"><span class="lineNum">     865 </span>            : </a>
<a name="866"><span class="lineNum">     866 </span><span class="lineNoCov">          0 :         for (auto it_pair = pIndexesPairs-&gt;begin(); it_pair != pIndexesPairs-&gt;end(); ++it_pair ) {</span></a>
<a name="867"><span class="lineNum">     867 </span><span class="lineNoCov">          0 :             const IndexType master_id = pIndexesPairs-&gt;GetId(it_pair); // MASTER</span></a>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :             const auto&amp; r_master_geometry = mOptions.Is(ORIGIN_SKIN_IS_CONDITION_BASED) ? r_const_origin_model_part.GetCondition(master_id).GetGeometry() : r_const_origin_model_part.GetElement(master_id).GetGeometry();</span></a>
<a name="870"><span class="lineNum">     870 </span><span class="lineNoCov">          0 :             r_master_geometry.PointLocalCoordinates(aux_coords, r_master_geometry.Center());</span></a>
<a name="871"><span class="lineNum">     871 </span><span class="lineNoCov">          0 :             const array_1d&lt;double, 3&gt; master_normal = r_master_geometry.UnitNormal(aux_coords);</span></a>
<a name="872"><span class="lineNum">     872 </span>            : </a>
<a name="873"><span class="lineNum">     873 </span>            :             // Reading integration points</a>
<a name="874"><span class="lineNum">     874 </span>            :             std::vector&lt;array_1d&lt;PointType,TDim&gt;&gt; geometrical_objects_points_slave; // These are the segmentation points, with this points it is possible to create the lines or triangles used on the mapping</a>
<a name="875"><span class="lineNum">     875 </span><span class="lineNoCov">          0 :             const bool is_inside = rIntegrationUtility.GetExactIntegration(r_slave_geometry, slave_normal, r_master_geometry, master_normal, geometrical_objects_points_slave);</span></a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span><span class="lineNoCov">          0 :             if (!is_inside) {</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineNoCov">          0 :                 indexes_to_remove.push_back(master_id);</span></a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 :                 const IndexType other_id = pIndexesPairs-&gt;GetOtherId(it_pair);</span></a>
<a name="880"><span class="lineNum">     880 </span><span class="lineNoCov">          0 :                 if (std::is_same&lt;TClassType, IndexMap&gt;::value &amp;&amp; other_id != 0) {</span></a>
<a name="881"><span class="lineNum">     881 </span><span class="lineNoCov">          0 :                     geometrical_objects_to_erase.push_back(other_id);</span></a>
<a name="882"><span class="lineNum">     882 </span>            :                 }</a>
<a name="883"><span class="lineNum">     883 </span>            :             }</a>
<a name="884"><span class="lineNum">     884 </span>            :         }</a>
<a name="885"><span class="lineNum">     885 </span>            : </a>
<a name="886"><span class="lineNum">     886 </span>            :         // Clear indexes</a>
<a name="887"><span class="lineNum">     887 </span><span class="lineNoCov">          0 :         for (IndexType i_to_remove = 0; i_to_remove &lt; indexes_to_remove.size(); ++i_to_remove) {</span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineNoCov">          0 :             if (mOptions.Is(ORIGIN_SKIN_IS_CONDITION_BASED)) {</span></a>
<a name="889"><span class="lineNum">     889 </span><span class="lineNoCov">          0 :                 for (auto&amp; id : geometrical_objects_to_erase ) {</span></a>
<a name="890"><span class="lineNum">     890 </span><span class="lineNoCov">          0 :                     auto&amp; r_cond = r_root_model_part.GetCondition(id);</span></a>
<a name="891"><span class="lineNum">     891 </span><span class="lineNoCov">          0 :                     r_cond.Set(TO_ERASE, true);</span></a>
<a name="892"><span class="lineNum">     892 </span>            :                 }</a>
<a name="893"><span class="lineNum">     893 </span>            :             } else {</a>
<a name="894"><span class="lineNum">     894 </span><span class="lineNoCov">          0 :                 for (auto&amp; id : geometrical_objects_to_erase ) {</span></a>
<a name="895"><span class="lineNum">     895 </span><span class="lineNoCov">          0 :                     auto&amp; r_elem = r_root_model_part.GetElement(id);</span></a>
<a name="896"><span class="lineNum">     896 </span><span class="lineNoCov">          0 :                     r_elem.Set(TO_ERASE, true);</span></a>
<a name="897"><span class="lineNum">     897 </span>            :                 }</a>
<a name="898"><span class="lineNum">     898 </span>            :             }</a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :             pIndexesPairs-&gt;RemoveId(indexes_to_remove[i_to_remove]);</span></a>
<a name="900"><span class="lineNum">     900 </span>            :         }</a>
<a name="901"><span class="lineNum">     901 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="902"><span class="lineNum">     902 </span>            : </a>
<a name="903"><span class="lineNum">     903 </span>            :     /**</a>
<a name="904"><span class="lineNum">     904 </span>            :      * @brief This method fills the database</a>
<a name="905"><span class="lineNum">     905 </span>            :      * @param rGeometricalObject Reference of a geometrical object</a>
<a name="906"><span class="lineNum">     906 </span>            :      * @param rTreePoints The search tree</a>
<a name="907"><span class="lineNum">     907 </span>            :      * @param AllocationSize The allocation size of the tree</a>
<a name="908"><span class="lineNum">     908 </span>            :      * @param SearchFactor The search factor of the tree</a>
<a name="909"><span class="lineNum">     909 </span>            :      */</a>
<a name="910"><span class="lineNum">     910 </span>            :     template&lt;class TEntity&gt;</a>
<a name="911"><span class="lineNum">     911 </span><span class="lineNoCov">          0 :     void FillDatabase(</span></a>
<a name="912"><span class="lineNum">     912 </span>            :         TEntity&amp; rGeometricalObject,</a>
<a name="913"><span class="lineNum">     913 </span>            :         KDTreeType&amp; rTreePoints,</a>
<a name="914"><span class="lineNum">     914 </span>            :         const SizeType AllocationSize,</a>
<a name="915"><span class="lineNum">     915 </span>            :         const double SearchFactor</a>
<a name="916"><span class="lineNum">     916 </span>            :         )</a>
<a name="917"><span class="lineNum">     917 </span>            :     {</a>
<a name="918"><span class="lineNum">     918 </span>            :         // Initialize values</a>
<a name="919"><span class="lineNum">     919 </span><span class="lineNoCov">          0 :         PointVector points_found(AllocationSize);</span></a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span>            :         GeometryType&amp; r_geometry = rGeometricalObject.GetGeometry();</a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 :         const Point center = r_geometry.Center();</span></a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            :         double radius = 0.0;</a>
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 :         for(IndexType i_node = 0; i_node &lt; r_geometry.PointsNumber(); ++i_node)  {</span></a>
<a name="926"><span class="lineNum">     926 </span>            :             const array_1d&lt;double, 3&gt; aux_vector = center.Coordinates() - r_geometry[i_node].Coordinates();</a>
<a name="927"><span class="lineNum">     927 </span>            :             const double aux_value = inner_prod(aux_vector, aux_vector);</a>
<a name="928"><span class="lineNum">     928 </span><span class="lineNoCov">          0 :             if(aux_value &gt; radius) radius = aux_value;</span></a>
<a name="929"><span class="lineNum">     929 </span>            :         }</a>
<a name="930"><span class="lineNum">     930 </span>            : </a>
<a name="931"><span class="lineNum">     931 </span><span class="lineNoCov">          0 :         const double search_radius = SearchFactor * std::sqrt(radius);</span></a>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<a name="933"><span class="lineNum">     933 </span><span class="lineNoCov">          0 :         const SizeType number_points_found = rTreePoints.SearchInRadius(center, search_radius, points_found.begin(), AllocationSize);</span></a>
<a name="934"><span class="lineNum">     934 </span>            : </a>
<a name="935"><span class="lineNum">     935 </span><span class="lineNoCov">          0 :         if (number_points_found &gt; 0) {</span></a>
<a name="936"><span class="lineNum">     936 </span>            :             // In case of missing is created</a>
<a name="937"><span class="lineNum">     937 </span><span class="lineNoCov">          0 :             if (!rGeometricalObject.Has(INDEX_SET))</span></a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 :                 rGeometricalObject.SetValue(INDEX_SET, Kratos::make_shared&lt;IndexSet&gt;());</span></a>
<a name="939"><span class="lineNum">     939 </span>            : </a>
<a name="940"><span class="lineNum">     940 </span>            :             // Accessing to the index set</a>
<a name="941"><span class="lineNum">     941 </span><span class="lineNoCov">          0 :             IndexSet::Pointer indexes_set = rGeometricalObject.GetValue(INDEX_SET);</span></a>
<a name="942"><span class="lineNum">     942 </span>            : </a>
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 :             for (IndexType i_point = 0; i_point &lt; number_points_found; ++i_point ) {</span></a>
<a name="944"><span class="lineNum">     944 </span>            :                 auto p_geometrical_object_master = points_found[i_point]-&gt;GetGeometricalObject();</a>
<a name="945"><span class="lineNum">     945 </span><span class="lineNoCov">          0 :                 indexes_set-&gt;AddId(p_geometrical_object_master-&gt;Id());</span></a>
<a name="946"><span class="lineNum">     946 </span>            :             }</a>
<a name="947"><span class="lineNum">     947 </span>            :         }</a>
<a name="948"><span class="lineNum">     948 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="949"><span class="lineNum">     949 </span>            : </a>
<a name="950"><span class="lineNum">     950 </span>            :     /**</a>
<a name="951"><span class="lineNum">     951 </span>            :      * @brief This method creates an inverse database</a>
<a name="952"><span class="lineNum">     952 </span>            :      */</a>
<a name="953"><span class="lineNum">     953 </span>            :     void CreateInverseDatabase();</a>
<a name="954"><span class="lineNum">     954 </span>            : </a>
<a name="955"><span class="lineNum">     955 </span>            :     /**</a>
<a name="956"><span class="lineNum">     956 </span>            :      * @brief Reset the interface database</a>
<a name="957"><span class="lineNum">     957 </span>            :      * @details This method resets the mapping database saved in the destination database.</a>
<a name="958"><span class="lineNum">     958 </span>            :      * @note Note that this needs to be done if such modelpart has changed its number of nodes or geometrical objects. This needs to be done even though the mapping instance is deleted since such information is saved in the destination nodes and geometrical objects.</a>
<a name="959"><span class="lineNum">     959 </span>            :      */</a>
<a name="960"><span class="lineNum">     960 </span>            :     void UpdateInterface();</a>
<a name="961"><span class="lineNum">     961 </span>            : </a>
<a name="962"><span class="lineNum">     962 </span>            :     ///@}</a>
<a name="963"><span class="lineNum">     963 </span>            :     ///@name Private  Access</a>
<a name="964"><span class="lineNum">     964 </span>            :     ///@{</a>
<a name="965"><span class="lineNum">     965 </span>            :     ///@}</a>
<a name="966"><span class="lineNum">     966 </span>            : </a>
<a name="967"><span class="lineNum">     967 </span>            :     ///@}</a>
<a name="968"><span class="lineNum">     968 </span>            :     ///@name Serialization</a>
<a name="969"><span class="lineNum">     969 </span>            :     ///@{</a>
<a name="970"><span class="lineNum">     970 </span>            : </a>
<a name="971"><span class="lineNum">     971 </span>            :     ///@name Private Inquiry</a>
<a name="972"><span class="lineNum">     972 </span>            :     ///@{</a>
<a name="973"><span class="lineNum">     973 </span>            :     ///@}</a>
<a name="974"><span class="lineNum">     974 </span>            : </a>
<a name="975"><span class="lineNum">     975 </span>            :     ///@name Unaccessible methods</a>
<a name="976"><span class="lineNum">     976 </span>            :     ///@{</a>
<a name="977"><span class="lineNum">     977 </span>            : </a>
<a name="978"><span class="lineNum">     978 </span>            :     /// Assignment operator.</a>
<a name="979"><span class="lineNum">     979 </span>            :     SimpleMortarMapperProcess&amp; operator=(SimpleMortarMapperProcess const&amp; rOther) = delete;</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            :     /// Copy constructor.</a>
<a name="982"><span class="lineNum">     982 </span>            :     //SimpleMortarMapperProcess(SimpleMortarMapperProcess const&amp; rOther);</a>
<a name="983"><span class="lineNum">     983 </span>            : </a>
<a name="984"><span class="lineNum">     984 </span>            :     ///@}</a>
<a name="985"><span class="lineNum">     985 </span>            : };// class SimpleMortarMapperProcess</a>
<a name="986"><span class="lineNum">     986 </span>            : </a>
<a name="987"><span class="lineNum">     987 </span>            : ///@}</a>
<a name="988"><span class="lineNum">     988 </span>            : ///@name Type Definitions</a>
<a name="989"><span class="lineNum">     989 </span>            : ///@{</a>
<a name="990"><span class="lineNum">     990 </span>            : </a>
<a name="991"><span class="lineNum">     991 </span>            : </a>
<a name="992"><span class="lineNum">     992 </span>            : ///@}</a>
<a name="993"><span class="lineNum">     993 </span>            : ///@name Input and output</a>
<a name="994"><span class="lineNum">     994 </span>            : ///@{</a>
<a name="995"><span class="lineNum">     995 </span>            : </a>
<a name="996"><span class="lineNum">     996 </span>            : ///@}</a>
<a name="997"><span class="lineNum">     997 </span>            : </a>
<a name="998"><span class="lineNum">     998 </span>            : }  // namespace Kratos.</a>
<a name="999"><span class="lineNum">     999 </span>            : #endif /* KRATOS_SIMPLE_MORTAR_MAPPER_PROCESS defined */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
