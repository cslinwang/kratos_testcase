<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - kratos/utilities/normal_calculation_utils.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">kratos/utilities</a> - normal_calculation_utils.h<span style="font-size: 80%;"> (source / <a href="normal_calculation_utils.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">58</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-10 06:41:28</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //    |  /           |</a>
<a name="2"><span class="lineNum">       2 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="3"><span class="lineNum">       3 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="4"><span class="lineNum">       4 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="5"><span class="lineNum">       5 </span>            : //                   Multi-Physics</a>
<a name="6"><span class="lineNum">       6 </span>            : //</a>
<a name="7"><span class="lineNum">       7 </span>            : //  License:             BSD License</a>
<a name="8"><span class="lineNum">       8 </span>            : //                                       Kratos default license: kratos/license.txt</a>
<a name="9"><span class="lineNum">       9 </span>            : //</a>
<a name="10"><span class="lineNum">      10 </span>            : //  Main authors:    Pooyan Dadvand</a>
<a name="11"><span class="lineNum">      11 </span>            : //                   Riccardo Rossi</a>
<a name="12"><span class="lineNum">      12 </span>            : //                   Vicente Mataix Ferrandiz</a>
<a name="13"><span class="lineNum">      13 </span>            : //                   Ruben Zorrilla</a>
<a name="14"><span class="lineNum">      14 </span>            : //</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            : #if !defined(KRATOS_NORMAL_CALCULATION_UTILS )</a>
<a name="17"><span class="lineNum">      17 </span>            : #define  KRATOS_NORMAL_CALCULATION_UTILS</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            : // System includes</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : // External includes</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span>            : // Project includes</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &quot;utilities/math_utils.h&quot;</a>
<a name="26"><span class="lineNum">      26 </span>            : #include &quot;utilities/variable_utils.h&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : #include &quot;includes/deprecated_variables.h&quot;</a>
<a name="28"><span class="lineNum">      28 </span>            : </a>
<a name="29"><span class="lineNum">      29 </span>            : namespace Kratos</a>
<a name="30"><span class="lineNum">      30 </span>            : {</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : ///@name Kratos Globals</a>
<a name="33"><span class="lineNum">      33 </span>            : ///@{</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : ///@}</a>
<a name="36"><span class="lineNum">      36 </span>            : ///@name Type Definitions</a>
<a name="37"><span class="lineNum">      37 </span>            : ///@{</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span>            : ///@}</a>
<a name="40"><span class="lineNum">      40 </span>            : ///@name  Enum's</a>
<a name="41"><span class="lineNum">      41 </span>            : ///@{</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            : ///@}</a>
<a name="44"><span class="lineNum">      44 </span>            : ///@name  Functions</a>
<a name="45"><span class="lineNum">      45 </span>            : ///@{</a>
<a name="46"><span class="lineNum">      46 </span>            : </a>
<a name="47"><span class="lineNum">      47 </span>            : ///@}</a>
<a name="48"><span class="lineNum">      48 </span>            : ///@name Kratos Classes</a>
<a name="49"><span class="lineNum">      49 </span>            : ///@{</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            : /**</a>
<a name="52"><span class="lineNum">      52 </span>            :  * @namespace NormalCalculationUtils</a>
<a name="53"><span class="lineNum">      53 </span>            :  * @ingroup KratosCore</a>
<a name="54"><span class="lineNum">      54 </span>            :  * @brief Tool to evaluate the normals on nodes based on the normals of a set of surface conditions</a>
<a name="55"><span class="lineNum">      55 </span>            :  * @author Pooyan Dadvand</a>
<a name="56"><span class="lineNum">      56 </span>            :  * @author Riccardo Rossi</a>
<a name="57"><span class="lineNum">      57 </span>            :  * @author Vicente Mataix Ferrandiz</a>
<a name="58"><span class="lineNum">      58 </span>            :  */</a>
<a name="59"><span class="lineNum">      59 </span>            : class KRATOS_API(KRATOS_CORE) NormalCalculationUtils</a>
<a name="60"><span class="lineNum">      60 </span>            : {</a>
<a name="61"><span class="lineNum">      61 </span>            : public:</a>
<a name="62"><span class="lineNum">      62 </span>            :     ///@name Type Definitions</a>
<a name="63"><span class="lineNum">      63 </span>            :     ///@{</a>
<a name="64"><span class="lineNum">      64 </span>            : </a>
<a name="65"><span class="lineNum">      65 </span>            :     /// The index type definition</a>
<a name="66"><span class="lineNum">      66 </span>            :     typedef std::size_t IndexType;</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            :     /// The size type definition</a>
<a name="69"><span class="lineNum">      69 </span>            :     typedef std::size_t SizeType;</a>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<a name="71"><span class="lineNum">      71 </span>            :     // Node definitions</a>
<a name="72"><span class="lineNum">      72 </span>            :     typedef Node&lt;3&gt; NodeType;</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            :     /// Definition of geometries</a>
<a name="75"><span class="lineNum">      75 </span>            :     typedef Geometry&lt;NodeType&gt; GeometryType;</a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            :     /// Condition type definition</a>
<a name="78"><span class="lineNum">      78 </span>            :     typedef ModelPart::ConditionType ConditionType;</a>
<a name="79"><span class="lineNum">      79 </span>            : </a>
<a name="80"><span class="lineNum">      80 </span>            :     /// Conditions array definition</a>
<a name="81"><span class="lineNum">      81 </span>            :     typedef ModelPart::ConditionsContainerType ConditionsArrayType;</a>
<a name="82"><span class="lineNum">      82 </span>            : </a>
<a name="83"><span class="lineNum">      83 </span>            :     /// Normal variable definition</a>
<a name="84"><span class="lineNum">      84 </span>            :     using NormalVariableType = Variable&lt;array_1d&lt;double,3&gt;&gt;;</a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :     ///@}</a>
<a name="87"><span class="lineNum">      87 </span>            :     ///@name Life Cycle</a>
<a name="88"><span class="lineNum">      88 </span>            :     ///@{</a>
<a name="89"><span class="lineNum">      89 </span>            : </a>
<a name="90"><span class="lineNum">      90 </span>            :     ///@}</a>
<a name="91"><span class="lineNum">      91 </span>            :     ///@name Operators</a>
<a name="92"><span class="lineNum">      92 </span>            :     ///@{</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :     ///@}</a>
<a name="95"><span class="lineNum">      95 </span>            :     ///@name Operations</a>
<a name="96"><span class="lineNum">      96 </span>            :     ///@{</a>
<a name="97"><span class="lineNum">      97 </span>            : </a>
<a name="98"><span class="lineNum">      98 </span>            :     /**</a>
<a name="99"><span class="lineNum">      99 </span>            :      * @brief It computes the normal in the conditions</a>
<a name="100"><span class="lineNum">     100 </span>            :      * @param rModelPart The model part to compute</a>
<a name="101"><span class="lineNum">     101 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="102"><span class="lineNum">     102 </span>            :      */</a>
<a name="103"><span class="lineNum">     103 </span>            :     template&lt;class TContainerType&gt;</a>
<a name="104"><span class="lineNum">     104 </span>            :     void CalculateNormalsInContainer(</a>
<a name="105"><span class="lineNum">     105 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="106"><span class="lineNum">     106 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="107"><span class="lineNum">     107 </span>            :         );</a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span>            :     /**</a>
<a name="110"><span class="lineNum">     110 </span>            :      * @brief It computes the mean of the normal in the entities and in all the nodes</a>
<a name="111"><span class="lineNum">     111 </span>            :      * @param rModelPart The model part to compute</a>
<a name="112"><span class="lineNum">     112 </span>            :      * @param EnforceGenericGeometryAlgorithm If enforce the generic algorithm for any kind of geometry</a>
<a name="113"><span class="lineNum">     113 </span>            :      * @param ConsiderUnitNormal In order to consider directly the unit normal instead of the area normal multiplied with a coefficient</a>
<a name="114"><span class="lineNum">     114 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="115"><span class="lineNum">     115 </span>            :      * @tparam TEntity The entity type considered</a>
<a name="116"><span class="lineNum">     116 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="117"><span class="lineNum">     117 </span>            :      */</a>
<a name="118"><span class="lineNum">     118 </span>            :     template&lt;class TContainerType, bool TIsHistorical = true&gt;</a>
<a name="119"><span class="lineNum">     119 </span>            :     void CalculateNormals(</a>
<a name="120"><span class="lineNum">     120 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="121"><span class="lineNum">     121 </span>            :         const bool EnforceGenericGeometryAlgorithm = false,</a>
<a name="122"><span class="lineNum">     122 </span>            :         const bool ConsiderUnitNormal = false,</a>
<a name="123"><span class="lineNum">     123 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="124"><span class="lineNum">     124 </span>            :         );</a>
<a name="125"><span class="lineNum">     125 </span>            : </a>
<a name="126"><span class="lineNum">     126 </span>            :     /**</a>
<a name="127"><span class="lineNum">     127 </span>            :      * @brief It computes the mean of the normal in the entities and in all the nodes (unit normal version)</a>
<a name="128"><span class="lineNum">     128 </span>            :      * @param rModelPart The model part to compute</a>
<a name="129"><span class="lineNum">     129 </span>            :      * @param EnforceGenericGeometryAlgorithm If enforce the generic algorithm for any kind of geometry</a>
<a name="130"><span class="lineNum">     130 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="131"><span class="lineNum">     131 </span>            :      * @tparam TEntity The entity type considered</a>
<a name="132"><span class="lineNum">     132 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="133"><span class="lineNum">     133 </span>            :      */</a>
<a name="134"><span class="lineNum">     134 </span>            :     template&lt;class TContainerType, bool TIsHistorical = true&gt;</a>
<a name="135"><span class="lineNum">     135 </span>            :     void CalculateUnitNormals(</a>
<a name="136"><span class="lineNum">     136 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="137"><span class="lineNum">     137 </span>            :         const bool EnforceGenericGeometryAlgorithm = false,</a>
<a name="138"><span class="lineNum">     138 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="139"><span class="lineNum">     139 </span>            :         );</a>
<a name="140"><span class="lineNum">     140 </span>            : </a>
<a name="141"><span class="lineNum">     141 </span>            :     /**</a>
<a name="142"><span class="lineNum">     142 </span>            :      * @brief Calculates the &quot;area normal&quot; (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="143"><span class="lineNum">     143 </span>            :      * @details This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest.</a>
<a name="144"><span class="lineNum">     144 </span>            :      * @param rConditions A set of conditions defining the &quot;skin&quot; of a model</a>
<a name="145"><span class="lineNum">     145 </span>            :      * @param Dimension Spatial dimension (2 or 3)</a>
<a name="146"><span class="lineNum">     146 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="147"><span class="lineNum">     147 </span>            :      * @note This function is not recommended for distributed (MPI) runs, as the user has to ensure that the calculated normals are assembled between processes. The overload of this function that takes a ModelPart is preferable in ths case, as it performs the required communication.</a>
<a name="148"><span class="lineNum">     148 </span>            :      */</a>
<a name="149"><span class="lineNum">     149 </span>            :     void CalculateOnSimplex(</a>
<a name="150"><span class="lineNum">     150 </span>            :         ConditionsArrayType&amp; rConditions,</a>
<a name="151"><span class="lineNum">     151 </span>            :         const std::size_t Dimension,</a>
<a name="152"><span class="lineNum">     152 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="153"><span class="lineNum">     153 </span>            :         );</a>
<a name="154"><span class="lineNum">     154 </span>            : </a>
<a name="155"><span class="lineNum">     155 </span>            :     /**</a>
<a name="156"><span class="lineNum">     156 </span>            :      * @brief Calculates the &quot;area normal&quot; in the non-historical database (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="157"><span class="lineNum">     157 </span>            :      * @details This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest.</a>
<a name="158"><span class="lineNum">     158 </span>            :      * @param rConditions A set of conditions defining the &quot;skin&quot; of a model</a>
<a name="159"><span class="lineNum">     159 </span>            :      * @param Dimension Spatial dimension (2 or 3)</a>
<a name="160"><span class="lineNum">     160 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="161"><span class="lineNum">     161 </span>            :      * @note This function is not recommended for distributed (MPI) runs, as the user has to ensure that the calculated normals are assembled between processes. The overload of this function that takes a ModelPart is preferable in ths case, as it performs the required communication.</a>
<a name="162"><span class="lineNum">     162 </span>            :      */</a>
<a name="163"><span class="lineNum">     163 </span>            :     void CalculateOnSimplexNonHistorical(</a>
<a name="164"><span class="lineNum">     164 </span>            :         ConditionsArrayType&amp; rConditions,</a>
<a name="165"><span class="lineNum">     165 </span>            :         const std::size_t Dimension,</a>
<a name="166"><span class="lineNum">     166 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="167"><span class="lineNum">     167 </span>            :         );</a>
<a name="168"><span class="lineNum">     168 </span>            : </a>
<a name="169"><span class="lineNum">     169 </span>            :     /**</a>
<a name="170"><span class="lineNum">     170 </span>            :      * @brief Calculates nodal area normal shape sensitivities w.r.t. nodal coordinates of the condition.</a>
<a name="171"><span class="lineNum">     171 </span>            :      *</a>
<a name="172"><span class="lineNum">     172 </span>            :      * @param rConditions   List of conditions where shape sensitivities need to be calculated.</a>
<a name="173"><span class="lineNum">     173 </span>            :      * @param Dimension     Dimensionality of the conditions</a>
<a name="174"><span class="lineNum">     174 </span>            :      */</a>
<a name="175"><span class="lineNum">     175 </span>            :     void CalculateNormalShapeDerivativesOnSimplex(</a>
<a name="176"><span class="lineNum">     176 </span>            :         ConditionsArrayType&amp; rConditions,</a>
<a name="177"><span class="lineNum">     177 </span>            :         const std::size_t Dimension</a>
<a name="178"><span class="lineNum">     178 </span>            :     );</a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            :     /**</a>
<a name="181"><span class="lineNum">     181 </span>            :      * @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="182"><span class="lineNum">     182 </span>            :      * @details This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest.</a>
<a name="183"><span class="lineNum">     183 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain</a>
<a name="184"><span class="lineNum">     184 </span>            :      * @param Dimension Spatial dimension (2 or 3)</a>
<a name="185"><span class="lineNum">     185 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="186"><span class="lineNum">     186 </span>            :      * @note Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions.</a>
<a name="187"><span class="lineNum">     187 </span>            :      */</a>
<a name="188"><span class="lineNum">     188 </span>            :     void CalculateOnSimplex(</a>
<a name="189"><span class="lineNum">     189 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="190"><span class="lineNum">     190 </span>            :         const std::size_t Dimension,</a>
<a name="191"><span class="lineNum">     191 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="192"><span class="lineNum">     192 </span>            :         );</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span>            :     /**</a>
<a name="195"><span class="lineNum">     195 </span>            :      * @brief Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="196"><span class="lineNum">     196 </span>            :      * @details This is done on the base of the Conditions provided which should be understood as the surface elements of the area of interest.</a>
<a name="197"><span class="lineNum">     197 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain</a>
<a name="198"><span class="lineNum">     198 </span>            :      * @param Dimension Spatial dimension (2 or 3)</a>
<a name="199"><span class="lineNum">     199 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="200"><span class="lineNum">     200 </span>            :      * @note Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions.</a>
<a name="201"><span class="lineNum">     201 </span>            :      */</a>
<a name="202"><span class="lineNum">     202 </span>            :     void CalculateOnSimplexNonHistorical(</a>
<a name="203"><span class="lineNum">     203 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="204"><span class="lineNum">     204 </span>            :         const std::size_t Dimension,</a>
<a name="205"><span class="lineNum">     205 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="206"><span class="lineNum">     206 </span>            :         );</a>
<a name="207"><span class="lineNum">     207 </span>            : </a>
<a name="208"><span class="lineNum">     208 </span>            :     /**</a>
<a name="209"><span class="lineNum">     209 </span>            :      * @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="210"><span class="lineNum">     210 </span>            :      * @details This is done on the base of the Conditions provided which should be  understood as the surface elements of the area of interest.</a>
<a name="211"><span class="lineNum">     211 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain</a>
<a name="212"><span class="lineNum">     212 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="213"><span class="lineNum">     213 </span>            :      * @note Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions.</a>
<a name="214"><span class="lineNum">     214 </span>            :      */</a>
<a name="215"><span class="lineNum">     215 </span>            :     void CalculateOnSimplex(</a>
<a name="216"><span class="lineNum">     216 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="217"><span class="lineNum">     217 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="218"><span class="lineNum">     218 </span>            :         );</a>
<a name="219"><span class="lineNum">     219 </span>            : </a>
<a name="220"><span class="lineNum">     220 </span>            :     /**</a>
<a name="221"><span class="lineNum">     221 </span>            :      * @brief Calculates the area normal in the non-historical database (vector oriented as the normal with a dimension proportional to the area).</a>
<a name="222"><span class="lineNum">     222 </span>            :      * @details This is done on the base of the Conditions provided which should be  understood as the surface elements of the area of interest.</a>
<a name="223"><span class="lineNum">     223 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain</a>
<a name="224"><span class="lineNum">     224 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="225"><span class="lineNum">     225 </span>            :      * @note Use this fuction instead of its overload taking a Conditions array for MPI applications, as it will take care of communication between partitions.</a>
<a name="226"><span class="lineNum">     226 </span>            :      */</a>
<a name="227"><span class="lineNum">     227 </span>            :     void CalculateOnSimplexNonHistorical(</a>
<a name="228"><span class="lineNum">     228 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="229"><span class="lineNum">     229 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="230"><span class="lineNum">     230 </span>            :         );</a>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<a name="232"><span class="lineNum">     232 </span>            :     /**</a>
<a name="233"><span class="lineNum">     233 </span>            :      * @brief This function swaps the normal of all of the conditions in a model part</a>
<a name="234"><span class="lineNum">     234 </span>            :      * @details This is done by swapping the two first nodes in the geometry and is thus appropriate for simplicial elements</a>
<a name="235"><span class="lineNum">     235 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain</a>
<a name="236"><span class="lineNum">     236 </span>            :      */</a>
<a name="237"><span class="lineNum">     237 </span>            :     void SwapNormals(ModelPart&amp; rModelPart);</a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<a name="239"><span class="lineNum">     239 </span>            :     /**</a>
<a name="240"><span class="lineNum">     240 </span>            :      * @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable.</a>
<a name="241"><span class="lineNum">     241 </span>            :      * @details This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI.</a>
<a name="242"><span class="lineNum">     242 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain.</a>
<a name="243"><span class="lineNum">     243 </span>            :      * @param Dimension Spatial dimension (2 or 3).</a>
<a name="244"><span class="lineNum">     244 </span>            :      * @param rVariable The Kratos::Variable used to indicate which parts of the boundary will be used to calculate the normals.</a>
<a name="245"><span class="lineNum">     245 </span>            :      * @param Zero The 'off' value for the flag. Conditions where rVariable == Zero will be skipped for normal calculation.</a>
<a name="246"><span class="lineNum">     246 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="247"><span class="lineNum">     247 </span>            :      */</a>
<a name="248"><span class="lineNum">     248 </span>            :     template&lt;class TValueType&gt;</a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :     void CalculateOnSimplex(</span></a>
<a name="250"><span class="lineNum">     250 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="251"><span class="lineNum">     251 </span>            :         const std::size_t Dimension,</a>
<a name="252"><span class="lineNum">     252 </span>            :         const Variable&lt;TValueType&gt;&amp; rVariable,</a>
<a name="253"><span class="lineNum">     253 </span>            :         const TValueType Zero,</a>
<a name="254"><span class="lineNum">     254 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="255"><span class="lineNum">     255 </span>            :         )</a>
<a name="256"><span class="lineNum">     256 </span>            :     {</a>
<a name="257"><span class="lineNum">     257 </span>            :         KRATOS_TRY;</a>
<a name="258"><span class="lineNum">     258 </span>            : </a>
<a name="259"><span class="lineNum">     259 </span>            :         // Reset normals</a>
<a name="260"><span class="lineNum">     260 </span>            :         //TODO: This can be parallel</a>
<a name="261"><span class="lineNum">     261 </span>            :         const array_1d&lt;double,3&gt; ZeroNormal(3,0.0);</a>
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 :         for(ModelPart::NodesContainerType::iterator it = rModelPart.NodesBegin(); it !=rModelPart.NodesEnd(); it++) {</span></a>
<a name="263"><span class="lineNum">     263 </span>            :             noalias(it-&gt;FastGetSolutionStepValue(rNormalVariable)) = ZeroNormal;</a>
<a name="264"><span class="lineNum">     264 </span>            :         }</a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span>            :         // Calculate new condition normals, using only conditions with rVariable == rValue</a>
<a name="267"><span class="lineNum">     267 </span>            :         array_1d&lt;double,3&gt; An(3,0.0);</a>
<a name="268"><span class="lineNum">     268 </span>            : </a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :         if ( Dimension == 2 ) {</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</span></a>
<a name="272"><span class="lineNum">     272 </span><span class="lineNoCov">          0 :                     CalculateNormal2D(*itCond,An,rNormalVariable);</span></a>
<a name="273"><span class="lineNum">     273 </span>            :             }</a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :         } else if ( Dimension == 3 ) {</span></a>
<a name="275"><span class="lineNum">     275 </span>            :             array_1d&lt;double,3&gt; v1(3,0.0);</a>
<a name="276"><span class="lineNum">     276 </span>            :             array_1d&lt;double,3&gt; v2(3,0.0);</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span><span class="lineNoCov">          0 :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</span></a>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :                     CalculateNormal3D(*itCond,An,v1,v2,rNormalVariable);</span></a>
<a name="281"><span class="lineNum">     281 </span>            :             }</a>
<a name="282"><span class="lineNum">     282 </span>            :         }</a>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<a name="284"><span class="lineNum">     284 </span>            :         // Transfer normals to nodes</a>
<a name="285"><span class="lineNum">     285 </span><span class="lineNoCov">          0 :         for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</span></a>
<a name="286"><span class="lineNum">     286 </span>            :             Condition::GeometryType&amp; rGeom = itCond-&gt;GetGeometry();</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :             const double Coef = 1.0 / rGeom.PointsNumber();</span></a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :             const auto&amp; r_normal = itCond-&gt;GetValue(rNormalVariable);</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :             for ( Condition::GeometryType::iterator itNode = rGeom.begin(); itNode != rGeom.end(); ++itNode)</span></a>
<a name="290"><span class="lineNum">     290 </span>            :                 noalias(itNode-&gt;FastGetSolutionStepValue(rNormalVariable)) += r_normal * Coef;</a>
<a name="291"><span class="lineNum">     291 </span>            :         }</a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span>            :         // For MPI: correct values on partition boundaries</a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :         rModelPart.GetCommunicator().AssembleCurrentData(rNormalVariable);</span></a>
<a name="295"><span class="lineNum">     295 </span>            : </a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;);</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="298"><span class="lineNum">     298 </span>            : </a>
<a name="299"><span class="lineNum">     299 </span>            :     ///</a>
<a name="300"><span class="lineNum">     300 </span>            :     /**</a>
<a name="301"><span class="lineNum">     301 </span>            :      * @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable.</a>
<a name="302"><span class="lineNum">     302 </span>            :      * @details This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI.</a>
<a name="303"><span class="lineNum">     303 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain.</a>
<a name="304"><span class="lineNum">     304 </span>            :      * @param Dimension Spatial dimension (2 or 3).</a>
<a name="305"><span class="lineNum">     305 </span>            :      * @param rVariable The Kratos::Variable used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped.</a>
<a name="306"><span class="lineNum">     306 </span>            :      */</a>
<a name="307"><span class="lineNum">     307 </span>            :     template&lt;class TValueType&gt;</a>
<a name="308"><span class="lineNum">     308 </span>            :     void CalculateOnSimplex(</a>
<a name="309"><span class="lineNum">     309 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="310"><span class="lineNum">     310 </span>            :         const std::size_t Dimension,</a>
<a name="311"><span class="lineNum">     311 </span>            :         const Variable&lt;TValueType&gt;&amp; rVariable</a>
<a name="312"><span class="lineNum">     312 </span>            :         )</a>
<a name="313"><span class="lineNum">     313 </span>            :     {</a>
<a name="314"><span class="lineNum">     314 </span><span class="lineNoCov">          0 :         CalculateOnSimplex(rModelPart,Dimension,rVariable,TValueType(),NORMAL);</span></a>
<a name="315"><span class="lineNum">     315 </span>            :     }</a>
<a name="316"><span class="lineNum">     316 </span>            : </a>
<a name="317"><span class="lineNum">     317 </span>            :     /**</a>
<a name="318"><span class="lineNum">     318 </span>            :      *  @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha .</a>
<a name="319"><span class="lineNum">     319 </span>            :      * @details This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI.</a>
<a name="320"><span class="lineNum">     320 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain.</a>
<a name="321"><span class="lineNum">     321 </span>            :      * @param Dimension Spatial dimension (2 or 3).</a>
<a name="322"><span class="lineNum">     322 </span>            :      * @param rVariable The Kratos::Variable used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped.</a>
<a name="323"><span class="lineNum">     323 </span>            :      * @param rAlpha the maximum angle to distinguish normals.</a>
<a name="324"><span class="lineNum">     324 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="325"><span class="lineNum">     325 </span>            :      */</a>
<a name="326"><span class="lineNum">     326 </span>            :     template&lt;class TValueType&gt;</a>
<a name="327"><span class="lineNum">     327 </span><span class="lineNoCov">          0 :     void CalculateOnSimplex(</span></a>
<a name="328"><span class="lineNum">     328 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="329"><span class="lineNum">     329 </span>            :         const std::size_t Dimension,</a>
<a name="330"><span class="lineNum">     330 </span>            :         const Variable&lt;TValueType&gt;&amp; rVariable,</a>
<a name="331"><span class="lineNum">     331 </span>            :         const TValueType Zero,</a>
<a name="332"><span class="lineNum">     332 </span>            :         const double rAlpha,</a>
<a name="333"><span class="lineNum">     333 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="334"><span class="lineNum">     334 </span>            :         )</a>
<a name="335"><span class="lineNum">     335 </span>            :     {</a>
<a name="336"><span class="lineNum">     336 </span>            :         KRATOS_TRY;</a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span>            :         // Reset normals</a>
<a name="339"><span class="lineNum">     339 </span>            :         //TODO: This can be parallel</a>
<a name="340"><span class="lineNum">     340 </span>            :         const array_1d&lt;double,3&gt; ZeroNormal(3,0.0);</a>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :         for(ModelPart::NodesContainerType::iterator it =  rModelPart.NodesBegin(); it !=rModelPart.NodesEnd(); it++) {</span></a>
<a name="342"><span class="lineNum">     342 </span>            :             noalias(it-&gt;FastGetSolutionStepValue(NORMAL)) = ZeroNormal;</a>
<a name="343"><span class="lineNum">     343 </span><span class="lineNoCov">          0 :             it-&gt;FastGetSolutionStepValue(NODAL_PAUX) = 0.0;</span></a>
<a name="344"><span class="lineNum">     344 </span>            :         }</a>
<a name="345"><span class="lineNum">     345 </span>            : </a>
<a name="346"><span class="lineNum">     346 </span>            :         // Calculate new condition normals, using only conditions with rVariable == rValue</a>
<a name="347"><span class="lineNum">     347 </span>            :         array_1d&lt;double,3&gt; An(3,0.0);</a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span><span class="lineNoCov">          0 :         if ( Dimension == 2 ) {</span></a>
<a name="350"><span class="lineNum">     350 </span><span class="lineNoCov">          0 :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</span></a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :                     CalculateNormal2D(*itCond,An,rNormalVariable);</span></a>
<a name="353"><span class="lineNum">     353 </span>            :             }</a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :         } else if ( Dimension == 3 ) {</span></a>
<a name="355"><span class="lineNum">     355 </span>            :             array_1d&lt;double,3&gt; v1(3,0.0);</a>
<a name="356"><span class="lineNum">     356 </span>            :             array_1d&lt;double,3&gt; v2(3,0.0);</a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<a name="358"><span class="lineNum">     358 </span><span class="lineNoCov">          0 :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</span></a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :                     CalculateNormal3D(*itCond,An,v1,v2,rNormalVariable);</span></a>
<a name="361"><span class="lineNum">     361 </span>            :             }</a>
<a name="362"><span class="lineNum">     362 </span>            :         }</a>
<a name="363"><span class="lineNum">     363 </span>            : </a>
<a name="364"><span class="lineNum">     364 </span>            :         // Loop over nodes to set normals</a>
<a name="365"><span class="lineNum">     365 </span><span class="lineNoCov">          0 :         for(ModelPart::NodesContainerType::iterator it =  rModelPart.NodesBegin(); it !=rModelPart.NodesEnd(); it++) {</span></a>
<a name="366"><span class="lineNum">     366 </span>            :             std::vector&lt; array_1d&lt;double,3&gt; &gt; N_Mat;</a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :             N_Mat.reserve(10);</span></a>
<a name="368"><span class="lineNum">     368 </span>            :             double nodal_area = 0.0;</a>
<a name="369"><span class="lineNum">     369 </span>            : </a>
<a name="370"><span class="lineNum">     370 </span>            :             GlobalPointersVector&lt;Condition &gt;&amp; ng_cond = it-&gt;GetValue(NEIGHBOUR_CONDITIONS);</a>
<a name="371"><span class="lineNum">     371 </span>            : </a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :             if(ng_cond.size() != 0) {</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :                 for(GlobalPointersVector&lt;Condition &gt;::iterator ic = ng_cond.begin(); ic!=ng_cond.end(); ic++) {</span></a>
<a name="374"><span class="lineNum">     374 </span>            :                     Condition::GeometryType&amp; pGeom = ic-&gt;GetGeometry();</a>
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 :                     const auto&amp; rNormal = ic-&gt;GetValue(rNormalVariable);</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :                     const double Coef = 1.0 / pGeom.PointsNumber();</span></a>
<a name="377"><span class="lineNum">     377 </span>            :                     double norm_normal = norm_2( rNormal );</a>
<a name="378"><span class="lineNum">     378 </span>            : </a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :                     if(norm_normal != 0.0) {</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :                         nodal_area += Coef * norm_normal;</span></a>
<a name="381"><span class="lineNum">     381 </span>            : </a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :                         if(N_Mat.size() == 0.0) {</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :                             N_Mat.push_back( rNormal * Coef );</span></a>
<a name="384"><span class="lineNum">     384 </span>            :                         } else {</a>
<a name="385"><span class="lineNum">     385 </span>            :                             int added = 0;</a>
<a name="386"><span class="lineNum">     386 </span><span class="lineNoCov">          0 :                             for(unsigned int ii=0; ii&lt;N_Mat.size();++ii) {</span></a>
<a name="387"><span class="lineNum">     387 </span>            :                                 const array_1d&lt;double,3&gt;&amp; temp_normal = N_Mat[ii];</a>
<a name="388"><span class="lineNum">     388 </span>            :                                 double norm_temp = norm_2( temp_normal );</a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :                                 double cos_alpha=temp_normal[0]*rNormal[0] + temp_normal[1]*rNormal[1] +temp_normal[2]*rNormal[2];</span></a>
<a name="391"><span class="lineNum">     391 </span><span class="lineNoCov">          0 :                                 cos_alpha /= (norm_temp*norm_normal);</span></a>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :                                 if( cos_alpha &gt; std::cos(0.017453293*rAlpha)) {</span></a>
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 :                                     N_Mat[ii] += rNormal * Coef;</span></a>
<a name="395"><span class="lineNum">     395 </span>            :                                     added = 1;</a>
<a name="396"><span class="lineNum">     396 </span>            :                                 }</a>
<a name="397"><span class="lineNum">     397 </span>            :                             }</a>
<a name="398"><span class="lineNum">     398 </span>            : </a>
<a name="399"><span class="lineNum">     399 </span><span class="lineNoCov">          0 :                             if(!added)</span></a>
<a name="400"><span class="lineNum">     400 </span><span class="lineNoCov">          0 :                                 N_Mat.push_back( rNormal*Coef );</span></a>
<a name="401"><span class="lineNum">     401 </span>            :                         }</a>
<a name="402"><span class="lineNum">     402 </span>            :                     }</a>
<a name="403"><span class="lineNum">     403 </span>            :                 }</a>
<a name="404"><span class="lineNum">     404 </span>            :             }</a>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<a name="406"><span class="lineNum">     406 </span>            :             // Compute NORMAL and mark</a>
<a name="407"><span class="lineNum">     407 </span>            :             array_1d&lt;double,3&gt; sum_Normal(3,0.0);</a>
<a name="408"><span class="lineNum">     408 </span>            : </a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 :             for(unsigned int ii=0; ii&lt;N_Mat.size(); ++ii) {</span></a>
<a name="410"><span class="lineNum">     410 </span>            :                 sum_Normal += N_Mat[ii];</a>
<a name="411"><span class="lineNum">     411 </span>            :             }</a>
<a name="412"><span class="lineNum">     412 </span>            : </a>
<a name="413"><span class="lineNum">     413 </span>            :             noalias( it-&gt;FastGetSolutionStepValue(rNormalVariable) ) = sum_Normal;</a>
<a name="414"><span class="lineNum">     414 </span><span class="lineNoCov">          0 :             it-&gt;FastGetSolutionStepValue(NODAL_PAUX) = nodal_area;</span></a>
<a name="415"><span class="lineNum">     415 </span>            :             //assign IS_SLIP = 0 for vertices</a>
<a name="416"><span class="lineNum">     416 </span><span class="lineNoCov">          0 :             if(N_Mat.size() == 2) {</span></a>
<a name="417"><span class="lineNum">     417 </span>            : //                 it-&gt;SetValue(IS_SLIP,0);</a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=20.0;</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :             } else if(N_Mat.size() == 3) {</span></a>
<a name="420"><span class="lineNum">     420 </span><span class="lineNoCov">          0 :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=30.0;</span></a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :             } else if(N_Mat.size() == 1) {</span></a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=10.0;</span></a>
<a name="423"><span class="lineNum">     423 </span>            :             }</a>
<a name="424"><span class="lineNum">     424 </span>            :         }</a>
<a name="425"><span class="lineNum">     425 </span>            : </a>
<a name="426"><span class="lineNum">     426 </span>            :         // For MPI: correct values on partition boundaries</a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :         rModelPart.GetCommunicator().AssembleCurrentData(rNormalVariable);</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :         rModelPart.GetCommunicator().AssembleCurrentData(NODAL_PAUX);</span></a>
<a name="429"><span class="lineNum">     429 </span>            : </a>
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;);</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="432"><span class="lineNum">     432 </span>            : </a>
<a name="433"><span class="lineNum">     433 </span>            :     /**</a>
<a name="434"><span class="lineNum">     434 </span>            :      *  @brief Calculates the area normal (vector oriented as the normal with a dimension proportional to the area) using only nodes marked with a flag variable and detecting corners. Corners are defined as nodes that recieves more than 2 normals from their neighbor conditions with a difference in angle greater than Alpha . (Low memory version)</a>
<a name="435"><span class="lineNum">     435 </span>            :      * @details This function is equivalent to other implementations of CalculateOnSimplex, but instead of using all conditions in the array, it only uses those that contain a value of rVariable != Zero. This is useful in problems where a part of the boundary is a slip condition, as it provides more reasonable values for the normals on the border between this area and other parts of the boundary. This function is safe to use in MPI.</a>
<a name="436"><span class="lineNum">     436 </span>            :      * @param rModelPart ModelPart of the problem. Must have a set of conditions defining the &quot;skin&quot; of the domain.</a>
<a name="437"><span class="lineNum">     437 </span>            :      * @param Dimension Spatial dimension (2 or 3).</a>
<a name="438"><span class="lineNum">     438 </span>            :      * @param rVariable The Kratos::Variable used to indicate which parts of the boundary will be used to calculate the normals. Conditions where rVariable == Zero will be skipped.</a>
<a name="439"><span class="lineNum">     439 </span>            :      * @param rAlpha the maximum angle to distinguish normals.</a>
<a name="440"><span class="lineNum">     440 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="441"><span class="lineNum">     441 </span>            :      */</a>
<a name="442"><span class="lineNum">     442 </span>            :     template&lt; class TValueType &gt;</a>
<a name="443"><span class="lineNum">     443 </span>            :     void CalculateOnSimplexLowMemory(</a>
<a name="444"><span class="lineNum">     444 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="445"><span class="lineNum">     445 </span>            :         int Dimension,</a>
<a name="446"><span class="lineNum">     446 </span>            :         const Variable&lt;TValueType&gt;&amp; rVariable,</a>
<a name="447"><span class="lineNum">     447 </span>            :         const TValueType Zero,const double rAlpha,</a>
<a name="448"><span class="lineNum">     448 </span>            :         const NormalVariableType&amp; rNormalVariable = NORMAL</a>
<a name="449"><span class="lineNum">     449 </span>            :         )</a>
<a name="450"><span class="lineNum">     450 </span>            :     {</a>
<a name="451"><span class="lineNum">     451 </span>            :         KRATOS_TRY;</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            :         // Reset normals</a>
<a name="454"><span class="lineNum">     454 </span>            :         //TODO: This can be parallel</a>
<a name="455"><span class="lineNum">     455 </span>            :         const array_1d&lt;double,3&gt; ZeroNormal(3,0.0);</a>
<a name="456"><span class="lineNum">     456 </span>            :         for(ModelPart::NodesContainerType::iterator it =  rModelPart.NodesBegin(); it !=rModelPart.NodesEnd(); it++) {</a>
<a name="457"><span class="lineNum">     457 </span>            :             noalias(it-&gt;GetValue(rNormalVariable)) = ZeroNormal;</a>
<a name="458"><span class="lineNum">     458 </span>            :             it-&gt;GetValue(NODAL_PAUX) = 0.0;</a>
<a name="459"><span class="lineNum">     459 </span>            :         }</a>
<a name="460"><span class="lineNum">     460 </span>            : </a>
<a name="461"><span class="lineNum">     461 </span>            :         // Calculate new condition normals, using only conditions with rVariable == rValue</a>
<a name="462"><span class="lineNum">     462 </span>            :         array_1d&lt;double,3&gt; An(3,0.0);</a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span>            :         if ( Dimension == 2 ) {</a>
<a name="465"><span class="lineNum">     465 </span>            :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</a>
<a name="466"><span class="lineNum">     466 </span>            :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</a>
<a name="467"><span class="lineNum">     467 </span>            :                     CalculateNormal2D(*itCond,An,rNormalVariable);</a>
<a name="468"><span class="lineNum">     468 </span>            :             }</a>
<a name="469"><span class="lineNum">     469 </span>            :         } else if ( Dimension == 3 ) {</a>
<a name="470"><span class="lineNum">     470 </span>            :             array_1d&lt;double,3&gt; v1(3,0.0);</a>
<a name="471"><span class="lineNum">     471 </span>            :             array_1d&lt;double,3&gt; v2(3,0.0);</a>
<a name="472"><span class="lineNum">     472 </span>            : </a>
<a name="473"><span class="lineNum">     473 </span>            :             for ( ModelPart::ConditionIterator itCond = rModelPart.ConditionsBegin(); itCond != rModelPart.ConditionsEnd(); ++itCond ) {</a>
<a name="474"><span class="lineNum">     474 </span>            :                 if ( itCond-&gt;GetValue(rVariable) != Zero )</a>
<a name="475"><span class="lineNum">     475 </span>            :                     CalculateNormal3D(*itCond,An,v1,v2,rNormalVariable);</a>
<a name="476"><span class="lineNum">     476 </span>            :             }</a>
<a name="477"><span class="lineNum">     477 </span>            :         }</a>
<a name="478"><span class="lineNum">     478 </span>            : </a>
<a name="479"><span class="lineNum">     479 </span>            :         // Loop over nodes to set normals</a>
<a name="480"><span class="lineNum">     480 </span>            :         for(ModelPart::NodesContainerType::iterator it =  rModelPart.NodesBegin(); it !=rModelPart.NodesEnd(); it++) {</a>
<a name="481"><span class="lineNum">     481 </span>            :             std::vector&lt; array_1d&lt;double,3&gt; &gt; N_Mat;</a>
<a name="482"><span class="lineNum">     482 </span>            :             N_Mat.reserve(10);</a>
<a name="483"><span class="lineNum">     483 </span>            :             double nodal_area = 0.0;</a>
<a name="484"><span class="lineNum">     484 </span>            : </a>
<a name="485"><span class="lineNum">     485 </span>            :             GlobalPointersVector&lt;Condition &gt;&amp; ng_cond = it-&gt;GetValue(NEIGHBOUR_CONDITIONS);</a>
<a name="486"><span class="lineNum">     486 </span>            : </a>
<a name="487"><span class="lineNum">     487 </span>            :             if(ng_cond.size() != 0){</a>
<a name="488"><span class="lineNum">     488 </span>            :                 for(GlobalPointersVector&lt;Condition &gt;::iterator ic = ng_cond.begin(); ic!=ng_cond.end(); ic++) {</a>
<a name="489"><span class="lineNum">     489 </span>            :                 Condition::GeometryType&amp; pGeom = ic-&gt;GetGeometry();</a>
<a name="490"><span class="lineNum">     490 </span>            :                 const auto&amp; rNormal = ic-&gt;GetValue(rNormalVariable);</a>
<a name="491"><span class="lineNum">     491 </span>            :                 const double Coef = 1.0 / pGeom.PointsNumber();</a>
<a name="492"><span class="lineNum">     492 </span>            :                 double norm_normal = norm_2( rNormal );</a>
<a name="493"><span class="lineNum">     493 </span>            : </a>
<a name="494"><span class="lineNum">     494 </span>            :                 if(norm_normal != 0.0) {</a>
<a name="495"><span class="lineNum">     495 </span>            :                     nodal_area += Coef * norm_normal;</a>
<a name="496"><span class="lineNum">     496 </span>            : </a>
<a name="497"><span class="lineNum">     497 </span>            :                     if(N_Mat.size() == 0.0) {</a>
<a name="498"><span class="lineNum">     498 </span>            :                         N_Mat.push_back( rNormal * Coef );</a>
<a name="499"><span class="lineNum">     499 </span>            :                     } else{</a>
<a name="500"><span class="lineNum">     500 </span>            :                         int added = 0;</a>
<a name="501"><span class="lineNum">     501 </span>            :                         for(unsigned int ii=0; ii&lt;N_Mat.size();++ii) {</a>
<a name="502"><span class="lineNum">     502 </span>            :                             const array_1d&lt;double,3&gt;&amp; temp_normal = N_Mat[ii];</a>
<a name="503"><span class="lineNum">     503 </span>            :                             double norm_temp = norm_2( temp_normal );</a>
<a name="504"><span class="lineNum">     504 </span>            : </a>
<a name="505"><span class="lineNum">     505 </span>            :                             double cos_alpha=temp_normal[0]*rNormal[0] + temp_normal[1]*rNormal[1] +temp_normal[2]*rNormal[2];</a>
<a name="506"><span class="lineNum">     506 </span>            :                             cos_alpha /= (norm_temp*norm_normal);</a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :                             if( cos_alpha &gt; cos(0.017453293*rAlpha) ){</a>
<a name="509"><span class="lineNum">     509 </span>            :                                 N_Mat[ii] += rNormal * Coef;</a>
<a name="510"><span class="lineNum">     510 </span>            :                                 added = 1;}</a>
<a name="511"><span class="lineNum">     511 </span>            :                             }</a>
<a name="512"><span class="lineNum">     512 </span>            :                             if(!added)</a>
<a name="513"><span class="lineNum">     513 </span>            :                                 N_Mat.push_back( rNormal*Coef );</a>
<a name="514"><span class="lineNum">     514 </span>            : </a>
<a name="515"><span class="lineNum">     515 </span>            :                         }</a>
<a name="516"><span class="lineNum">     516 </span>            :                     }</a>
<a name="517"><span class="lineNum">     517 </span>            :                 }</a>
<a name="518"><span class="lineNum">     518 </span>            :             }</a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            :             // Compute NORMAL and mark</a>
<a name="521"><span class="lineNum">     521 </span>            :             array_1d&lt;double,3&gt; sum_Normal(3,0.0);</a>
<a name="522"><span class="lineNum">     522 </span>            : </a>
<a name="523"><span class="lineNum">     523 </span>            :             for(unsigned int ii=0; ii&lt;N_Mat.size(); ++ii){</a>
<a name="524"><span class="lineNum">     524 </span>            :                 sum_Normal += N_Mat[ii];</a>
<a name="525"><span class="lineNum">     525 </span>            :             }</a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span>            :             noalias( it-&gt;FastGetSolutionStepValue(rNormalVariable) ) = sum_Normal;</a>
<a name="528"><span class="lineNum">     528 </span>            :             it-&gt;FastGetSolutionStepValue(NODAL_PAUX) = nodal_area;</a>
<a name="529"><span class="lineNum">     529 </span>            :             //assign IS_SLIP = 0 for vertices</a>
<a name="530"><span class="lineNum">     530 </span>            :             if(N_Mat.size() == 2){</a>
<a name="531"><span class="lineNum">     531 </span>            : //                 it-&gt;SetValue(IS_SLIP,0);</a>
<a name="532"><span class="lineNum">     532 </span>            :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=20.0;</a>
<a name="533"><span class="lineNum">     533 </span>            :             } else if(N_Mat.size() == 3) {</a>
<a name="534"><span class="lineNum">     534 </span>            :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=30.0;</a>
<a name="535"><span class="lineNum">     535 </span>            :             } else if(N_Mat.size() == 1) {</a>
<a name="536"><span class="lineNum">     536 </span>            :                 it-&gt;FastGetSolutionStepValue(IS_SLIP)=10.0;</a>
<a name="537"><span class="lineNum">     537 </span>            : </a>
<a name="538"><span class="lineNum">     538 </span>            :             }</a>
<a name="539"><span class="lineNum">     539 </span>            :         }</a>
<a name="540"><span class="lineNum">     540 </span>            : </a>
<a name="541"><span class="lineNum">     541 </span>            :         // For MPI: correct values on partition boundaries</a>
<a name="542"><span class="lineNum">     542 </span>            :         rModelPart.GetCommunicator().AssembleCurrentData(rNormalVariable);</a>
<a name="543"><span class="lineNum">     543 </span>            :         rModelPart.GetCommunicator().AssembleCurrentData(NODAL_PAUX);</a>
<a name="544"><span class="lineNum">     544 </span>            : </a>
<a name="545"><span class="lineNum">     545 </span>            :         KRATOS_CATCH(&quot;&quot;);</a>
<a name="546"><span class="lineNum">     546 </span>            :     }</a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span>            : private:</a>
<a name="549"><span class="lineNum">     549 </span>            :     ///@name Static Member Variables</a>
<a name="550"><span class="lineNum">     550 </span>            :     ///@{</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span>            :     ///@}</a>
<a name="553"><span class="lineNum">     553 </span>            :     ///@name Member Variables</a>
<a name="554"><span class="lineNum">     554 </span>            :     ///@{</a>
<a name="555"><span class="lineNum">     555 </span>            : </a>
<a name="556"><span class="lineNum">     556 </span>            :     ///@}</a>
<a name="557"><span class="lineNum">     557 </span>            :     ///@name Private Operators</a>
<a name="558"><span class="lineNum">     558 </span>            :     ///@{</a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span>            :     ///@}</a>
<a name="561"><span class="lineNum">     561 </span>            :     ///@name Private Operations</a>
<a name="562"><span class="lineNum">     562 </span>            :     ///@{</a>
<a name="563"><span class="lineNum">     563 </span>            : </a>
<a name="564"><span class="lineNum">     564 </span>            :     /**</a>
<a name="565"><span class="lineNum">     565 </span>            :      * @brief It initializes the normal in the entites and in all the nodes</a>
<a name="566"><span class="lineNum">     566 </span>            :      * @param rModelPart The model part to compute</a>
<a name="567"><span class="lineNum">     567 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="568"><span class="lineNum">     568 </span>            :      * @tparam TContainerType Type of the container that will store the entities for the normal calculation</a>
<a name="569"><span class="lineNum">     569 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="570"><span class="lineNum">     570 </span>            :      */</a>
<a name="571"><span class="lineNum">     571 </span>            :     template&lt;class TContainerType, bool TIsHistorical&gt;</a>
<a name="572"><span class="lineNum">     572 </span>            :     void InitializeNormals(</a>
<a name="573"><span class="lineNum">     573 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="574"><span class="lineNum">     574 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="575"><span class="lineNum">     575 </span>            :         );</a>
<a name="576"><span class="lineNum">     576 </span>            : </a>
<a name="577"><span class="lineNum">     577 </span>            :     /**</a>
<a name="578"><span class="lineNum">     578 </span>            :      * @brief It computes the unit normals from the area normals</a>
<a name="579"><span class="lineNum">     579 </span>            :      * @param rModelPart The model part to compute</a>
<a name="580"><span class="lineNum">     580 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="581"><span class="lineNum">     581 </span>            :      * @tparam TContainerType Type of the container that will store the entities for the normal calculation</a>
<a name="582"><span class="lineNum">     582 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="583"><span class="lineNum">     583 </span>            :      */</a>
<a name="584"><span class="lineNum">     584 </span>            :     template&lt;class TContainerType, bool TIsHistorical&gt;</a>
<a name="585"><span class="lineNum">     585 </span>            :     void ComputeUnitNormalsFromAreaNormals(</a>
<a name="586"><span class="lineNum">     586 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="587"><span class="lineNum">     587 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="588"><span class="lineNum">     588 </span>            :         );</a>
<a name="589"><span class="lineNum">     589 </span>            : </a>
<a name="590"><span class="lineNum">     590 </span>            :     /**</a>
<a name="591"><span class="lineNum">     591 </span>            :      * @brief This function adds the Contribution of one of the geometries to the corresponding nodes</a>
<a name="592"><span class="lineNum">     592 </span>            :      * @param rCondition Reference to the target condition</a>
<a name="593"><span class="lineNum">     593 </span>            :      * @param rAn Area normal</a>
<a name="594"><span class="lineNum">     594 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="595"><span class="lineNum">     595 </span>            :      */</a>
<a name="596"><span class="lineNum">     596 </span>            :     static void CalculateNormal2D(</a>
<a name="597"><span class="lineNum">     597 </span>            :         Condition&amp; rCondition,</a>
<a name="598"><span class="lineNum">     598 </span>            :         array_1d&lt;double,3&gt;&amp; rAn,</a>
<a name="599"><span class="lineNum">     599 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="600"><span class="lineNum">     600 </span>            :         );</a>
<a name="601"><span class="lineNum">     601 </span>            : </a>
<a name="602"><span class="lineNum">     602 </span>            :     /**</a>
<a name="603"><span class="lineNum">     603 </span>            :      * @brief Calculates 2D condition area normals shape sensitivity</a>
<a name="604"><span class="lineNum">     604 </span>            :      * @param rCondition Reference to the target condition</a>
<a name="605"><span class="lineNum">     605 </span>            :      */</a>
<a name="606"><span class="lineNum">     606 </span>            :     static void CalculateNormalShapeDerivative2D(</a>
<a name="607"><span class="lineNum">     607 </span>            :         ConditionType&amp; rCondition</a>
<a name="608"><span class="lineNum">     608 </span>            :         );</a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            :     /**</a>
<a name="611"><span class="lineNum">     611 </span>            :      * @brief This function adds the Contribution of one of the geometries to the corresponding nodes</a>
<a name="612"><span class="lineNum">     612 </span>            :      * @param rCondition Reference to the target condition</a>
<a name="613"><span class="lineNum">     613 </span>            :      * @param rAn Area normal</a>
<a name="614"><span class="lineNum">     614 </span>            :      * @param rv1 First tangent vector</a>
<a name="615"><span class="lineNum">     615 </span>            :      * @param rv2 Second tangent vector</a>
<a name="616"><span class="lineNum">     616 </span>            :      */</a>
<a name="617"><span class="lineNum">     617 </span>            :     static void CalculateNormal3D(</a>
<a name="618"><span class="lineNum">     618 </span>            :         Condition&amp; rCondition,</a>
<a name="619"><span class="lineNum">     619 </span>            :         array_1d&lt;double,3&gt;&amp; rAn,</a>
<a name="620"><span class="lineNum">     620 </span>            :         array_1d&lt;double,3&gt;&amp; rv1,</a>
<a name="621"><span class="lineNum">     621 </span>            :         array_1d&lt;double,3&gt;&amp; rv2,</a>
<a name="622"><span class="lineNum">     622 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="623"><span class="lineNum">     623 </span>            :         );</a>
<a name="624"><span class="lineNum">     624 </span>            : </a>
<a name="625"><span class="lineNum">     625 </span>            :     /**</a>
<a name="626"><span class="lineNum">     626 </span>            :      * @brief Calculates 3D condition area normals shape sensitivity</a>
<a name="627"><span class="lineNum">     627 </span>            :      * @param rCondition Reference to the target condition</a>
<a name="628"><span class="lineNum">     628 </span>            :      */</a>
<a name="629"><span class="lineNum">     629 </span>            :     static void CalculateNormalShapeDerivative3D(</a>
<a name="630"><span class="lineNum">     630 </span>            :         ConditionType&amp; rCondition</a>
<a name="631"><span class="lineNum">     631 </span>            :         );</a>
<a name="632"><span class="lineNum">     632 </span>            : </a>
<a name="633"><span class="lineNum">     633 </span>            :     /**</a>
<a name="634"><span class="lineNum">     634 </span>            :      * @brief This method retrieves the containers</a>
<a name="635"><span class="lineNum">     635 </span>            :      * @param  rModelPart The modelpart with the containers to retrieve</a>
<a name="636"><span class="lineNum">     636 </span>            :      * @return The corresponding containers</a>
<a name="637"><span class="lineNum">     637 </span>            :      * @tparam TContainerType The container type</a>
<a name="638"><span class="lineNum">     638 </span>            :      */</a>
<a name="639"><span class="lineNum">     639 </span>            :     template&lt;class TContainerType&gt;</a>
<a name="640"><span class="lineNum">     640 </span>            :     TContainerType&amp; GetContainer(ModelPart&amp; rModelPart);</a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :     /**</a>
<a name="643"><span class="lineNum">     643 </span>            :      * @brief This method computes the normals considering generic algorithm</a>
<a name="644"><span class="lineNum">     644 </span>            :      * @param rModelPart The modelpart with normals to compute</a>
<a name="645"><span class="lineNum">     645 </span>            :      * @param ConsiderUnitNormal In order to consider directly the unit normal instead of the area normal multiplied with a coefficient</a>
<a name="646"><span class="lineNum">     646 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="647"><span class="lineNum">     647 </span>            :      * @tparam TContainerType The container type</a>
<a name="648"><span class="lineNum">     648 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="649"><span class="lineNum">     649 </span>            :      */</a>
<a name="650"><span class="lineNum">     650 </span>            :     template&lt;class TContainerType, bool TIsHistorical&gt;</a>
<a name="651"><span class="lineNum">     651 </span>            :     void CalculateNormalsUsingGenericAlgorithm(</a>
<a name="652"><span class="lineNum">     652 </span>            :         ModelPart&amp; rModelPart,</a>
<a name="653"><span class="lineNum">     653 </span>            :         const bool ConsiderUnitNormal,</a>
<a name="654"><span class="lineNum">     654 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="655"><span class="lineNum">     655 </span>            :         );</a>
<a name="656"><span class="lineNum">     656 </span>            : </a>
<a name="657"><span class="lineNum">     657 </span>            :     /**</a>
<a name="658"><span class="lineNum">     658 </span>            :      * @brief Gets the normal value from a node</a>
<a name="659"><span class="lineNum">     659 </span>            :      * Returns a reference to the nodal normal value</a>
<a name="660"><span class="lineNum">     660 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="661"><span class="lineNum">     661 </span>            :      * @param rNode Reference to the target node</a>
<a name="662"><span class="lineNum">     662 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="663"><span class="lineNum">     663 </span>            :      * @return array_1d&lt;double,3&gt;&amp; Reference to the normal value</a>
<a name="664"><span class="lineNum">     664 </span>            :      */</a>
<a name="665"><span class="lineNum">     665 </span>            :     template&lt;bool TIsHistorical&gt;</a>
<a name="666"><span class="lineNum">     666 </span>            :     array_1d&lt;double,3&gt;&amp; GetNormalValue(</a>
<a name="667"><span class="lineNum">     667 </span>            :         NodeType&amp; rNode,</a>
<a name="668"><span class="lineNum">     668 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="669"><span class="lineNum">     669 </span>            :         );</a>
<a name="670"><span class="lineNum">     670 </span>            : </a>
<a name="671"><span class="lineNum">     671 </span>            :     /**</a>
<a name="672"><span class="lineNum">     672 </span>            :      * @brief Sets the normal value to a node</a>
<a name="673"><span class="lineNum">     673 </span>            :      * Sets the provided normal value to the node</a>
<a name="674"><span class="lineNum">     674 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="675"><span class="lineNum">     675 </span>            :      * @param rNode Reference to the target node</a>
<a name="676"><span class="lineNum">     676 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="677"><span class="lineNum">     677 </span>            :      * @param rNormalValue Normal value to be set</a>
<a name="678"><span class="lineNum">     678 </span>            :      */</a>
<a name="679"><span class="lineNum">     679 </span>            :     template&lt;bool TIsHistorical&gt;</a>
<a name="680"><span class="lineNum">     680 </span>            :     void SetNormalValue(</a>
<a name="681"><span class="lineNum">     681 </span>            :         NodeType&amp; rNode,</a>
<a name="682"><span class="lineNum">     682 </span>            :         const NormalVariableType&amp; rNormalVariable,</a>
<a name="683"><span class="lineNum">     683 </span>            :         const array_1d&lt;double,3&gt;&amp; rNormalValue</a>
<a name="684"><span class="lineNum">     684 </span>            :         );</a>
<a name="685"><span class="lineNum">     685 </span>            : </a>
<a name="686"><span class="lineNum">     686 </span>            :     /**</a>
<a name="687"><span class="lineNum">     687 </span>            :      * @brief Checks if the simplex geometry normal calculation can be used</a>
<a name="688"><span class="lineNum">     688 </span>            :      * This method checks if the simplex geometry normal calculation can be applied to the current model part conditions</a>
<a name="689"><span class="lineNum">     689 </span>            :      * @param rModelPart Model part with the conditions from which the normal is computed</a>
<a name="690"><span class="lineNum">     690 </span>            :      * @param EnforceGenericGeometryAlgorithm True if the generic algorithm is enforced</a>
<a name="691"><span class="lineNum">     691 </span>            :      * @return true If the simplex geometries calculation can be used</a>
<a name="692"><span class="lineNum">     692 </span>            :      * @return false If the generic geometries algorithm is to be used</a>
<a name="693"><span class="lineNum">     693 </span>            :      */</a>
<a name="694"><span class="lineNum">     694 </span>            :     bool CheckUseSimplex(</a>
<a name="695"><span class="lineNum">     695 </span>            :         const ModelPart&amp; rModelPart,</a>
<a name="696"><span class="lineNum">     696 </span>            :         const bool EnforceGenericGeometryAlgorithm</a>
<a name="697"><span class="lineNum">     697 </span>            :         );</a>
<a name="698"><span class="lineNum">     698 </span>            : </a>
<a name="699"><span class="lineNum">     699 </span>            :     /**</a>
<a name="700"><span class="lineNum">     700 </span>            :      * @brief Auxiliary calculate on simplex method without specialization</a>
<a name="701"><span class="lineNum">     701 </span>            :      * Auxiliary method to be specialized</a>
<a name="702"><span class="lineNum">     702 </span>            :      * @tparam TIsHistorical Specifies if the historical or non-historical nodal database is used</a>
<a name="703"><span class="lineNum">     703 </span>            :      * @param rConditions A set of conditions defining the &quot;skin&quot; of a model</a>
<a name="704"><span class="lineNum">     704 </span>            :      * @param Dimension Spatial dimension (2 or 3)</a>
<a name="705"><span class="lineNum">     705 </span>            :      * @param rNormalVariable Component variable storing the normal value</a>
<a name="706"><span class="lineNum">     706 </span>            :      */</a>
<a name="707"><span class="lineNum">     707 </span>            :     template&lt;bool TIsHistorical&gt;</a>
<a name="708"><span class="lineNum">     708 </span>            :     void AuxiliaryCalculateOnSimplex(</a>
<a name="709"><span class="lineNum">     709 </span>            :         ConditionsArrayType&amp; rConditions,</a>
<a name="710"><span class="lineNum">     710 </span>            :         const std::size_t Dimension,</a>
<a name="711"><span class="lineNum">     711 </span>            :         const NormalVariableType&amp; rNormalVariable</a>
<a name="712"><span class="lineNum">     712 </span>            :         );</a>
<a name="713"><span class="lineNum">     713 </span>            : </a>
<a name="714"><span class="lineNum">     714 </span>            :     ///@}</a>
<a name="715"><span class="lineNum">     715 </span>            :     ///@name Private  Access</a>
<a name="716"><span class="lineNum">     716 </span>            :     ///@{</a>
<a name="717"><span class="lineNum">     717 </span>            :     ///@}</a>
<a name="718"><span class="lineNum">     718 </span>            : </a>
<a name="719"><span class="lineNum">     719 </span>            :     ///@}</a>
<a name="720"><span class="lineNum">     720 </span>            :     ///@name Serialization</a>
<a name="721"><span class="lineNum">     721 </span>            :     ///@{</a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span>            :     ///@name Private Inquiry</a>
<a name="724"><span class="lineNum">     724 </span>            :     ///@{</a>
<a name="725"><span class="lineNum">     725 </span>            :     ///@}</a>
<a name="726"><span class="lineNum">     726 </span>            : </a>
<a name="727"><span class="lineNum">     727 </span>            :     ///@name Unaccessible methods</a>
<a name="728"><span class="lineNum">     728 </span>            :     ///@{</a>
<a name="729"><span class="lineNum">     729 </span>            :     ///@}</a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span>            : }; // Class NormalCalculationUtils</a>
<a name="732"><span class="lineNum">     732 </span>            : </a>
<a name="733"><span class="lineNum">     733 </span>            : } // namespace Kratos</a>
<a name="734"><span class="lineNum">     734 </span>            : </a>
<a name="735"><span class="lineNum">     735 </span>            : #endif /* KRATOS_NORMAL_CALCULATION_UTILS  defined */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
