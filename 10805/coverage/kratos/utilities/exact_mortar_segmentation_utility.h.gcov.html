<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - kratos/utilities/exact_mortar_segmentation_utility.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">kratos/utilities</a> - exact_mortar_segmentation_utility.h<span style="font-size: 80%;"> (source / <a href="exact_mortar_segmentation_utility.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">89</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-17 14:49:52</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">192</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<a name="2"><span class="lineNum">       2 </span>            : //    |  /           |</a>
<a name="3"><span class="lineNum">       3 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="4"><span class="lineNum">       4 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="5"><span class="lineNum">       5 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="6"><span class="lineNum">       6 </span>            : //                   Multi-Physics</a>
<a name="7"><span class="lineNum">       7 </span>            : //</a>
<a name="8"><span class="lineNum">       8 </span>            : //  License:             BSD License</a>
<a name="9"><span class="lineNum">       9 </span>            : //                                       Kratos default license: kratos/license.txt</a>
<a name="10"><span class="lineNum">      10 </span>            : //</a>
<a name="11"><span class="lineNum">      11 </span>            : //  Main authors:    Vicente Mataix Ferrandiz</a>
<a name="12"><span class="lineNum">      12 </span>            : //</a>
<a name="13"><span class="lineNum">      13 </span>            : #if !defined(KRATOS_EXACT_MORTAR_INTEGRATION_UTILITY_H_INCLUDED)</a>
<a name="14"><span class="lineNum">      14 </span>            : #define KRATOS_EXACT_MORTAR_INTEGRATION_UTILITY_H_INCLUDED</a>
<a name="15"><span class="lineNum">      15 </span>            : </a>
<a name="16"><span class="lineNum">      16 </span>            : // System includes</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &lt;iostream&gt;</a>
<a name="18"><span class="lineNum">      18 </span>            : #include &lt;iomanip&gt;</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &lt;cmath&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : // External includes</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span>            : // Project includes</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &quot;includes/mortar_classes.h&quot;</a>
<a name="25"><span class="lineNum">      25 </span>            : </a>
<a name="26"><span class="lineNum">      26 </span>            : // The geometry of the triangle for the &quot;tessellation&quot;</a>
<a name="27"><span class="lineNum">      27 </span>            : /* LINES */</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &quot;geometries/line_2d_2.h&quot;</a>
<a name="29"><span class="lineNum">      29 </span>            : /* TRIANGLES */</a>
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;geometries/triangle_3d_3.h&quot;</a>
<a name="31"><span class="lineNum">      31 </span>            : /* QUADRILATERALS */</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &quot;geometries/quadrilateral_3d_4.h&quot;</a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span>            : // /* The integration points (we clip triangles in 3D, so with line and triangle is enough)*/</a>
<a name="35"><span class="lineNum">      35 </span>            : // #include &quot;integration/line_gauss_legendre_integration_points.h&quot;</a>
<a name="36"><span class="lineNum">      36 </span>            : #include &quot;integration/triangle_gauss_legendre_integration_points.h&quot;</a>
<a name="37"><span class="lineNum">      37 </span>            : </a>
<a name="38"><span class="lineNum">      38 </span>            : /* Utilities */</a>
<a name="39"><span class="lineNum">      39 </span>            : #include &quot;utilities/math_utils.h&quot;</a>
<a name="40"><span class="lineNum">      40 </span>            : #include &quot;utilities/mortar_utilities.h&quot;</a>
<a name="41"><span class="lineNum">      41 </span>            : </a>
<a name="42"><span class="lineNum">      42 </span>            : namespace Kratos {</a>
<a name="43"><span class="lineNum">      43 </span>            : ///@name Kratos Globals</a>
<a name="44"><span class="lineNum">      44 </span>            : ///@{</a>
<a name="45"><span class="lineNum">      45 </span>            : </a>
<a name="46"><span class="lineNum">      46 </span>            : ///@}</a>
<a name="47"><span class="lineNum">      47 </span>            : ///@name Type Definitions</a>
<a name="48"><span class="lineNum">      48 </span>            : ///@{</a>
<a name="49"><span class="lineNum">      49 </span>            : </a>
<a name="50"><span class="lineNum">      50 </span>            :     /// Geometric definitions</a>
<a name="51"><span class="lineNum">      51 </span>            :     typedef Point PointType;</a>
<a name="52"><span class="lineNum">      52 </span>            :     typedef Node&lt;3&gt; NodeType;</a>
<a name="53"><span class="lineNum">      53 </span>            :     typedef Geometry&lt;NodeType&gt; GeometryType;</a>
<a name="54"><span class="lineNum">      54 </span>            :     typedef Geometry&lt;PointType&gt; GeometryPointType;</a>
<a name="55"><span class="lineNum">      55 </span>            : </a>
<a name="56"><span class="lineNum">      56 </span>            :     ///Type definition for integration methods</a>
<a name="57"><span class="lineNum">      57 </span>            :     typedef GeometryData::IntegrationMethod IntegrationMethod;</a>
<a name="58"><span class="lineNum">      58 </span>            :     typedef IntegrationPoint&lt;2&gt; IntegrationPointType;</a>
<a name="59"><span class="lineNum">      59 </span>            :     typedef GeometryType::IntegrationPointsArrayType IntegrationPointsType;</a>
<a name="60"><span class="lineNum">      60 </span>            : </a>
<a name="61"><span class="lineNum">      61 </span>            :     /// The definition of the size type</a>
<a name="62"><span class="lineNum">      62 </span>            :     typedef std::size_t SizeType;</a>
<a name="63"><span class="lineNum">      63 </span>            : </a>
<a name="64"><span class="lineNum">      64 </span>            : ///@}</a>
<a name="65"><span class="lineNum">      65 </span>            : ///@name  Enum's</a>
<a name="66"><span class="lineNum">      66 </span>            : ///@{</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            : ///@}</a>
<a name="69"><span class="lineNum">      69 </span>            : ///@name  Functions</a>
<a name="70"><span class="lineNum">      70 </span>            : ///@{</a>
<a name="71"><span class="lineNum">      71 </span>            : </a>
<a name="72"><span class="lineNum">      72 </span>            : ///@}</a>
<a name="73"><span class="lineNum">      73 </span>            : ///@name Kratos Classes</a>
<a name="74"><span class="lineNum">      74 </span>            : ///@{</a>
<a name="75"><span class="lineNum">      75 </span>            : </a>
<a name="76"><span class="lineNum">      76 </span>            : /**</a>
<a name="77"><span class="lineNum">      77 </span>            :  * @class ExactMortarIntegrationUtility</a>
<a name="78"><span class="lineNum">      78 </span>            :  * @ingroup KratosCore</a>
<a name="79"><span class="lineNum">      79 </span>            :  * @brief This utility calculates the exact integration necessary for the Mortar Conditions</a>
<a name="80"><span class="lineNum">      80 </span>            :  * @details The utility performs a mortar segmentation in order to obtain the exact integration of the geometry intersected</a>
<a name="81"><span class="lineNum">      81 </span>            :  * @author Vicente Mataix Ferrandiz</a>
<a name="82"><span class="lineNum">      82 </span>            :  * @tparam TDim The dimension of work</a>
<a name="83"><span class="lineNum">      83 </span>            :  * @tparam TNumNodes The number of nodes of the slave</a>
<a name="84"><span class="lineNum">      84 </span>            :  * @tparam TBelong If we consider belonging of nodes or not. When you do the intersections in order to get the directional derivatives you need to know where the intersections belongs to calculate the derivatives. This says between which nodes the intersection belongs</a>
<a name="85"><span class="lineNum">      85 </span>            :  * @tparam TNumNodesMaster The number of nodes of the master</a>
<a name="86"><span class="lineNum">      86 </span>            :  */</a>
<a name="87"><span class="lineNum">      87 </span>            : template &lt;SizeType TDim, SizeType TNumNodes, bool TBelong = false, SizeType TNumNodesMaster = TNumNodes&gt;</a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 : class KRATOS_API(KRATOS_CORE) ExactMortarIntegrationUtility</span></a>
<a name="89"><span class="lineNum">      89 </span>            : {</a>
<a name="90"><span class="lineNum">      90 </span>            : public:</a>
<a name="91"><span class="lineNum">      91 </span>            :     ///@name Type Definitions</a>
<a name="92"><span class="lineNum">      92 </span>            :     ///@{</a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            :     /// The type of points belongfs to be considered</a>
<a name="95"><span class="lineNum">      95 </span>            :     typedef typename std::conditional&lt;TNumNodes == 2, PointBelongsLine2D2N, typename std::conditional&lt;TNumNodes == 3, typename std::conditional&lt;TNumNodesMaster == 3, PointBelongsTriangle3D3N, PointBelongsTriangle3D3NQuadrilateral3D4N&gt;::type, typename std::conditional&lt;TNumNodesMaster == 3, PointBelongsQuadrilateral3D4NTriangle3D3N, PointBelongsQuadrilateral3D4N&gt;::type&gt;::type&gt;::type BelongType;</a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            :     /// The definition of the point with belonging</a>
<a name="98"><span class="lineNum">      98 </span>            :     typedef PointBelong&lt;TNumNodes, TNumNodesMaster&gt; PointBelongType;</a>
<a name="99"><span class="lineNum">      99 </span>            : </a>
<a name="100"><span class="lineNum">     100 </span>            :     /// An array of points belong</a>
<a name="101"><span class="lineNum">     101 </span>            :     typedef std::vector&lt;array_1d&lt;PointBelongType, TDim&gt;&gt; VectorArrayPointsBelong;</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            :     /// A vector of points</a>
<a name="104"><span class="lineNum">     104 </span>            :     typedef std::vector&lt;array_1d&lt;PointType, TDim&gt;&gt; VectorArrayPoints;</a>
<a name="105"><span class="lineNum">     105 </span>            : </a>
<a name="106"><span class="lineNum">     106 </span>            :     /// The type of array of points to be considered depending if we are interested in derivatives or not</a>
<a name="107"><span class="lineNum">     107 </span>            :     typedef typename std::conditional&lt;TBelong, VectorArrayPointsBelong,VectorArrayPoints&gt;::type ConditionArrayListType;</a>
<a name="108"><span class="lineNum">     108 </span>            : </a>
<a name="109"><span class="lineNum">     109 </span>            :     /// A vector of points for derivatives</a>
<a name="110"><span class="lineNum">     110 </span>            :     typedef std::vector&lt;PointBelongType&gt; VectorPointsBelong;</a>
<a name="111"><span class="lineNum">     111 </span>            : </a>
<a name="112"><span class="lineNum">     112 </span>            :     /// A vector of normal points</a>
<a name="113"><span class="lineNum">     113 </span>            :     typedef std::vector&lt;PointType&gt; VectorPoints;</a>
<a name="114"><span class="lineNum">     114 </span>            : </a>
<a name="115"><span class="lineNum">     115 </span>            :     /// The type of vector of points to be considered depending if we are interested in define derivatives or not</a>
<a name="116"><span class="lineNum">     116 </span>            :     typedef typename std::conditional&lt;TBelong, VectorPointsBelong, VectorPoints&gt;::type PointListType;</a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span>            :     /// An array of points belong</a>
<a name="119"><span class="lineNum">     119 </span>            :     typedef array_1d&lt;PointBelongType, 3&gt; ArrayPointsBelong;</a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            :     /// An array of normal points</a>
<a name="122"><span class="lineNum">     122 </span>            :     typedef array_1d&lt;PointType, 3&gt; ArrayPoints;</a>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<a name="124"><span class="lineNum">     124 </span>            :     /// The type of arrayt of points to be used depending if we are interested in derivatives or not</a>
<a name="125"><span class="lineNum">     125 </span>            :     typedef typename std::conditional&lt;TBelong, ArrayPointsBelong, ArrayPoints&gt;::type ArrayTriangleType;</a>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<a name="127"><span class="lineNum">     127 </span>            :     /// The points line geometry</a>
<a name="128"><span class="lineNum">     128 </span>            :     typedef Line2D2&lt;Point&gt; LineType;</a>
<a name="129"><span class="lineNum">     129 </span>            : </a>
<a name="130"><span class="lineNum">     130 </span>            :     /// The points triangle geometry</a>
<a name="131"><span class="lineNum">     131 </span>            :     typedef Triangle3D3&lt;Point&gt; TriangleType;</a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            :     /// The geometry that will be considered for decomposition</a>
<a name="134"><span class="lineNum">     134 </span>            :     typedef typename std::conditional&lt;TDim == 2, LineType, TriangleType&gt;::type DecompositionType;</a>
<a name="135"><span class="lineNum">     135 </span>            : </a>
<a name="136"><span class="lineNum">     136 </span>            :     /// The definition of the index type</a>
<a name="137"><span class="lineNum">     137 </span>            :     typedef std::size_t IndexType;</a>
<a name="138"><span class="lineNum">     138 </span>            : </a>
<a name="139"><span class="lineNum">     139 </span>            :     /// Definition of epsilon</a>
<a name="140"><span class="lineNum">     140 </span>            :     static constexpr double ZeroTolerance = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            :     /// Pointer definition of ExactMortarIntegrationUtility</a>
<a name="143"><span class="lineNum">     143 </span>            :     KRATOS_CLASS_POINTER_DEFINITION(ExactMortarIntegrationUtility);</a>
<a name="144"><span class="lineNum">     144 </span>            : </a>
<a name="145"><span class="lineNum">     145 </span>            :     ///@}</a>
<a name="146"><span class="lineNum">     146 </span>            :     ///@name Life Cycle</a>
<a name="147"><span class="lineNum">     147 </span>            :     ///@{</a>
<a name="148"><span class="lineNum">     148 </span>            : </a>
<a name="149"><span class="lineNum">     149 </span>            :     /**</a>
<a name="150"><span class="lineNum">     150 </span>            :      * @brief This is the default constructor</a>
<a name="151"><span class="lineNum">     151 </span>            :      * @param IntegrationOrder The integration order to consider</a>
<a name="152"><span class="lineNum">     152 </span>            :      * @param DistanceThreshold The maximum distance to be considered (if too far the integration will be skiped)</a>
<a name="153"><span class="lineNum">     153 </span>            :      */</a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :     ExactMortarIntegrationUtility(</span></a>
<a name="155"><span class="lineNum">     155 </span>            :         const SizeType IntegrationOrder = 0,</a>
<a name="156"><span class="lineNum">     156 </span>            :         const double DistanceThreshold = std::numeric_limits&lt;double&gt;::max(),</a>
<a name="157"><span class="lineNum">     157 </span>            :         const SizeType EchoLevel = 0,</a>
<a name="158"><span class="lineNum">     158 </span>            :         const double ZeroToleranceFactor = 1.0,</a>
<a name="159"><span class="lineNum">     159 </span>            :         const bool ConsiderDelaunator = false</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :         ) :mIntegrationOrder(IntegrationOrder),</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineNoCov">          0 :            mDistanceThreshold(DistanceThreshold),</span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineNoCov">          0 :            mEchoLevel(EchoLevel),</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :            mZeroToleranceFactor(ZeroToleranceFactor),</span></a>
<a name="164"><span class="lineNum">     164 </span><span class="lineNoCov">          0 :            mConsiderDelaunator(ConsiderDelaunator)</span></a>
<a name="165"><span class="lineNum">     165 </span>            :     {</a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :         GetIntegrationMethod();</span></a>
<a name="167"><span class="lineNum">     167 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="168"><span class="lineNum">     168 </span>            : </a>
<a name="169"><span class="lineNum">     169 </span>            :     /// Destructor.</a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :     virtual ~ExactMortarIntegrationUtility() = default;</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span>            :     ///@}</a>
<a name="173"><span class="lineNum">     173 </span>            :     ///@name Operators</a>
<a name="174"><span class="lineNum">     174 </span>            :     ///@{</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span>            :     ///@}</a>
<a name="177"><span class="lineNum">     177 </span>            :     ///@name Operations</a>
<a name="178"><span class="lineNum">     178 </span>            :     ///@{</a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            :     /**</a>
<a name="181"><span class="lineNum">     181 </span>            :      * @brief This utility computes the exact integration of the mortar condition (just the points, not the whole integration points)</a>
<a name="182"><span class="lineNum">     182 </span>            :      * @param rOriginalSlaveGeometry The geometry of the slave condition</a>
<a name="183"><span class="lineNum">     183 </span>            :      * @param rSlaveNormal The normal of the slave condition</a>
<a name="184"><span class="lineNum">     184 </span>            :      * @param rOriginalMasterGeometry The geometry of the master condition</a>
<a name="185"><span class="lineNum">     185 </span>            :      * @param rMasterNormal The normal of the master condition</a>
<a name="186"><span class="lineNum">     186 </span>            :      * @param rConditionsPointsSlave The points that perform the exact integration</a>
<a name="187"><span class="lineNum">     187 </span>            :      * @return True if there is a common area (the geometries intersect), false otherwise</a>
<a name="188"><span class="lineNum">     188 </span>            :      */</a>
<a name="189"><span class="lineNum">     189 </span>            :     bool GetExactIntegration(</a>
<a name="190"><span class="lineNum">     190 </span>            :         const GeometryType&amp; rOriginalSlaveGeometry,</a>
<a name="191"><span class="lineNum">     191 </span>            :         const array_1d&lt;double, 3&gt;&amp; rSlaveNormal,</a>
<a name="192"><span class="lineNum">     192 </span>            :         const GeometryType&amp; rOriginalMasterGeometry,</a>
<a name="193"><span class="lineNum">     193 </span>            :         const array_1d&lt;double, 3&gt;&amp; rMasterNormal,</a>
<a name="194"><span class="lineNum">     194 </span>            :         ConditionArrayListType&amp; rConditionsPointsSlave</a>
<a name="195"><span class="lineNum">     195 </span>            :         );</a>
<a name="196"><span class="lineNum">     196 </span>            : </a>
<a name="197"><span class="lineNum">     197 </span>            :     /**</a>
<a name="198"><span class="lineNum">     198 </span>            :      * @brief This utility computes the exact integration of the mortar condition</a>
<a name="199"><span class="lineNum">     199 </span>            :      * @param rOriginalSlaveGeometry The geometry of the slave condition</a>
<a name="200"><span class="lineNum">     200 </span>            :      * @param rSlaveNormal The normal of the slave condition</a>
<a name="201"><span class="lineNum">     201 </span>            :      * @param rOriginalMasterGeometry The geometry of the master condition</a>
<a name="202"><span class="lineNum">     202 </span>            :      * @param rMasterNormal The normal of the master condition</a>
<a name="203"><span class="lineNum">     203 </span>            :      * @param rIntegrationPointsSlave The integrations points that belong to the slave</a>
<a name="204"><span class="lineNum">     204 </span>            :      * @return True if there is a common area (the geometries intersect), false otherwise</a>
<a name="205"><span class="lineNum">     205 </span>            :      */</a>
<a name="206"><span class="lineNum">     206 </span>            :     bool GetExactIntegration(</a>
<a name="207"><span class="lineNum">     207 </span>            :         const GeometryType&amp; rOriginalSlaveGeometry,</a>
<a name="208"><span class="lineNum">     208 </span>            :         const array_1d&lt;double, 3&gt;&amp; rSlaveNormal,</a>
<a name="209"><span class="lineNum">     209 </span>            :         const GeometryType&amp; rOriginalMasterGeometry,</a>
<a name="210"><span class="lineNum">     210 </span>            :         const array_1d&lt;double, 3&gt;&amp; rMasterNormal,</a>
<a name="211"><span class="lineNum">     211 </span>            :         IntegrationPointsType&amp; rIntegrationPointsSlave</a>
<a name="212"><span class="lineNum">     212 </span>            :         );</a>
<a name="213"><span class="lineNum">     213 </span>            : </a>
<a name="214"><span class="lineNum">     214 </span>            :     /**</a>
<a name="215"><span class="lineNum">     215 </span>            :      * @brief This utility computes the exact integration of the mortar condition and returns the area</a>
<a name="216"><span class="lineNum">     216 </span>            :      * @param rOriginalSlaveGeometry The geometry of the slave condition</a>
<a name="217"><span class="lineNum">     217 </span>            :      * @param rSlaveNormal The normal of the slave condition</a>
<a name="218"><span class="lineNum">     218 </span>            :      * @param rOriginalMasterGeometry The geometry of the master condition</a>
<a name="219"><span class="lineNum">     219 </span>            :      * @param rMasterNormal The normal of the master condition</a>
<a name="220"><span class="lineNum">     220 </span>            :      * @param rArea The total area integrated</a>
<a name="221"><span class="lineNum">     221 </span>            :      * @return True if there is a common area (the geometries intersect), false otherwise</a>
<a name="222"><span class="lineNum">     222 </span>            :      */</a>
<a name="223"><span class="lineNum">     223 </span>            :     bool GetExactAreaIntegration(</a>
<a name="224"><span class="lineNum">     224 </span>            :         const GeometryType&amp; rOriginalSlaveGeometry,</a>
<a name="225"><span class="lineNum">     225 </span>            :         const array_1d&lt;double, 3&gt;&amp; rSlaveNormal,</a>
<a name="226"><span class="lineNum">     226 </span>            :         const GeometryType&amp; rOriginalMasterGeometry,</a>
<a name="227"><span class="lineNum">     227 </span>            :         const array_1d&lt;double, 3&gt;&amp; rMasterNormal,</a>
<a name="228"><span class="lineNum">     228 </span>            :         double&amp; rArea</a>
<a name="229"><span class="lineNum">     229 </span>            :         );</a>
<a name="230"><span class="lineNum">     230 </span>            : </a>
<a name="231"><span class="lineNum">     231 </span>            :     /**</a>
<a name="232"><span class="lineNum">     232 </span>            :      * @brief It returns the total area inside the integration area</a>
<a name="233"><span class="lineNum">     233 </span>            :      * @param rOriginalSlaveGeometry The geometry of the slave condition</a>
<a name="234"><span class="lineNum">     234 </span>            :      * @param rConditionsPointsSlave The points that perform the exact integration</a>
<a name="235"><span class="lineNum">     235 </span>            :      * @param rArea The total area integrated</a>
<a name="236"><span class="lineNum">     236 </span>            :      */</a>
<a name="237"><span class="lineNum">     237 </span>            :     void GetTotalArea(</a>
<a name="238"><span class="lineNum">     238 </span>            :         const GeometryType&amp; rOriginalSlaveGeometry,</a>
<a name="239"><span class="lineNum">     239 </span>            :         ConditionArrayListType&amp; rConditionsPointsSlave,</a>
<a name="240"><span class="lineNum">     240 </span>            :         double&amp; rArea</a>
<a name="241"><span class="lineNum">     241 </span>            :         );</a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span>            :     /**</a>
<a name="244"><span class="lineNum">     244 </span>            :      * @brief This utility computes the exact integration of the mortar condition</a>
<a name="245"><span class="lineNum">     245 </span>            :      * @param pSlaveCond The slave condition</a>
<a name="246"><span class="lineNum">     246 </span>            :      * @param pMasterCond The master condition</a>
<a name="247"><span class="lineNum">     247 </span>            :      * @param rCustomSolution The matrix containing the integrations points that belong to the slave</a>
<a name="248"><span class="lineNum">     248 </span>            :      * @return True if there is a common area (the geometries intersect), false otherwise</a>
<a name="249"><span class="lineNum">     249 </span>            :      */</a>
<a name="250"><span class="lineNum">     250 </span>            :     bool TestGetExactIntegration(</a>
<a name="251"><span class="lineNum">     251 </span>            :         Condition::Pointer pSlaveCond,</a>
<a name="252"><span class="lineNum">     252 </span>            :         Condition::Pointer pMasterCond,</a>
<a name="253"><span class="lineNum">     253 </span>            :         Matrix&amp; rCustomSolution</a>
<a name="254"><span class="lineNum">     254 </span>            :         );</a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span>            : </a>
<a name="257"><span class="lineNum">     257 </span>            :     /**</a>
<a name="258"><span class="lineNum">     258 </span>            :      * @brief This utility computes the exact integration of the mortar condition and returns the area</a>
<a name="259"><span class="lineNum">     259 </span>            :      * @param pSlaveCond The slave condition</a>
<a name="260"><span class="lineNum">     260 </span>            :      * @param pMasterCond The master condition</a>
<a name="261"><span class="lineNum">     261 </span>            :      * @return The total area integrated</a>
<a name="262"><span class="lineNum">     262 </span>            :      */</a>
<a name="263"><span class="lineNum">     263 </span>            :     double TestGetExactAreaIntegration(</a>
<a name="264"><span class="lineNum">     264 </span>            :         Condition::Pointer pSlaveCond,</a>
<a name="265"><span class="lineNum">     265 </span>            :         Condition::Pointer pMasterCond</a>
<a name="266"><span class="lineNum">     266 </span>            :         );</a>
<a name="267"><span class="lineNum">     267 </span>            : </a>
<a name="268"><span class="lineNum">     268 </span>            : </a>
<a name="269"><span class="lineNum">     269 </span>            :     /**</a>
<a name="270"><span class="lineNum">     270 </span>            :      * @brief This utility computes the exact integration of the mortar condition and returns the area</a>
<a name="271"><span class="lineNum">     271 </span>            :      * @param rMainModelPart The main model part</a>
<a name="272"><span class="lineNum">     272 </span>            :      * @param pSlaveCond The slave condition</a>
<a name="273"><span class="lineNum">     273 </span>            :      * @return The total area integrated</a>
<a name="274"><span class="lineNum">     274 </span>            :      */</a>
<a name="275"><span class="lineNum">     275 </span>            :     double TestGetExactAreaIntegration(</a>
<a name="276"><span class="lineNum">     276 </span>            :         ModelPart&amp; rMainModelPart,</a>
<a name="277"><span class="lineNum">     277 </span>            :         Condition::Pointer pSlaveCond</a>
<a name="278"><span class="lineNum">     278 </span>            :         );</a>
<a name="279"><span class="lineNum">     279 </span>            : </a>
<a name="280"><span class="lineNum">     280 </span>            :     /**</a>
<a name="281"><span class="lineNum">     281 </span>            :      * @brief This method is used for debugging purposes. Generates a GiD mesh to check</a>
<a name="282"><span class="lineNum">     282 </span>            :      * @param rMainModelPart The main model part</a>
<a name="283"><span class="lineNum">     283 </span>            :      * @param IOConsidered The IO considered</a>
<a name="284"><span class="lineNum">     284 </span>            :      */</a>
<a name="285"><span class="lineNum">     285 </span>            :     void TestIODebug(</a>
<a name="286"><span class="lineNum">     286 </span>            :         ModelPart&amp; rMainModelPart,</a>
<a name="287"><span class="lineNum">     287 </span>            :         const std::string IOConsidered = &quot;GiD&quot;</a>
<a name="288"><span class="lineNum">     288 </span>            :         );</a>
<a name="289"><span class="lineNum">     289 </span>            : </a>
<a name="290"><span class="lineNum">     290 </span>            :     ///@}</a>
<a name="291"><span class="lineNum">     291 </span>            :     ///@name  Access</a>
<a name="292"><span class="lineNum">     292 </span>            :     ///@{</a>
<a name="293"><span class="lineNum">     293 </span>            : </a>
<a name="294"><span class="lineNum">     294 </span>            :     /**</a>
<a name="295"><span class="lineNum">     295 </span>            :      * @brief This method gets the current mIntegrationOrder</a>
<a name="296"><span class="lineNum">     296 </span>            :      * @return The integration order considered</a>
<a name="297"><span class="lineNum">     297 </span>            :      */</a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :     SizeType&amp; GetIntegrationOrder()</span></a>
<a name="299"><span class="lineNum">     299 </span>            :     {</a>
<a name="300"><span class="lineNum">     300 </span><span class="lineNoCov">          0 :         return mIntegrationOrder;</span></a>
<a name="301"><span class="lineNum">     301 </span>            :     }</a>
<a name="302"><span class="lineNum">     302 </span>            : </a>
<a name="303"><span class="lineNum">     303 </span>            :     /**</a>
<a name="304"><span class="lineNum">     304 </span>            :      * @brief This method sets the current mIntegrationOrder</a>
<a name="305"><span class="lineNum">     305 </span>            :      * @param IntegrationOrder The integration order considered</a>
<a name="306"><span class="lineNum">     306 </span>            :      */</a>
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 :     void SetIntegrationOrder(const SizeType IntegrationOrder)</span></a>
<a name="308"><span class="lineNum">     308 </span>            :     {</a>
<a name="309"><span class="lineNum">     309 </span><span class="lineNoCov">          0 :         mIntegrationOrder = IntegrationOrder;</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :         GetIntegrationMethod();</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="312"><span class="lineNum">     312 </span>            : </a>
<a name="313"><span class="lineNum">     313 </span>            :     /**</a>
<a name="314"><span class="lineNum">     314 </span>            :      * @brief This method gets the current mDistanceThreshold</a>
<a name="315"><span class="lineNum">     315 </span>            :      * @return The distance threshold considered</a>
<a name="316"><span class="lineNum">     316 </span>            :      */</a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :     double&amp; GetDistanceThreshold()</span></a>
<a name="318"><span class="lineNum">     318 </span>            :     {</a>
<a name="319"><span class="lineNum">     319 </span><span class="lineNoCov">          0 :         return mDistanceThreshold;</span></a>
<a name="320"><span class="lineNum">     320 </span>            :     }</a>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<a name="322"><span class="lineNum">     322 </span>            :     /**</a>
<a name="323"><span class="lineNum">     323 </span>            :      * @brief This method sets the current mDistanceThreshold</a>
<a name="324"><span class="lineNum">     324 </span>            :      * @param DistanceThreshold The distance threshold considered</a>
<a name="325"><span class="lineNum">     325 </span>            :      */</a>
<a name="326"><span class="lineNum">     326 </span><span class="lineNoCov">          0 :     void SetDistanceThreshold(const double DistanceThreshold)</span></a>
<a name="327"><span class="lineNum">     327 </span>            :     {</a>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :         mDistanceThreshold = DistanceThreshold;</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="330"><span class="lineNum">     330 </span>            : </a>
<a name="331"><span class="lineNum">     331 </span>            :     /**</a>
<a name="332"><span class="lineNum">     332 </span>            :      * @brief This method gets the current mEchoLevel</a>
<a name="333"><span class="lineNum">     333 </span>            :      * @return The echo level considered</a>
<a name="334"><span class="lineNum">     334 </span>            :      */</a>
<a name="335"><span class="lineNum">     335 </span><span class="lineNoCov">          0 :     SizeType&amp; GetEchoLevel()</span></a>
<a name="336"><span class="lineNum">     336 </span>            :     {</a>
<a name="337"><span class="lineNum">     337 </span><span class="lineNoCov">          0 :         return mEchoLevel;</span></a>
<a name="338"><span class="lineNum">     338 </span>            :     }</a>
<a name="339"><span class="lineNum">     339 </span>            : </a>
<a name="340"><span class="lineNum">     340 </span>            :     /**</a>
<a name="341"><span class="lineNum">     341 </span>            :      * @brief This method sets the current mEchoLevel</a>
<a name="342"><span class="lineNum">     342 </span>            :      * @param EchoLevel The echo level considered</a>
<a name="343"><span class="lineNum">     343 </span>            :      */</a>
<a name="344"><span class="lineNum">     344 </span><span class="lineNoCov">          0 :     void SetEchoLevel(const SizeType EchoLevel)</span></a>
<a name="345"><span class="lineNum">     345 </span>            :     {</a>
<a name="346"><span class="lineNum">     346 </span><span class="lineNoCov">          0 :         mEchoLevel = EchoLevel;</span></a>
<a name="347"><span class="lineNum">     347 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span>            :     /**</a>
<a name="350"><span class="lineNum">     350 </span>            :      * @brief This method gets the current mZeroToleranceFactor</a>
<a name="351"><span class="lineNum">     351 </span>            :      * @return The zero tolerance factor considered</a>
<a name="352"><span class="lineNum">     352 </span>            :      */</a>
<a name="353"><span class="lineNum">     353 </span><span class="lineNoCov">          0 :     double&amp; GetZeroToleranceFactor()</span></a>
<a name="354"><span class="lineNum">     354 </span>            :     {</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :         return mZeroToleranceFactor;</span></a>
<a name="356"><span class="lineNum">     356 </span>            :     }</a>
<a name="357"><span class="lineNum">     357 </span>            : </a>
<a name="358"><span class="lineNum">     358 </span>            :     /**</a>
<a name="359"><span class="lineNum">     359 </span>            :      * @brief This method sets the current mZeroToleranceFactor</a>
<a name="360"><span class="lineNum">     360 </span>            :      * @param ZeroToleranceFactor The zero tolerance factor considered</a>
<a name="361"><span class="lineNum">     361 </span>            :      */</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 :     void SetZeroToleranceFactor(const double ZeroToleranceFactor)</span></a>
<a name="363"><span class="lineNum">     363 </span>            :     {</a>
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 :         mZeroToleranceFactor = ZeroToleranceFactor;</span></a>
<a name="365"><span class="lineNum">     365 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<a name="367"><span class="lineNum">     367 </span>            :     /**</a>
<a name="368"><span class="lineNum">     368 </span>            :      * @brief This method gets the current mConsiderDelaunator</a>
<a name="369"><span class="lineNum">     369 </span>            :      * @return If considering delaunator</a>
<a name="370"><span class="lineNum">     370 </span>            :      */</a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :     bool&amp; GetConsiderDelaunator()</span></a>
<a name="372"><span class="lineNum">     372 </span>            :     {</a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :         return mConsiderDelaunator;</span></a>
<a name="374"><span class="lineNum">     374 </span>            :     }</a>
<a name="375"><span class="lineNum">     375 </span>            : </a>
<a name="376"><span class="lineNum">     376 </span>            :     /**</a>
<a name="377"><span class="lineNum">     377 </span>            :      * @brief This method sets the current mConsiderDelaunator</a>
<a name="378"><span class="lineNum">     378 </span>            :      * @param ConsiderDelaunator If considering delaunator</a>
<a name="379"><span class="lineNum">     379 </span>            :      */</a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :     void SetConsiderDelaunator(const bool ConsiderDelaunator)</span></a>
<a name="381"><span class="lineNum">     381 </span>            :     {</a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :         mConsiderDelaunator = ConsiderDelaunator;</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="384"><span class="lineNum">     384 </span>            : </a>
<a name="385"><span class="lineNum">     385 </span>            :     ///@}</a>
<a name="386"><span class="lineNum">     386 </span>            : protected:</a>
<a name="387"><span class="lineNum">     387 </span>            :     ///@name Protected static Member Variables</a>
<a name="388"><span class="lineNum">     388 </span>            :     ///@{</a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span>            :     ///@}</a>
<a name="391"><span class="lineNum">     391 </span>            :     ///@name Protected member Variables</a>
<a name="392"><span class="lineNum">     392 </span>            :     ///@{</a>
<a name="393"><span class="lineNum">     393 </span>            : </a>
<a name="394"><span class="lineNum">     394 </span>            :     ///@}</a>
<a name="395"><span class="lineNum">     395 </span>            :     ///@name Protected Operators</a>
<a name="396"><span class="lineNum">     396 </span>            :     ///@{</a>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<a name="398"><span class="lineNum">     398 </span>            :     ///@}</a>
<a name="399"><span class="lineNum">     399 </span>            :     ///@name Protected Operations</a>
<a name="400"><span class="lineNum">     400 </span>            :     ///@{</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span>            :     /**</a>
<a name="403"><span class="lineNum">     403 </span>            :      * @brief Get the integration method to consider</a>
<a name="404"><span class="lineNum">     404 </span>            :      */</a>
<a name="405"><span class="lineNum">     405 </span>            :     void GetIntegrationMethod();</a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :     /**</a>
<a name="408"><span class="lineNum">     408 </span>            :      * @brief Get the integration method to consider</a>
<a name="409"><span class="lineNum">     409 </span>            :      */</a>
<a name="410"><span class="lineNum">     410 </span>            :     GeometryType::IntegrationPointsArrayType GetIntegrationTriangle();</a>
<a name="411"><span class="lineNum">     411 </span>            : </a>
<a name="412"><span class="lineNum">     412 </span>            :     /**</a>
<a name="413"><span class="lineNum">     413 </span>            :      * @brief This method checks if the whole array is true</a>
<a name="414"><span class="lineNum">     414 </span>            :      * @param rAllInside The nodes that are inside or not the geometry</a>
<a name="415"><span class="lineNum">     415 </span>            :      * @return True if all the nodes are inside, false otherwise</a>
<a name="416"><span class="lineNum">     416 </span>            :      */</a>
<a name="417"><span class="lineNum">     417 </span>            :     template&lt;SizeType TSizeCheck = TNumNodes&gt;</a>
<a name="418"><span class="lineNum">     418 </span>            :     static inline bool CheckAllInside(const array_1d&lt;bool, TSizeCheck&gt;&amp; rAllInside)</a>
<a name="419"><span class="lineNum">     419 </span>            :     {</a>
<a name="420"><span class="lineNum">     420 </span><span class="lineNoCov">          0 :         for (IndexType i_node = 0; i_node &lt; TSizeCheck; ++i_node)</span></a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :             if (!rAllInside[i_node])</span></a>
<a name="422"><span class="lineNum">     422 </span>            :                 return false;</a>
<a name="423"><span class="lineNum">     423 </span>            : </a>
<a name="424"><span class="lineNum">     424 </span>            :         return true;</a>
<a name="425"><span class="lineNum">     425 </span>            :     }</a>
<a name="426"><span class="lineNum">     426 </span>            : </a>
<a name="427"><span class="lineNum">     427 </span>            :     /**</a>
<a name="428"><span class="lineNum">     428 </span>            :      * @brief This function intersects two lines in a 2D plane</a>
<a name="429"><span class="lineNum">     429 </span>            :      * @param rPointOrig1 The first point from the origin geometry</a>
<a name="430"><span class="lineNum">     430 </span>            :      * @param rPointOrig2 The second point from the origin geometry</a>
<a name="431"><span class="lineNum">     431 </span>            :      * @param rPointDest1 The first point in the destination geometry</a>
<a name="432"><span class="lineNum">     432 </span>            :      * @param rPointDest2 The second point in the destination geometry</a>
<a name="433"><span class="lineNum">     433 </span>            :      * @param rPointIntersection The intersection point if there is any</a>
<a name="434"><span class="lineNum">     434 </span>            :      * @return True if there is a intersection point, false otherwise</a>
<a name="435"><span class="lineNum">     435 </span>            :      */</a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :     static inline bool Clipping2D(</span></a>
<a name="437"><span class="lineNum">     437 </span>            :         PointType&amp; rPointIntersection,</a>
<a name="438"><span class="lineNum">     438 </span>            :         const PointType&amp; rPointOrig1,</a>
<a name="439"><span class="lineNum">     439 </span>            :         const PointType&amp; rPointOrig2,</a>
<a name="440"><span class="lineNum">     440 </span>            :         const PointType&amp; rPointDest1,</a>
<a name="441"><span class="lineNum">     441 </span>            :         const PointType&amp; rPointDest2</a>
<a name="442"><span class="lineNum">     442 </span>            :         )</a>
<a name="443"><span class="lineNum">     443 </span>            :     {</a>
<a name="444"><span class="lineNum">     444 </span>            :         const array_1d&lt;double, 3&gt;&amp; r_coord_point_orig1 = rPointOrig1.Coordinates();</a>
<a name="445"><span class="lineNum">     445 </span>            :         const array_1d&lt;double, 3&gt;&amp; r_coord_point_orig2 = rPointOrig2.Coordinates();</a>
<a name="446"><span class="lineNum">     446 </span>            :         const array_1d&lt;double, 3&gt;&amp; r_coord_point_dest1 = rPointDest1.Coordinates();</a>
<a name="447"><span class="lineNum">     447 </span>            :         const array_1d&lt;double, 3&gt;&amp; r_coord_point_dest2 = rPointDest2.Coordinates();</a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :         const double s_orig1_orig2_x = r_coord_point_orig2[0] - r_coord_point_orig1[0];</span></a>
<a name="450"><span class="lineNum">     450 </span><span class="lineNoCov">          0 :         const double s_orig1_orig2_y = r_coord_point_orig2[1] - r_coord_point_orig1[1];</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 :         const double s_dest1_dest2_x = r_coord_point_dest2[0] - r_coord_point_dest1[0];</span></a>
<a name="452"><span class="lineNum">     452 </span><span class="lineNoCov">          0 :         const double s_dest1_dest2_y = r_coord_point_dest2[1] - r_coord_point_dest1[1];</span></a>
<a name="453"><span class="lineNum">     453 </span>            : </a>
<a name="454"><span class="lineNum">     454 </span><span class="lineNoCov">          0 :         const double denom = s_orig1_orig2_x * s_dest1_dest2_y -</span></a>
<a name="455"><span class="lineNum">     455 </span><span class="lineNoCov">          0 :                              s_dest1_dest2_x * s_orig1_orig2_y;</span></a>
<a name="456"><span class="lineNum">     456 </span>            : </a>
<a name="457"><span class="lineNum">     457 </span>            :         const double tolerance = 1.0e-15;</a>
<a name="458"><span class="lineNum">     458 </span>            : //         const double tolerance = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="459"><span class="lineNum">     459 </span>            : </a>
<a name="460"><span class="lineNum">     460 </span><span class="lineNoCov">          0 :         if (std::abs(denom) &lt; tolerance) // NOTE: Collinear</span></a>
<a name="461"><span class="lineNum">     461 </span>            :             return false;</a>
<a name="462"><span class="lineNum">     462 </span>            : </a>
<a name="463"><span class="lineNum">     463 </span><span class="lineNoCov">          0 :         const double s_orig1_dest1_x = r_coord_point_orig1[0] - r_coord_point_dest1[0];</span></a>
<a name="464"><span class="lineNum">     464 </span><span class="lineNoCov">          0 :         const double s_orig1_dest1_y = r_coord_point_orig1[1] - r_coord_point_dest1[1];</span></a>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<a name="466"><span class="lineNum">     466 </span><span class="lineNoCov">          0 :         const double s = (s_orig1_orig2_x * s_orig1_dest1_y - s_orig1_orig2_y * s_orig1_dest1_x)/denom;</span></a>
<a name="467"><span class="lineNum">     467 </span>            : </a>
<a name="468"><span class="lineNum">     468 </span><span class="lineNoCov">          0 :         const double t = (s_dest1_dest2_x * s_orig1_dest1_y - s_dest1_dest2_y * s_orig1_dest1_x)/denom;</span></a>
<a name="469"><span class="lineNum">     469 </span>            : </a>
<a name="470"><span class="lineNum">     470 </span><span class="lineNoCov">          0 :         if (s &gt;= -tolerance &amp;&amp; s &lt;= (1.0 + tolerance) &amp;&amp; t &gt;= -tolerance &amp;&amp; t &lt;= (1.0 + tolerance)) {</span></a>
<a name="471"><span class="lineNum">     471 </span><span class="lineNoCov">          0 :             rPointIntersection.Coordinates()[0] = r_coord_point_orig1[0] + t * s_orig1_orig2_x;</span></a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :             rPointIntersection.Coordinates()[1] = r_coord_point_orig1[1] + t * s_orig1_orig2_y;</span></a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span><span class="lineNoCov">          0 :             return true;</span></a>
<a name="475"><span class="lineNum">     475 </span>            :         } else</a>
<a name="476"><span class="lineNum">     476 </span>            :             return false;</a>
<a name="477"><span class="lineNum">     477 </span>            :     }</a>
<a name="478"><span class="lineNum">     478 </span>            : </a>
<a name="479"><span class="lineNum">     479 </span>            :     /**</a>
<a name="480"><span class="lineNum">     480 </span>            :      * @brief This function calculates in 2D the normal vector to a given one</a>
<a name="481"><span class="lineNum">     481 </span>            :      * @param rVector The vector to compute the normal</a>
<a name="482"><span class="lineNum">     482 </span>            :      * @return normal The normal vector</a>
<a name="483"><span class="lineNum">     483 </span>            :      */</a>
<a name="484"><span class="lineNum">     484 </span><span class="lineNoCov">          0 :     static inline array_1d&lt;double, 3&gt; GetNormalVector2D(const array_1d&lt;double, 3&gt;&amp; rVector)</span></a>
<a name="485"><span class="lineNum">     485 </span>            :     {</a>
<a name="486"><span class="lineNum">     486 </span>            :         array_1d&lt;double, 3&gt; normal;</a>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span><span class="lineNoCov">          0 :         normal[0] = -rVector[1];</span></a>
<a name="489"><span class="lineNum">     489 </span><span class="lineNoCov">          0 :         normal[1] = rVector[0];</span></a>
<a name="490"><span class="lineNum">     490 </span><span class="lineNoCov">          0 :         normal[2] = 0.0;</span></a>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<a name="492"><span class="lineNum">     492 </span><span class="lineNoCov">          0 :         return normal;</span></a>
<a name="493"><span class="lineNum">     493 </span>            :     }</a>
<a name="494"><span class="lineNum">     494 </span>            : </a>
<a name="495"><span class="lineNum">     495 </span>            :     /**</a>
<a name="496"><span class="lineNum">     496 </span>            :      * @brief This function calculates in 2D the angle between two points</a>
<a name="497"><span class="lineNum">     497 </span>            :      * @param rPointOrig1 The points from the origin geometry</a>
<a name="498"><span class="lineNum">     498 </span>            :      * @param rPointOrig2 The points in the destination geometry</a>
<a name="499"><span class="lineNum">     499 </span>            :      * @param rAxis1 The axis respect the angle is calculated</a>
<a name="500"><span class="lineNum">     500 </span>            :      * @param rAxis2 The normal to the previous axis</a>
<a name="501"><span class="lineNum">     501 </span>            :      * @return angle The angle formed</a>
<a name="502"><span class="lineNum">     502 </span>            :      */</a>
<a name="503"><span class="lineNum">     503 </span><span class="lineNoCov">          0 :     static inline double AnglePoints(</span></a>
<a name="504"><span class="lineNum">     504 </span>            :         const PointType&amp; rPointOrig1,</a>
<a name="505"><span class="lineNum">     505 </span>            :         const PointType&amp; rPointOrig2,</a>
<a name="506"><span class="lineNum">     506 </span>            :         const array_1d&lt;double, 3&gt;&amp; rAxis1,</a>
<a name="507"><span class="lineNum">     507 </span>            :         const array_1d&lt;double, 3&gt;&amp; rAxis2</a>
<a name="508"><span class="lineNum">     508 </span>            :         )</a>
<a name="509"><span class="lineNum">     509 </span>            :     {</a>
<a name="510"><span class="lineNum">     510 </span>            :         array_1d&lt;double, 3&gt; local_edge = rPointOrig2.Coordinates() - rPointOrig1.Coordinates();</a>
<a name="511"><span class="lineNum">     511 </span><span class="lineNoCov">          0 :         if (norm_2(local_edge) &gt; 0.0)</span></a>
<a name="512"><span class="lineNum">     512 </span>            :             local_edge /= norm_2(local_edge);</a>
<a name="513"><span class="lineNum">     513 </span>            : </a>
<a name="514"><span class="lineNum">     514 </span>            :         const double xi  = inner_prod(rAxis1, local_edge);</a>
<a name="515"><span class="lineNum">     515 </span>            :         const double eta = inner_prod(rAxis2, local_edge);</a>
<a name="516"><span class="lineNum">     516 </span>            : </a>
<a name="517"><span class="lineNum">     517 </span><span class="lineNoCov">          0 :         return (std::atan2(eta, xi));</span></a>
<a name="518"><span class="lineNum">     518 </span>            :     }</a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            :     /**</a>
<a name="521"><span class="lineNum">     521 </span>            :      * @brief This function checks if two points are the same one</a>
<a name="522"><span class="lineNum">     522 </span>            :      * @param rPointOrig The points from the origin geometry</a>
<a name="523"><span class="lineNum">     523 </span>            :      * @param rPointDest The points in the destination geometry</a>
<a name="524"><span class="lineNum">     524 </span>            :      * @return check The check done</a>
<a name="525"><span class="lineNum">     525 </span>            :      */</a>
<a name="526"><span class="lineNum">     526 </span><span class="lineNoCov">          0 :     static inline bool CheckPoints(</span></a>
<a name="527"><span class="lineNum">     527 </span>            :         const PointType&amp; rPointOrig,</a>
<a name="528"><span class="lineNum">     528 </span>            :         const PointType&amp; rPointDest</a>
<a name="529"><span class="lineNum">     529 </span>            :         )</a>
<a name="530"><span class="lineNum">     530 </span>            :     {</a>
<a name="531"><span class="lineNum">     531 </span>            : //         const double tolerance = std::numeric_limits&lt;double&gt;::epsilon(); // NOTE: Giving some problems, too tight</a>
<a name="532"><span class="lineNum">     532 </span>            :         const double tolerance = 1.0e-15;</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineNoCov">          0 :         return rPointDest.Distance(rPointOrig) &lt; tolerance;</span></a>
<a name="534"><span class="lineNum">     534 </span>            :     }</a>
<a name="535"><span class="lineNum">     535 </span>            : </a>
<a name="536"><span class="lineNum">     536 </span>            :     /**</a>
<a name="537"><span class="lineNum">     537 </span>            :      * @brief This functions calculates the determinant of a 2D triangle (using points) to check if invert the order</a>
<a name="538"><span class="lineNum">     538 </span>            :      * @param rPointOrig1 First point</a>
<a name="539"><span class="lineNum">     539 </span>            :      * @param rPointOrig2 Second point</a>
<a name="540"><span class="lineNum">     540 </span>            :      * @param rPointOrig3 Third point</a>
<a name="541"><span class="lineNum">     541 </span>            :      * @return The DetJ</a>
<a name="542"><span class="lineNum">     542 </span>            :      */</a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 :     static inline double FastTriagleCheck2D(</span></a>
<a name="544"><span class="lineNum">     544 </span>            :         const PointType&amp; rPointOrig1,</a>
<a name="545"><span class="lineNum">     545 </span>            :         const PointType&amp; rPointOrig2,</a>
<a name="546"><span class="lineNum">     546 </span>            :         const PointType&amp; rPointOrig3</a>
<a name="547"><span class="lineNum">     547 </span>            :         )</a>
<a name="548"><span class="lineNum">     548 </span>            :     {</a>
<a name="549"><span class="lineNum">     549 </span><span class="lineNoCov">          0 :         const double x10 = rPointOrig2.X() - rPointOrig1.X();</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineNoCov">          0 :         const double y10 = rPointOrig2.Y() - rPointOrig1.Y();</span></a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span><span class="lineNoCov">          0 :         const double x20 = rPointOrig3.X() - rPointOrig1.X();</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineNoCov">          0 :         const double y20 = rPointOrig3.Y() - rPointOrig1.Y();</span></a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span>            :         //Jacobian is calculated:</a>
<a name="556"><span class="lineNum">     556 </span>            :         //  |dx/dxi  dx/deta|   |x1-x0   x2-x0|</a>
<a name="557"><span class="lineNum">     557 </span>            :         //J=|               |=  |                 |</a>
<a name="558"><span class="lineNum">     558 </span>            :         //  |dy/dxi  dy/deta|   |y1-y0   y2-y0|</a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span><span class="lineNoCov">          0 :         return x10 * y20 - y10 * x20;</span></a>
<a name="561"><span class="lineNum">     561 </span>            :     }</a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<a name="563"><span class="lineNum">     563 </span>            :     /**</a>
<a name="564"><span class="lineNum">     564 </span>            :      * @brief This function push backs the points that are inside</a>
<a name="565"><span class="lineNum">     565 </span>            :      * @param rPointList The intersection points</a>
<a name="566"><span class="lineNum">     566 </span>            :      * @param rAllInside The nodes that are already known as inside the other geometry</a>
<a name="567"><span class="lineNum">     567 </span>            :      * @param rThisGeometry The geometry considered</a>
<a name="568"><span class="lineNum">     568 </span>            :      */</a>
<a name="569"><span class="lineNum">     569 </span>            :     template&lt;SizeType TSizeCheck = TNumNodes&gt;</a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :     inline void PushBackPoints(</span></a>
<a name="571"><span class="lineNum">     571 </span>            :         VectorPoints&amp; rPointList,</a>
<a name="572"><span class="lineNum">     572 </span>            :         const array_1d&lt;bool, TSizeCheck&gt;&amp; rAllInside,</a>
<a name="573"><span class="lineNum">     573 </span>            :         GeometryPointType&amp; rThisGeometry</a>
<a name="574"><span class="lineNum">     574 </span>            :         )</a>
<a name="575"><span class="lineNum">     575 </span>            :     {</a>
<a name="576"><span class="lineNum">     576 </span><span class="lineNoCov">          0 :         for (IndexType i_node = 0; i_node &lt; TSizeCheck; ++i_node) {</span></a>
<a name="577"><span class="lineNum">     577 </span><span class="lineNoCov">          0 :             if (rAllInside[i_node]) {</span></a>
<a name="578"><span class="lineNum">     578 </span>            :                 // We check if the node already exists</a>
<a name="579"><span class="lineNum">     579 </span>            :                 bool add_point = true;</a>
<a name="580"><span class="lineNum">     580 </span><span class="lineNoCov">          0 :                 for (IndexType iter = 0; iter &lt; rPointList.size(); ++iter)</span></a>
<a name="581"><span class="lineNum">     581 </span><span class="lineNoCov">          0 :                     if (CheckPoints(rThisGeometry[i_node], rPointList[iter])) add_point = false;</span></a>
<a name="582"><span class="lineNum">     582 </span>            : </a>
<a name="583"><span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 if (add_point)</span></a>
<a name="584"><span class="lineNum">     584 </span><span class="lineNoCov">          0 :                     rPointList.push_back(rThisGeometry[i_node]);</span></a>
<a name="585"><span class="lineNum">     585 </span>            :             }</a>
<a name="586"><span class="lineNum">     586 </span>            :         }</a>
<a name="587"><span class="lineNum">     587 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span>            :     /**</a>
<a name="590"><span class="lineNum">     590 </span>            :      * @brief This function push backs the points that are inside</a>
<a name="591"><span class="lineNum">     591 </span>            :      * @param rPointList The intersection points</a>
<a name="592"><span class="lineNum">     592 </span>            :      * @param rAllInside The nodes that are already known as inside the other geometry</a>
<a name="593"><span class="lineNum">     593 </span>            :      * @param rThisGeometry The geometry considered</a>
<a name="594"><span class="lineNum">     594 </span>            :      * @param rThisBelongs This determine where it belongs each intersection</a>
<a name="595"><span class="lineNum">     595 </span>            :      */</a>
<a name="596"><span class="lineNum">     596 </span>            :     template&lt;SizeType TSizeCheck = TNumNodes&gt;</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :     inline void PushBackPoints(</span></a>
<a name="598"><span class="lineNum">     598 </span>            :         VectorPointsBelong&amp; rPointList,</a>
<a name="599"><span class="lineNum">     599 </span>            :         const array_1d&lt;bool, TSizeCheck&gt;&amp; rAllInside,</a>
<a name="600"><span class="lineNum">     600 </span>            :         GeometryPointType&amp; rThisGeometry,</a>
<a name="601"><span class="lineNum">     601 </span>            :         const PointBelongs&amp; rThisBelongs</a>
<a name="602"><span class="lineNum">     602 </span>            :         )</a>
<a name="603"><span class="lineNum">     603 </span>            :     {</a>
<a name="604"><span class="lineNum">     604 </span><span class="lineNoCov">          0 :         for (IndexType i_node = 0; i_node &lt; TSizeCheck; ++i_node) {</span></a>
<a name="605"><span class="lineNum">     605 </span><span class="lineNoCov">          0 :             if (rAllInside[i_node]) {</span></a>
<a name="606"><span class="lineNum">     606 </span>            :                 // We check if the node already exists</a>
<a name="607"><span class="lineNum">     607 </span>            :                 bool add_point = true;</a>
<a name="608"><span class="lineNum">     608 </span><span class="lineNoCov">          0 :                 for (IndexType iter = 0; iter &lt; rPointList.size(); ++iter) {</span></a>
<a name="609"><span class="lineNum">     609 </span><span class="lineNoCov">          0 :                     if (CheckPoints(rThisGeometry[i_node], rPointList[iter])) {</span></a>
<a name="610"><span class="lineNum">     610 </span>            :                         add_point = false;</a>
<a name="611"><span class="lineNum">     611 </span>            :                     }</a>
<a name="612"><span class="lineNum">     612 </span>            :                 }</a>
<a name="613"><span class="lineNum">     613 </span>            : </a>
<a name="614"><span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 if (add_point) {</span></a>
<a name="615"><span class="lineNum">     615 </span><span class="lineNoCov">          0 :                     const IndexType initial_index = (rThisBelongs == PointBelongs::Master) ? TNumNodes : 0;</span></a>
<a name="616"><span class="lineNum">     616 </span><span class="lineNoCov">          0 :                     rPointList.push_back(PointBelong&lt;TNumNodes, TNumNodesMaster&gt;(rThisGeometry[i_node].Coordinates(), static_cast&lt;BelongType&gt;(initial_index + i_node)));</span></a>
<a name="617"><span class="lineNum">     617 </span>            :                 }</a>
<a name="618"><span class="lineNum">     618 </span>            :             }</a>
<a name="619"><span class="lineNum">     619 </span>            :         }</a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="621"><span class="lineNum">     621 </span>            : </a>
<a name="622"><span class="lineNum">     622 </span>            :     /**</a>
<a name="623"><span class="lineNum">     623 </span>            :      * @brief This function checks if the points of Geometry2 are inside Geometry1</a>
<a name="624"><span class="lineNum">     624 </span>            :      * @param rAllInside The nodes that are inside or not the geometry</a>
<a name="625"><span class="lineNum">     625 </span>            :      * @param rGeometry1 The geometry where the points are checked</a>
<a name="626"><span class="lineNum">     626 </span>            :      * @param rGeometry2 The geometry to check</a>
<a name="627"><span class="lineNum">     627 </span>            :      */</a>
<a name="628"><span class="lineNum">     628 </span>            :     template&lt;SizeType TSizeCheck = TNumNodes&gt;</a>
<a name="629"><span class="lineNum">     629 </span>            :     inline void CheckInside(</a>
<a name="630"><span class="lineNum">     630 </span>            :         array_1d&lt;bool, TSizeCheck&gt;&amp; rAllInside,</a>
<a name="631"><span class="lineNum">     631 </span>            :         GeometryPointType&amp; rGeometry1,</a>
<a name="632"><span class="lineNum">     632 </span>            :         GeometryPointType&amp; rGeometry2,</a>
<a name="633"><span class="lineNum">     633 </span>            :         const double Tolerance</a>
<a name="634"><span class="lineNum">     634 </span>            :         )</a>
<a name="635"><span class="lineNum">     635 </span>            :     {</a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :         for (IndexType i_node = 0; i_node &lt; TSizeCheck; ++i_node) {</span></a>
<a name="637"><span class="lineNum">     637 </span>            :             GeometryType::CoordinatesArrayType projected_gp_local;</a>
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 :             rAllInside[i_node] = rGeometry1.IsInside( rGeometry2[i_node].Coordinates( ), projected_gp_local, Tolerance) ;</span></a>
<a name="639"><span class="lineNum">     639 </span>            :         }</a>
<a name="640"><span class="lineNum">     640 </span>            :     }</a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :     /**</a>
<a name="643"><span class="lineNum">     643 </span>            :      * @brief This function computes the angles indexes</a>
<a name="644"><span class="lineNum">     644 </span>            :      * @param rPointList The intersection points</a>
<a name="645"><span class="lineNum">     645 </span>            :      * @param rNormal The normal vector</a>
<a name="646"><span class="lineNum">     646 </span>            :      */</a>
<a name="647"><span class="lineNum">     647 </span>            :     inline std::vector&lt;IndexType&gt; ComputeAnglesIndexes(</a>
<a name="648"><span class="lineNum">     648 </span>            :         PointListType&amp; rPointList,</a>
<a name="649"><span class="lineNum">     649 </span>            :         const array_1d&lt;double, 3&gt;&amp; rNormal</a>
<a name="650"><span class="lineNum">     650 </span>            :         ) const;</a>
<a name="651"><span class="lineNum">     651 </span>            : </a>
<a name="652"><span class="lineNum">     652 </span>            :     /**</a>
<a name="653"><span class="lineNum">     653 </span>            :      * @brief This function computes the angles indexes</a>
<a name="654"><span class="lineNum">     654 </span>            :      * @param rPointList The intersection points</a>
<a name="655"><span class="lineNum">     655 </span>            :      * @param rSlaveGeometry The first (slave) geometry studied (projected)</a>
<a name="656"><span class="lineNum">     656 </span>            :      * @param rMasterGeometry The second (master) geometry studied (projected)</a>
<a name="657"><span class="lineNum">     657 </span>            :      * @param rRefCenter The reference point to rotate</a>
<a name="658"><span class="lineNum">     658 </span>            :      */</a>
<a name="659"><span class="lineNum">     659 </span>            :     inline void ComputeClippingIntersections(</a>
<a name="660"><span class="lineNum">     660 </span>            :         PointListType&amp; rPointList,</a>
<a name="661"><span class="lineNum">     661 </span>            :         const GeometryPointType&amp; rSlaveGeometry,</a>
<a name="662"><span class="lineNum">     662 </span>            :         const GeometryPointType&amp; rMasterGeometry,</a>
<a name="663"><span class="lineNum">     663 </span>            :         const PointType&amp; rRefCenter</a>
<a name="664"><span class="lineNum">     664 </span>            :         );</a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span>            :     /**</a>
<a name="667"><span class="lineNum">     667 </span>            :      * @brief This function calculates the triangles intersections (this is a module, that can be used directly in the respective function)</a>
<a name="668"><span class="lineNum">     668 </span>            :      * @param rConditionsPointsSlave The final solution vector, containing all the nodes</a>
<a name="669"><span class="lineNum">     669 </span>            :      * @param rPointList The intersection points</a>
<a name="670"><span class="lineNum">     670 </span>            :      * @param rSlaveGeometry The first (slave) geometry studied (projected)</a>
<a name="671"><span class="lineNum">     671 </span>            :      * @param rMasterGeometry The second (master) geometry studied (projected)</a>
<a name="672"><span class="lineNum">     672 </span>            :      * @param rSlaveTangentXi The first vector used as base to rotate</a>
<a name="673"><span class="lineNum">     673 </span>            :      * @param rSlaveTangentEta The second vector used as base to rotate</a>
<a name="674"><span class="lineNum">     674 </span>            :      * @param rRefCenter The reference point to rotate</a>
<a name="675"><span class="lineNum">     675 </span>            :      * @param IsAllInside To simplify and consider the point_list directly</a>
<a name="676"><span class="lineNum">     676 </span>            :      * @return If there is intersection or not (true/false)</a>
<a name="677"><span class="lineNum">     677 </span>            :      */</a>
<a name="678"><span class="lineNum">     678 </span>            :     template &lt;class TGeometryType = GeometryType&gt;</a>
<a name="679"><span class="lineNum">     679 </span>            :     inline bool TriangleIntersections(</a>
<a name="680"><span class="lineNum">     680 </span>            :         ConditionArrayListType&amp; rConditionsPointsSlave,</a>
<a name="681"><span class="lineNum">     681 </span>            :         PointListType&amp; rPointList,</a>
<a name="682"><span class="lineNum">     682 </span>            :         const TGeometryType&amp; rOriginalSlaveGeometry,</a>
<a name="683"><span class="lineNum">     683 </span>            :         const GeometryPointType&amp; rSlaveGeometry,</a>
<a name="684"><span class="lineNum">     684 </span>            :         const GeometryPointType&amp; rMasterGeometry,</a>
<a name="685"><span class="lineNum">     685 </span>            :         const array_1d&lt;double, 3&gt;&amp; rSlaveTangentXi,</a>
<a name="686"><span class="lineNum">     686 </span>            :         const array_1d&lt;double, 3&gt;&amp; rSlaveTangentEta,</a>
<a name="687"><span class="lineNum">     687 </span>            :         const PointType&amp; rRefCenter,</a>
<a name="688"><span class="lineNum">     688 </span>            :         const bool IsAllInside = false</a>
<a name="689"><span class="lineNum">     689 </span>            :         );</a>
<a name="690"><span class="lineNum">     690 </span>            : </a>
<a name="691"><span class="lineNum">     691 </span>            :     /**</a>
<a name="692"><span class="lineNum">     692 </span>            :      * @brief This method checks if the center of the geometry is inside the slave geometry (to prevent convex geometries)</a>
<a name="693"><span class="lineNum">     693 </span>            :      * @param AuxiliarCenterLocalCoordinates These are the local coordinates corresponding to the center</a>
<a name="694"><span class="lineNum">     694 </span>            :      * @param NumNodes The number of nodes of the geometry</a>
<a name="695"><span class="lineNum">     695 </span>            :      * @return True if is inside false otherwise</a>
<a name="696"><span class="lineNum">     696 </span>            :      */</a>
<a name="697"><span class="lineNum">     697 </span>            :     static inline bool CheckCenterIsInside(</a>
<a name="698"><span class="lineNum">     698 </span>            :         const array_1d&lt;double, 2&gt;&amp; rAuxiliarCenterLocalCoordinates,</a>
<a name="699"><span class="lineNum">     699 </span>            :         const SizeType NumNodes = TNumNodes</a>
<a name="700"><span class="lineNum">     700 </span>            :         );</a>
<a name="701"><span class="lineNum">     701 </span>            : </a>
<a name="702"><span class="lineNum">     702 </span>            :     ///@}</a>
<a name="703"><span class="lineNum">     703 </span>            :     ///@name Protected  Access</a>
<a name="704"><span class="lineNum">     704 </span>            :     ///@{</a>
<a name="705"><span class="lineNum">     705 </span>            : </a>
<a name="706"><span class="lineNum">     706 </span>            :     ///@}</a>
<a name="707"><span class="lineNum">     707 </span>            :     ///@name Protected Inquiry</a>
<a name="708"><span class="lineNum">     708 </span>            :     ///@{</a>
<a name="709"><span class="lineNum">     709 </span>            : </a>
<a name="710"><span class="lineNum">     710 </span>            :     ///@}</a>
<a name="711"><span class="lineNum">     711 </span>            :     ///@name Protected LifeCycle</a>
<a name="712"><span class="lineNum">     712 </span>            :     ///@{</a>
<a name="713"><span class="lineNum">     713 </span>            :     ///@}</a>
<a name="714"><span class="lineNum">     714 </span>            : private:</a>
<a name="715"><span class="lineNum">     715 </span>            :     ///@name Static Member Variables</a>
<a name="716"><span class="lineNum">     716 </span>            :     ///@{</a>
<a name="717"><span class="lineNum">     717 </span>            :     ///@}</a>
<a name="718"><span class="lineNum">     718 </span>            :     ///@name Member Variables</a>
<a name="719"><span class="lineNum">     719 </span>            :     ///@{</a>
<a name="720"><span class="lineNum">     720 </span>            : </a>
<a name="721"><span class="lineNum">     721 </span>            :     SizeType mIntegrationOrder;              /// The integration order to consider</a>
<a name="722"><span class="lineNum">     722 </span>            :     double mDistanceThreshold;               /// The distance where we directly  consider out of integration limits</a>
<a name="723"><span class="lineNum">     723 </span>            :     SizeType mEchoLevel;                     /// The echo level considered</a>
<a name="724"><span class="lineNum">     724 </span>            :     double mZeroToleranceFactor;             /// The zero tolerance factor considered</a>
<a name="725"><span class="lineNum">     725 </span>            :     IntegrationMethod mAuxIntegrationMethod; /// The auxiliar list of Gauss Points taken from the geometry</a>
<a name="726"><span class="lineNum">     726 </span>            :     bool mConsiderDelaunator;                /// If consider the DelaunatorUtilities in 3D in order to construct the triangles</a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span>            :     ///@}</a>
<a name="729"><span class="lineNum">     729 </span>            :     ///@name Private Operators</a>
<a name="730"><span class="lineNum">     730 </span>            :     ///@{</a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span>            :     ///@}</a>
<a name="733"><span class="lineNum">     733 </span>            :     ///@name Private Operations</a>
<a name="734"><span class="lineNum">     734 </span>            :     ///@{</a>
<a name="735"><span class="lineNum">     735 </span>            : </a>
<a name="736"><span class="lineNum">     736 </span>            :     ///@}</a>
<a name="737"><span class="lineNum">     737 </span>            :     ///@name Private  Access</a>
<a name="738"><span class="lineNum">     738 </span>            :     ///@{</a>
<a name="739"><span class="lineNum">     739 </span>            :     ///@}</a>
<a name="740"><span class="lineNum">     740 </span>            : </a>
<a name="741"><span class="lineNum">     741 </span>            :     ///@}</a>
<a name="742"><span class="lineNum">     742 </span>            :     ///@name Serialization</a>
<a name="743"><span class="lineNum">     743 </span>            :     ///@{</a>
<a name="744"><span class="lineNum">     744 </span>            : </a>
<a name="745"><span class="lineNum">     745 </span>            :     ///@name Private Inquiry</a>
<a name="746"><span class="lineNum">     746 </span>            :     ///@{</a>
<a name="747"><span class="lineNum">     747 </span>            :     ///@}</a>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<a name="749"><span class="lineNum">     749 </span>            :     ///@name Unaccessible methods</a>
<a name="750"><span class="lineNum">     750 </span>            :     ///@{</a>
<a name="751"><span class="lineNum">     751 </span>            :     ///@}</a>
<a name="752"><span class="lineNum">     752 </span>            : };  // Class ExactMortarIntegrationUtility</a>
<a name="753"><span class="lineNum">     753 </span>            : }</a>
<a name="754"><span class="lineNum">     754 </span>            : #endif /* KRATOS_EXACT_MORTAR_INTEGRATION_UTILITY_H_INCLUDED defined */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
