<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - kratos/utilities/cutting_utility.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">kratos/utilities</a> - cutting_utility.h<span style="font-size: 80%;"> (source / <a href="cutting_utility.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">283</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-17 14:49:52</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //    |  /           |</a>
<a name="2"><span class="lineNum">       2 </span>            : //    ' /   __| _` | __|  _ \   __|</a>
<a name="3"><span class="lineNum">       3 </span>            : //    . \  |   (   | |   (   |\__ `</a>
<a name="4"><span class="lineNum">       4 </span>            : //   _|\_\_|  \__,_|\__|\___/ ____/</a>
<a name="5"><span class="lineNum">       5 </span>            : //                   Multi-Physics</a>
<a name="6"><span class="lineNum">       6 </span>            : //</a>
<a name="7"><span class="lineNum">       7 </span>            : //  License:             BSD License</a>
<a name="8"><span class="lineNum">       8 </span>            : //                                       Kratos default license: kratos/license.txt</a>
<a name="9"><span class="lineNum">       9 </span>            : //</a>
<a name="10"><span class="lineNum">      10 </span>            : //  Main authors:    Pablo Becker</a>
<a name="11"><span class="lineNum">      11 </span>            : //</a>
<a name="12"><span class="lineNum">      12 </span>            : //</a>
<a name="13"><span class="lineNum">      13 </span>            : </a>
<a name="14"><span class="lineNum">      14 </span>            : #if !defined(KRATOS_CUTTING_UTILITY)</a>
<a name="15"><span class="lineNum">      15 </span>            : #define  KRATOS_CUTTING_UTILITY</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : // System includes</a>
<a name="18"><span class="lineNum">      18 </span>            : #ifdef _OPENMP</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &lt;omp.h&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            : #endif</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &lt;string&gt;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;iostream&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : #include &lt;cstdlib&gt;</a>
<a name="24"><span class="lineNum">      24 </span>            : #include &lt;cmath&gt;</a>
<a name="25"><span class="lineNum">      25 </span>            : #include &lt;algorithm&gt;</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : // External includes</a>
<a name="28"><span class="lineNum">      28 </span>            : #include &lt;boost/numeric/ublas/matrix.hpp&gt;</a>
<a name="29"><span class="lineNum">      29 </span>            : #include &lt;boost/numeric/ublas/vector.hpp&gt;</a>
<a name="30"><span class="lineNum">      30 </span>            : #include &lt;boost/numeric/ublas/banded.hpp&gt;</a>
<a name="31"><span class="lineNum">      31 </span>            : #include &lt;boost/numeric/ublas/matrix_sparse.hpp&gt;</a>
<a name="32"><span class="lineNum">      32 </span>            : #include &lt;boost/numeric/ublas/triangular.hpp&gt;</a>
<a name="33"><span class="lineNum">      33 </span>            : #include &lt;boost/numeric/ublas/operation.hpp&gt;</a>
<a name="34"><span class="lineNum">      34 </span>            : #include &lt;boost/numeric/ublas/lu.hpp&gt;</a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : // Project includes</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &quot;includes/define.h&quot;</a>
<a name="38"><span class="lineNum">      38 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="39"><span class="lineNum">      39 </span>            : #include &quot;includes/node.h&quot;</a>
<a name="40"><span class="lineNum">      40 </span>            : #include &quot;includes/dof.h&quot;</a>
<a name="41"><span class="lineNum">      41 </span>            : #include &quot;includes/variables.h&quot;</a>
<a name="42"><span class="lineNum">      42 </span>            : #include &quot;containers/array_1d.h&quot;</a>
<a name="43"><span class="lineNum">      43 </span>            : #include &quot;processes/find_nodal_neighbours_process.h&quot;</a>
<a name="44"><span class="lineNum">      44 </span>            : #include &quot;containers/data_value_container.h&quot;</a>
<a name="45"><span class="lineNum">      45 </span>            : #include &quot;includes/mesh.h&quot;</a>
<a name="46"><span class="lineNum">      46 </span>            : #include &quot;utilities/math_utils.h&quot;</a>
<a name="47"><span class="lineNum">      47 </span>            : #include &quot;utilities/split_tetrahedra.h&quot;</a>
<a name="48"><span class="lineNum">      48 </span>            : #include &quot;utilities/split_triangle.h&quot;</a>
<a name="49"><span class="lineNum">      49 </span>            : #include &quot;geometries/tetrahedra_3d_4.h&quot;</a>
<a name="50"><span class="lineNum">      50 </span>            : #include &quot;geometries/triangle_3d_3.h&quot;</a>
<a name="51"><span class="lineNum">      51 </span>            : #include &quot;spatial_containers/spatial_containers.h&quot;</a>
<a name="52"><span class="lineNum">      52 </span>            : </a>
<a name="53"><span class="lineNum">      53 </span>            : namespace Kratos</a>
<a name="54"><span class="lineNum">      54 </span>            : {</a>
<a name="55"><span class="lineNum">      55 </span>            : </a>
<a name="56"><span class="lineNum">      56 </span>            : /// CUTTING UTILITY.</a>
<a name="57"><span class="lineNum">      57 </span>            : /** The cutting utility is used to create cutting planes in a 3D domain.</a>
<a name="58"><span class="lineNum">      58 </span>            :      Despite this can be done in the postprocessing (using Kratos), on large domains the output data would be really large and include info that is not useful for the user.</a>
<a name="59"><span class="lineNum">      59 </span>            :      This app creates nodes and conditions (in a new, empty model part) intersecting the domain with as many planes as the user want. It is also possible to use different layers</a>
<a name="60"><span class="lineNum">      60 </span>            :      If conditions are triangles, they can be added too to the new model part.</a>
<a name="61"><span class="lineNum">      61 </span>            :      After each time step UpdateCutData must be called to save the new info into the new model part, interpolating from the tetraeda elements</a>
<a name="62"><span class="lineNum">      62 </span>            :      NOTE: it only work with tetraedra elements, generating triangles  (1 or 2) from the tetraedra - plane intersection.</a>
<a name="63"><span class="lineNum">      63 </span>            :  */</a>
<a name="64"><span class="lineNum">      64 </span>            : class CuttingUtility</a>
<a name="65"><span class="lineNum">      65 </span>            : {</a>
<a name="66"><span class="lineNum">      66 </span>            : public:</a>
<a name="67"><span class="lineNum">      67 </span>            : </a>
<a name="68"><span class="lineNum">      68 </span>            :     ///@name Type Definitions</a>
<a name="69"><span class="lineNum">      69 </span>            :     ///@{</a>
<a name="70"><span class="lineNum">      70 </span>            :     typedef ModelPart::NodesContainerType NodesArrayType;</a>
<a name="71"><span class="lineNum">      71 </span>            :     typedef ModelPart::ElementsContainerType ElementsArrayType;</a>
<a name="72"><span class="lineNum">      72 </span>            :     typedef ModelPart::ConditionsContainerType ConditionsArrayType;</a>
<a name="73"><span class="lineNum">      73 </span>            :     typedef DenseVector&lt;Matrix&gt; Matrix_Order_Tensor;</a>
<a name="74"><span class="lineNum">      74 </span>            :     typedef DenseVector&lt;Vector&gt; Vector_Order_Tensor;</a>
<a name="75"><span class="lineNum">      75 </span>            :     typedef DenseVector&lt;Vector_Order_Tensor&gt; Node_Vector_Order_Tensor;</a>
<a name="76"><span class="lineNum">      76 </span>            :     typedef Node &lt; 3 &gt; PointType;</a>
<a name="77"><span class="lineNum">      77 </span>            :     typedef Node &lt; 3 &gt; ::Pointer PointPointerType;</a>
<a name="78"><span class="lineNum">      78 </span>            :     typedef std::vector&lt;PointType::Pointer&gt; PointVector;</a>
<a name="79"><span class="lineNum">      79 </span>            :     typedef PointVector::iterator PointIterator;</a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span>            :     ///@}</a>
<a name="82"><span class="lineNum">      82 </span>            :     ///@name Life Cycle</a>
<a name="83"><span class="lineNum">      83 </span>            :     ///@{</a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            :     /// Default constructor.</a>
<a name="86"><span class="lineNum">      86 </span>            :     CuttingUtility()</a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :     {</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :         smallest_edge=1.0;   //</span></a>
<a name="89"><span class="lineNum">      89 </span>            :     }</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            :     /// Destructor.</a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :     virtual ~CuttingUtility() {}</span></a>
<a name="93"><span class="lineNum">      93 </span>            : </a>
<a name="94"><span class="lineNum">      94 </span>            : </a>
<a name="95"><span class="lineNum">      95 </span>            :     ///This function Creates cutting planes by creating nodes and conditions (to define the conectivities) in a different model part.</a>
<a name="96"><span class="lineNum">      96 </span>            :     /** It is used to find the smallest edge that will be used later as a reference to identify whether a node is part of the plane or is simple close</a>
<a name="97"><span class="lineNum">      97 </span>            :         (and therefore a new point will be created by interpolation)</a>
<a name="98"><span class="lineNum">      98 </span>            :      * @param mr_model_part . model part to find the smallest edge</a>
<a name="99"><span class="lineNum">      99 </span>            :      **/</a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :     void FindSmallestEdge(ModelPart&amp; mr_model_part)</span></a>
<a name="101"><span class="lineNum">     101 </span>            :     {</a>
<a name="102"><span class="lineNum">     102 </span>            :         ModelPart&amp; this_model_part = mr_model_part;</a>
<a name="103"><span class="lineNum">     103 </span>            :         ElementsArrayType&amp; rElements = this_model_part.Elements();</a>
<a name="104"><span class="lineNum">     104 </span>            :         ElementsArrayType::iterator it_begin = rElements.ptr_begin();</a>
<a name="105"><span class="lineNum">     105 </span>            :         ElementsArrayType::iterator it_end = rElements.ptr_end();</a>
<a name="106"><span class="lineNum">     106 </span>            :         double dist_node_neigh;             //distance between the two nodes of the edge</a>
<a name="107"><span class="lineNum">     107 </span>            :         array_1d&lt;double, 3 &gt; node_coord;             //</a>
<a name="108"><span class="lineNum">     108 </span>            :         array_1d&lt;double, 3 &gt; neigh_coord;             //</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :         smallest_edge = 1000000000000000000000000000.0; //maybe the mesh is huge, setting a big number just in case</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 :         for (ElementsArrayType::iterator it = it_begin; it != it_end; ++it) //looping all the elements</span></a>
<a name="111"><span class="lineNum">     111 </span>            :         {</a>
<a name="112"><span class="lineNum">     112 </span>            :             Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = it-&gt;GetGeometry(); //geometry of the element</a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :             for(unsigned int i = 0; i &lt; it-&gt;GetGeometry().size() ; i++)  //edge i</span></a>
<a name="114"><span class="lineNum">     114 </span>            :             {</a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :                 node_coord[0] = geom[i].X();</span></a>
<a name="116"><span class="lineNum">     116 </span><span class="lineNoCov">          0 :                 node_coord[1] = geom[i].Y();</span></a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :                 node_coord[2] = geom[i].Z();</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :                 for(unsigned int j = 0; j &lt; it-&gt;GetGeometry().size() ; j++)  //edge i</span></a>
<a name="119"><span class="lineNum">     119 </span>            :                 {</a>
<a name="120"><span class="lineNum">     120 </span><span class="lineNoCov">          0 :                     neigh_coord[0] = geom[j].X();</span></a>
<a name="121"><span class="lineNum">     121 </span><span class="lineNoCov">          0 :                     neigh_coord[1] = geom[j].Y();</span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 :                     neigh_coord[2] = geom[j].Z();</span></a>
<a name="123"><span class="lineNum">     123 </span><span class="lineNoCov">          0 :                     dist_node_neigh = sqrt( pow((node_coord[0]- neigh_coord[0]),2) + pow((node_coord[1]- neigh_coord[1]),2) + pow((node_coord[2]- neigh_coord[2]),2) ) ; // distance between node and neighbour</span></a>
<a name="124"><span class="lineNum">     124 </span><span class="lineNoCov">          0 :                     if ((dist_node_neigh&lt;smallest_edge) &amp;&amp; (i!=j)) smallest_edge=dist_node_neigh; //saving the smallest found up to now</span></a>
<a name="125"><span class="lineNum">     125 </span>            :                 }//closing j loop</a>
<a name="126"><span class="lineNum">     126 </span>            :             } //closing i loop</a>
<a name="127"><span class="lineNum">     127 </span>            :         } //closing element loop</a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :         KRATOS_WATCH(smallest_edge);</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :     } //closing function</span></a>
<a name="130"><span class="lineNum">     130 </span>            : </a>
<a name="131"><span class="lineNum">     131 </span>            :     ///************************************************************************************************</a>
<a name="132"><span class="lineNum">     132 </span>            :     ///************************************************************************************************</a>
<a name="133"><span class="lineNum">     133 </span>            : </a>
<a name="134"><span class="lineNum">     134 </span>            :     ///This function Creates cutting planes by creating nodes and conditions (to define the conectivities) in a different model part. (new_model_part)</a>
<a name="135"><span class="lineNum">     135 </span>            :     /** each time it is called a new cutting plane is created and therefore new nodes and conditions are added to the new model part</a>
<a name="136"><span class="lineNum">     136 </span>            :         WARNING: the cutting plane MUST cut the domain in at least one triangle, otherwise a segmentiation fault might appear</a>
<a name="137"><span class="lineNum">     137 </span>            :      * @param mr_model_part . original model part</a>
<a name="138"><span class="lineNum">     138 </span>            :      * @param mr__new_model_part . destinantion model part</a>
<a name="139"><span class="lineNum">     139 </span>            :      * @param versor. unit vector perpendicular to the plane</a>
<a name="140"><span class="lineNum">     140 </span>            :      * @param Xp. a point that is part of the plane</a>
<a name="141"><span class="lineNum">     141 </span>            :      * @param plane_number . layer to add the conditions (integer)</a>
<a name="142"><span class="lineNum">     142 </span>            :      * @param tolerance factor . if find_smallest edge has been called, then it is the tolerance relative to that edge, in this case it should be 0.5&gt;factor&gt;0. high values will generate less triangles but the result will not be a perfect plane. on the other hand small values will generate a perfect plane but with lots of ugly triangles. If findsmallestedge has noot been run, it absolute tolerance.</a>
<a name="143"><span class="lineNum">     143 </span>            :      **/</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :     void GenerateCut(ModelPart&amp; mr_model_part, ModelPart&amp; mr_new_model_part, const array_1d&lt;double, 3 &gt;&amp; versor, const array_1d&lt;double, 3 &gt;&amp; Xp, int plane_number ,double tolerance_factor)</span></a>
<a name="145"><span class="lineNum">     145 </span>            :     {</a>
<a name="146"><span class="lineNum">     146 </span>            :         KRATOS_WATCH(&quot;Generating Cutting plane with the following data:&quot;)</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineNoCov">          0 :         KRATOS_WATCH(versor);</span></a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :         KRATOS_WATCH(Xp);</span></a>
<a name="149"><span class="lineNum">     149 </span>            :         KRATOS_TRY</a>
<a name="150"><span class="lineNum">     150 </span>            : </a>
<a name="151"><span class="lineNum">     151 </span><span class="lineNoCov">          0 :         if (!mr_new_model_part.GetNodalSolutionStepVariablesList().Has(FATHER_NODES) ||</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineNoCov">          0 :             !mr_new_model_part.GetNodalSolutionStepVariablesList().Has(WEIGHT_FATHER_NODES) )</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :             KRATOS_ERROR &lt;&lt; &quot;The cut model part was not initialized. &quot;</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :                             &quot;Please call AddVariablesToCutModelPart before GenerateCut.&quot;</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineNoCov">          0 :                          &lt;&lt; std::endl;</span></a>
<a name="156"><span class="lineNum">     156 </span>            : </a>
<a name="157"><span class="lineNum">     157 </span>            :         DenseVector&lt;array_1d&lt;int, 2 &gt; &gt; Position_Node;</a>
<a name="158"><span class="lineNum">     158 </span>            :         DenseVector&lt;int&gt; List_New_Nodes;</a>
<a name="159"><span class="lineNum">     159 </span>            : </a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :                 boost::numeric::ublas::compressed_matrix&lt;int&gt; Coord;</span></a>
<a name="161"><span class="lineNum">     161 </span>            :         ModelPart&amp; this_model_part = mr_model_part;</a>
<a name="162"><span class="lineNum">     162 </span>            :         ModelPart&amp; new_model_part = mr_new_model_part;</a>
<a name="163"><span class="lineNum">     163 </span>            : </a>
<a name="164"><span class="lineNum">     164 </span>            :         DenseVector&lt;int&gt;  Elems_In_Plane( this_model_part.Elements().size());          //our (int) vector, where we write 1 when the element is cut by the cutting plane. when it is 2, it means we have 2 triangles (4 cutting points)</a>
<a name="165"><span class="lineNum">     165 </span>            :         int number_of_triangles = 0;</a>
<a name="166"><span class="lineNum">     166 </span><span class="lineNoCov">          0 :         double tolerance = tolerance_factor*smallest_edge; //if Find_Smallest_Edge is not run , then the tolerance is absolute</span></a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span>            :         //finished creating the variables and vector/matrix needed. now we have to call the subroutines.</a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :         CSR_Row_Matrix_Mod(this_model_part, Coord);</span></a>
<a name="170"><span class="lineNum">     170 </span>            : </a>
<a name="171"><span class="lineNum">     171 </span><span class="lineNoCov">          0 :         FirstLoop(this_model_part, Coord, versor, Xp, number_of_triangles, Elems_In_Plane, tolerance);</span></a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span><span class="lineNoCov">          0 :         Create_List_Of_New_Nodes_Mod(this_model_part,  new_model_part, Coord, List_New_Nodes, Position_Node);</span></a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span><span class="lineNoCov">          0 :         Calculate_Coordinate_And_Insert_New_Nodes_Mod(this_model_part, new_model_part, Position_Node, List_New_Nodes, versor, Xp, tolerance);</span></a>
<a name="176"><span class="lineNum">     176 </span>            : </a>
<a name="177"><span class="lineNum">     177 </span><span class="lineNoCov">          0 :         GenerateElements (this_model_part, new_model_part, Elems_In_Plane, Coord, versor, plane_number);</span></a>
<a name="178"><span class="lineNum">     178 </span>            : </a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span>            :         KRATOS_WATCH(&quot;Finished generating cutting plane&quot;)</a>
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<a name="184"><span class="lineNum">     184 </span>            : </a>
<a name="185"><span class="lineNum">     185 </span>            :     ///************************************************************************************************</a>
<a name="186"><span class="lineNum">     186 </span>            :     ///************************************************************************************************</a>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :     /// ADDSKINCONDITIONS: THIS FUNCTION ADDS TO THE NEW MODEL PART THE DATA OF THE CONDITIONS BELONGING TO THE OLD MODEL PART, BASICALLY THE SAME AS THE PREVIOUS FUNCTION BUT THERE'S NO NEED TO INTERPOLATE SINCE THE NODES COORDINATES ALREADY EXIST. WE ONLY NEED TO COPY THEM TO THE NEW MODEL PART.</a>
<a name="190"><span class="lineNum">     190 </span>            :     /** this function adds the skin condtion.</a>
<a name="191"><span class="lineNum">     191 </span>            :         WARNING: They have to be triangles and it CAN'T be empty, otherwise a segmentation fault will appear</a>
<a name="192"><span class="lineNum">     192 </span>            :      * @param mr_model_part . original model part</a>
<a name="193"><span class="lineNum">     193 </span>            :      * @param mr__new_model_part . destinantion model part</a>
<a name="194"><span class="lineNum">     194 </span>            :      * @param plane_number . layer to add the conditions (integer)</a>
<a name="195"><span class="lineNum">     195 </span>            :      **/</a>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :     void AddSkinConditions(ModelPart&amp; mr_model_part, ModelPart&amp; mr_new_model_part, int plane_number )</span></a>
<a name="197"><span class="lineNum">     197 </span>            :     {</a>
<a name="198"><span class="lineNum">     198 </span>            :         ModelPart&amp; this_model_part = mr_model_part;</a>
<a name="199"><span class="lineNum">     199 </span>            :         NodesArrayType::iterator it_begin_node_old = this_model_part.Nodes().ptr_begin();</a>
<a name="200"><span class="lineNum">     200 </span>            :         ModelPart&amp; new_model_part = mr_new_model_part;</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            :         std::cout &lt;&lt;&quot;Adding Skin Conditions to the new model part, added in layer:&quot; &lt;&lt; std::endl;</a>
<a name="203"><span class="lineNum">     203 </span><span class="lineNoCov">          0 :         KRATOS_WATCH(plane_number)</span></a>
<a name="204"><span class="lineNum">     204 </span>            :         KRATOS_TRY</a>
<a name="205"><span class="lineNum">     205 </span>            :         DenseVector&lt;int&gt;  Condition_Nodes( this_model_part.Nodes().size());          //our (int) vector, where we write -1 when the node is part of the condition faces</a>
<a name="206"><span class="lineNum">     206 </span>            :         int number_of_triangles = 0; //we set it to zero to start</a>
<a name="207"><span class="lineNum">     207 </span>            :         int number_of_nodes = 0; //same as above</a>
<a name="208"><span class="lineNum">     208 </span>            :         int number_of_previous_nodes = 0; // nodes from the previous conditions (planes) created</a>
<a name="209"><span class="lineNum">     209 </span>            :         int number_of_conditions = 0;</a>
<a name="210"><span class="lineNum">     210 </span>            : </a>
<a name="211"><span class="lineNum">     211 </span><span class="lineNoCov">          0 :         if (!new_model_part.GetNodalSolutionStepVariablesList().Has(FATHER_NODES) ||</span></a>
<a name="212"><span class="lineNum">     212 </span><span class="lineNoCov">          0 :             !new_model_part.GetNodalSolutionStepVariablesList().Has(WEIGHT_FATHER_NODES) )</span></a>
<a name="213"><span class="lineNum">     213 </span><span class="lineNoCov">          0 :             KRATOS_ERROR &lt;&lt; &quot;The cut model part was not initialized. &quot;</span></a>
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 :                             &quot;Please call AddVariablesToCutModelPart before AddSkinConditions.&quot;</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :                          &lt;&lt; std::endl;</span></a>
<a name="216"><span class="lineNum">     216 </span>            : </a>
<a name="217"><span class="lineNum">     217 </span>            :         ConditionsArrayType&amp; rConditions = this_model_part.Conditions();</a>
<a name="218"><span class="lineNum">     218 </span>            :         ConditionsArrayType::iterator cond_it_begin = rConditions.ptr_begin();</a>
<a name="219"><span class="lineNum">     219 </span>            :         ConditionsArrayType::iterator cond_it_end = rConditions.ptr_end();</a>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<a name="221"><span class="lineNum">     221 </span>            :         ConditionsArrayType&amp; rConditions_new = new_model_part.Conditions();</a>
<a name="222"><span class="lineNum">     222 </span>            :         ConditionsArrayType::iterator cond_it_end_new = rConditions_new.ptr_end();</a>
<a name="223"><span class="lineNum">     223 </span>            :         ConditionsArrayType::iterator cond_it_begin_new = rConditions_new.ptr_begin();</a>
<a name="224"><span class="lineNum">     224 </span><span class="lineNoCov">          0 :         number_of_conditions = cond_it_end - cond_it_begin;</span></a>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<a name="226"><span class="lineNum">     226 </span><span class="lineNoCov">          0 :         if (new_model_part.Nodes().size()!=0)  //it means this is not the first plane that has to be created</span></a>
<a name="227"><span class="lineNum">     227 </span>            :         {</a>
<a name="228"><span class="lineNum">     228 </span>            :             NodesArrayType&amp; rNodes_new = new_model_part.Nodes();        //i need the model part just to check the id of the new nodes.</a>
<a name="229"><span class="lineNum">     229 </span>            :             NodesArrayType::iterator it_end_node_new = rNodes_new.ptr_end();</a>
<a name="230"><span class="lineNum">     230 </span>            :             NodesArrayType::iterator it_begin_node_new = rNodes_new.ptr_begin();</a>
<a name="231"><span class="lineNum">     231 </span><span class="lineNoCov">          0 :             number_of_previous_nodes=(it_end_node_new-it_begin_node_new);</span></a>
<a name="232"><span class="lineNum">     232 </span><span class="lineNoCov">          0 :             number_of_triangles=cond_it_end_new - cond_it_begin_new ;</span></a>
<a name="233"><span class="lineNum">     233 </span>            :            // KRATOS_WATCH(number_of_triangles)</a>
<a name="234"><span class="lineNum">     234 </span>            :             //KRATOS_WATCH(number_of_previous_nodes)</a>
<a name="235"><span class="lineNum">     235 </span>            :             //KRATOS_CATCH(&quot;&quot;)</a>
<a name="236"><span class="lineNum">     236 </span>            :         }</a>
<a name="237"><span class="lineNum">     237 </span>            :         else //nothing. number of triangles and nodes already set to 0</a>
<a name="238"><span class="lineNum">     238 </span>            :         {</a>
<a name="239"><span class="lineNum">     239 </span>            :             std::cout &lt;&lt;&quot;First Cutting Plane&quot; &lt;&lt; std::endl;</a>
<a name="240"><span class="lineNum">     240 </span>            :         }</a>
<a name="241"><span class="lineNum">     241 </span>            : </a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span><span class="lineNoCov">          0 :                 if (number_of_conditions!=0)</span></a>
<a name="244"><span class="lineNum">     244 </span>            :                 {</a>
<a name="245"><span class="lineNum">     245 </span><span class="lineNoCov">          0 :                         for (unsigned int index=0 ; index != this_model_part.Nodes().size() ; ++index) Condition_Nodes[index]=0; //initializing in zero the whole vector (meaning no useful nodes for the condition layer)</span></a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :                         for(ModelPart::ConditionsContainerType::iterator i_condition = rConditions.begin() ; i_condition != rConditions.end() ; i_condition++)</span></a>
<a name="248"><span class="lineNum">     248 </span>            :                         {</a>
<a name="249"><span class="lineNum">     249 </span>            :                                 Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = i_condition-&gt;GetGeometry();</a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :                                 for(unsigned int i = 0; i &lt; i_condition-&gt;GetGeometry().size() ; i++)</span></a>
<a name="251"><span class="lineNum">     251 </span>            :                                 {</a>
<a name="252"><span class="lineNum">     252 </span>            :                                         //int position = (geom[i].Id()) - 1; //the id of the node minus one is the position in the Condition_Node array (position0 = node1)</a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :                                         int position = this_model_part.Nodes().find(geom[i].Id()) - it_begin_node_old; //probably there-s a better way to do this, i only need the position in the array, (not the ID)</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :                                         Condition_Nodes[position] =  -1 ; //a -1 means we need this node!</span></a>
<a name="255"><span class="lineNum">     255 </span>            :                                 }</a>
<a name="256"><span class="lineNum">     256 </span>            :                         }//done. now we know all the nodes that will have to be added to the new model part.</a>
<a name="257"><span class="lineNum">     257 </span>            : </a>
<a name="258"><span class="lineNum">     258 </span>            :                         //we loop all the nodes in the old model part and copy the ones used by conditions to the new model part:</a>
<a name="259"><span class="lineNum">     259 </span><span class="lineNoCov">          0 :                         for (unsigned int index=0 ; index != this_model_part.Nodes().size() ; ++index)</span></a>
<a name="260"><span class="lineNum">     260 </span>            :                         {</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineNoCov">          0 :                                 if (Condition_Nodes[index]==-1)</span></a>
<a name="262"><span class="lineNum">     262 </span>            :                                 {</a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :                                         ++number_of_nodes; //one new node!</span></a>
<a name="264"><span class="lineNum">     264 </span><span class="lineNoCov">          0 :                                         Condition_Nodes[index] = number_of_nodes + number_of_previous_nodes; //we give this node consecutives ids. now we create the new node</span></a>
<a name="265"><span class="lineNum">     265 </span>            :                                         ModelPart::NodesContainerType::iterator it_node = this_model_part.Nodes().begin()+index;</a>
<a name="266"><span class="lineNum">     266 </span><span class="lineNoCov">          0 :                                         Node &lt; 3 &gt; ::Pointer pnode = new_model_part.CreateNewNode(number_of_nodes+number_of_previous_nodes, it_node-&gt;X(), it_node-&gt;Y(), it_node-&gt;Z());  //recordar que es el nueevo model part!!</span></a>
<a name="267"><span class="lineNum">     267 </span>            :                                         pnode-&gt;SetBufferSize(this_model_part.NodesBegin()-&gt;GetBufferSize());</a>
<a name="268"><span class="lineNum">     268 </span>            :                                         pnode-&gt;GetValue(FATHER_NODES).resize(0);</a>
<a name="269"><span class="lineNum">     269 </span><span class="lineNoCov">          0 :                                         pnode-&gt;GetValue(FATHER_NODES).push_back( Node&lt;3&gt;::WeakPointer( *it_node.base() ) );       // we keep the same size despite we only need one. to have everyhing with the same size</span></a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :                                         pnode-&gt;GetValue(FATHER_NODES).push_back( Node&lt;3&gt;::WeakPointer( *it_node.base() ) );</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineNoCov">          0 :                                         pnode-&gt; GetValue(WEIGHT_FATHER_NODES) = 1.0;  //since both father node 1 and 2 are the same, any value between 0 and one would be ok.</span></a>
<a name="272"><span class="lineNum">     272 </span>            : </a>
<a name="273"><span class="lineNum">     273 </span><span class="lineNoCov">          0 :                                         pnode-&gt;X0() = it_node-&gt;X0();</span></a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :                                         pnode-&gt;Y0() = it_node-&gt;Y0();</span></a>
<a name="275"><span class="lineNum">     275 </span><span class="lineNoCov">          0 :                                         pnode-&gt;Z0() = it_node-&gt;Z0();</span></a>
<a name="276"><span class="lineNum">     276 </span>            :                                 }</a>
<a name="277"><span class="lineNum">     277 </span>            :                         }//finished the list of nodes to be added.</a>
<a name="278"><span class="lineNum">     278 </span>            : </a>
<a name="279"><span class="lineNum">     279 </span>            :                         //now to the conditions!</a>
<a name="280"><span class="lineNum">     280 </span>            :                         DenseVector&lt;int&gt;  triangle_nodes(3); //here we'll save the nodes' ids with the new node names</a>
<a name="281"><span class="lineNum">     281 </span><span class="lineNoCov">          0 :                         Condition const&amp; rReferenceCondition = KratosComponents&lt;Condition&gt;::Get(&quot;SurfaceCondition3D3N&quot;);         //condition type</span></a>
<a name="282"><span class="lineNum">     282 </span><span class="lineNoCov">          0 :                         Properties::Pointer properties = this_model_part.GetMesh().pGetProperties(plane_number);                //this will allow us later to turn this layer on/off in GID</span></a>
<a name="283"><span class="lineNum">     283 </span>            : </a>
<a name="284"><span class="lineNum">     284 </span><span class="lineNoCov">          0 :                         for(ModelPart::ConditionsContainerType::iterator i_condition = rConditions.begin() ; i_condition != rConditions.end() ; i_condition++) //looping all the conditions</span></a>
<a name="285"><span class="lineNum">     285 </span>            :                         {</a>
<a name="286"><span class="lineNum">     286 </span>            :                                 Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = i_condition-&gt;GetGeometry(); //current condition(nodes, etc)</a>
<a name="287"><span class="lineNum">     287 </span><span class="lineNoCov">          0 :                                 for(unsigned int i = 0; i &lt; i_condition-&gt;GetGeometry().size() ; i++)         //looping the nodes</span></a>
<a name="288"><span class="lineNum">     288 </span>            :                                 {</a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :                                         int position = this_model_part.Nodes().find(geom[i].Id()) - it_begin_node_old;  //the id of the node minus one is the position in the Condition_Node array (position0 = node1)</span></a>
<a name="290"><span class="lineNum">     290 </span><span class="lineNoCov">          0 :                                         triangle_nodes[i]=Condition_Nodes[position]; // saving the i nodeId</span></a>
<a name="291"><span class="lineNum">     291 </span>            :                                 } //nodes id saved. now we have to create the element.</a>
<a name="292"><span class="lineNum">     292 </span>            :                                 Triangle3D3&lt;Node&lt;3&gt; &gt; geometry(</a>
<a name="293"><span class="lineNum">     293 </span><span class="lineNoCov">          0 :                                         new_model_part.Nodes()(triangle_nodes[0]),  //condition to be added</span></a>
<a name="294"><span class="lineNum">     294 </span><span class="lineNoCov">          0 :                                         new_model_part.Nodes()(triangle_nodes[1]),</span></a>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 :                                         new_model_part.Nodes()(triangle_nodes[2])</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :                                 );</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineNoCov">          0 :                                 Condition::Pointer p_condition = rReferenceCondition.Create(number_of_triangles+1, geometry, properties); //está bien? acá la verdad ni idea. sobre todo number_of_triangles (la posición). o debe ser un puntero de elemento en vez de un entero?</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :                                 new_model_part.Conditions().push_back(p_condition);</span></a>
<a name="299"><span class="lineNum">     299 </span>            :                                 ++number_of_triangles;</a>
<a name="300"><span class="lineNum">     300 </span>            :                         }</a>
<a name="301"><span class="lineNum">     301 </span>            :                 }</a>
<a name="302"><span class="lineNum">     302 </span>            :         KRATOS_WATCH(&quot;Finished copying conditions surfaces&quot;)</a>
<a name="303"><span class="lineNum">     303 </span><span class="lineNoCov">          0 :         KRATOS_CATCH(&quot;&quot;)</span></a>
<a name="304"><span class="lineNum">     304 </span>            : </a>
<a name="305"><span class="lineNum">     305 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span>            :     /// Initialize the solution step data container for the cut model part.</a>
<a name="308"><span class="lineNum">     308 </span>            :     /** Please call this function before either GenerateCut or AddSkinCondition.</a>
<a name="309"><span class="lineNum">     309 </span>            :      *  @param rModelPart the reference (problem) model part.</a>
<a name="310"><span class="lineNum">     310 </span>            :      *  @param rNewModelPart the new model part, where cut data will be stored.</a>
<a name="311"><span class="lineNum">     311 </span>            :      */</a>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :     void AddVariablesToCutModelPart(</span></a>
<a name="313"><span class="lineNum">     313 </span>            :         const ModelPart&amp; rModelPart,</a>
<a name="314"><span class="lineNum">     314 </span>            :         ModelPart&amp; rNewModelPart) const</a>
<a name="315"><span class="lineNum">     315 </span>            :     {</a>
<a name="316"><span class="lineNum">     316 </span><span class="lineNoCov">          0 :         rNewModelPart.GetNodalSolutionStepVariablesList() = rModelPart.GetNodalSolutionStepVariablesList();</span></a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :         rNewModelPart.AddNodalSolutionStepVariable(FATHER_NODES);</span></a>
<a name="318"><span class="lineNum">     318 </span><span class="lineNoCov">          0 :         rNewModelPart.AddNodalSolutionStepVariable(WEIGHT_FATHER_NODES);</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<a name="322"><span class="lineNum">     322 </span>            :     //************************************************************************************************</a>
<a name="323"><span class="lineNum">     323 </span>            :     //************************************************************************************************</a>
<a name="324"><span class="lineNum">     324 </span>            : </a>
<a name="325"><span class="lineNum">     325 </span>            : </a>
<a name="326"><span class="lineNum">     326 </span>            :     //LIST OF SUBROUTINES</a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            : </a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :     void CSR_Row_Matrix_Mod(ModelPart&amp; this_model_part, boost::numeric::ublas::compressed_matrix&lt;int&gt;&amp; Coord)</span></a>
<a name="330"><span class="lineNum">     330 </span>            :     {</a>
<a name="331"><span class="lineNum">     331 </span>            :         NodesArrayType&amp; pNodes = this_model_part.Nodes();</a>
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 :         Coord.resize(pNodes.size(), pNodes.size());</span></a>
<a name="333"><span class="lineNum">     333 </span>            :         NodesArrayType::iterator i_begin = pNodes.ptr_begin();</a>
<a name="334"><span class="lineNum">     334 </span>            :         NodesArrayType::iterator i_end = pNodes.ptr_end();</a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span><span class="lineNoCov">          0 :         std::vector&lt;unsigned int&gt; aux(10000);</span></a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span><span class="lineNoCov">          0 :         for (ModelPart::NodeIterator i = i_begin; i != i_end; ++i)</span></a>
<a name="339"><span class="lineNum">     339 </span>            :         {</a>
<a name="340"><span class="lineNum">     340 </span><span class="lineNoCov">          0 :             int index_i = i-&gt;Id() - 1;</span></a>
<a name="341"><span class="lineNum">     341 </span>            :             GlobalPointersVector&lt; Node &lt; 3 &gt; &gt;&amp; neighb_nodes = i-&gt;GetValue(NEIGHBOUR_NODES);</a>
<a name="342"><span class="lineNum">     342 </span><span class="lineNoCov">          0 :             Coord.push_back(index_i, index_i, -1);        //only modification added, now the diagonal is filled with -1 too.</span></a>
<a name="343"><span class="lineNum">     343 </span>            : </a>
<a name="344"><span class="lineNum">     344 </span>            :             unsigned int active = 0;</a>
<a name="345"><span class="lineNum">     345 </span>            :             for (GlobalPointersVector&lt; Node &lt; 3 &gt; &gt;::iterator inode = neighb_nodes.begin();</a>
<a name="346"><span class="lineNum">     346 </span><span class="lineNoCov">          0 :                     inode != neighb_nodes.end(); inode++)</span></a>
<a name="347"><span class="lineNum">     347 </span>            :             {</a>
<a name="348"><span class="lineNum">     348 </span><span class="lineNoCov">          0 :                 int index_j = inode-&gt;Id() - 1;</span></a>
<a name="349"><span class="lineNum">     349 </span><span class="lineNoCov">          0 :                 if (index_j &gt; index_i)</span></a>
<a name="350"><span class="lineNum">     350 </span>            :                 {</a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :                     aux[active] = index_j;</span></a>
<a name="352"><span class="lineNum">     352 </span><span class="lineNoCov">          0 :                     active++;</span></a>
<a name="353"><span class="lineNum">     353 </span>            :                 }</a>
<a name="354"><span class="lineNum">     354 </span>            :             }</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :             std::sort(aux.begin(), aux.begin() + active);</span></a>
<a name="356"><span class="lineNum">     356 </span>            : </a>
<a name="357"><span class="lineNum">     357 </span><span class="lineNoCov">          0 :             for (unsigned int k = 0; k &lt; active; k++)</span></a>
<a name="358"><span class="lineNum">     358 </span>            :             {</a>
<a name="359"><span class="lineNum">     359 </span><span class="lineNoCov">          0 :                 Coord.push_back(index_i, aux[k], -1);</span></a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            :             }</a>
<a name="362"><span class="lineNum">     362 </span>            :         }</a>
<a name="363"><span class="lineNum">     363 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="364"><span class="lineNum">     364 </span>            : </a>
<a name="365"><span class="lineNum">     365 </span>            :     //************************************************************************************************</a>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :     void FirstLoop(ModelPart&amp; this_model_part, boost::numeric::ublas::compressed_matrix&lt;int&gt;&amp; Coord, const array_1d&lt;double, 3 &gt;&amp; versor, const array_1d&lt;double, 3 &gt;&amp; Xp,</span></a>
<a name="368"><span class="lineNum">     368 </span>            :                    int number_of_triangles, DenseVector&lt;int&gt;&amp;  Elems_In_Plane, double tolerance)//</a>
<a name="369"><span class="lineNum">     369 </span>            :     {</a>
<a name="370"><span class="lineNum">     370 </span>            :         //Xp is a random point that belongs to the cutting plane</a>
<a name="371"><span class="lineNum">     371 </span>            :         //versor is a vector normal to the plane</a>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<a name="373"><span class="lineNum">     373 </span>            :         ElementsArrayType&amp; rElements = this_model_part.Elements();</a>
<a name="374"><span class="lineNum">     374 </span>            : </a>
<a name="375"><span class="lineNum">     375 </span>            :         ElementsArrayType::iterator it_begin = rElements.ptr_begin();</a>
<a name="376"><span class="lineNum">     376 </span>            :         ElementsArrayType::iterator it_end = rElements.ptr_end();</a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span>            :         double dist_node_point;          // node to closest point in the plane</a>
<a name="379"><span class="lineNum">     379 </span>            :         double dist_neigh_point;        //other node of the edge (neighbour) to closest point in the plane</a>
<a name="380"><span class="lineNum">     380 </span>            :         //double dist_node_neigh;             //distance between the two nodes of the edge</a>
<a name="381"><span class="lineNum">     381 </span>            :         array_1d&lt;double, 3 &gt; temp_dist;               //aux segment</a>
<a name="382"><span class="lineNum">     382 </span>            :         array_1d&lt;double, 3 &gt; node_coord;             //</a>
<a name="383"><span class="lineNum">     383 </span>            :         array_1d&lt;double, 3 &gt; neigh_coord;             //</a>
<a name="384"><span class="lineNum">     384 </span>            :         array_1d&lt;unsigned int, 4 &gt; list_matching_nodes;             // used to save the new nodes that match exactly old nodes  (very unlikely, but might be 4 for very plane elements)</a>
<a name="385"><span class="lineNum">     385 </span>            :         unsigned int exact_nodes=0;</a>
<a name="386"><span class="lineNum">     386 </span>            : </a>
<a name="387"><span class="lineNum">     387 </span>            :         number_of_triangles =  0;</a>
<a name="388"><span class="lineNum">     388 </span>            :         int current_element= 0; //current element. it's a position. NOT ID!</a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span>            :         int number_of_cuts= 0; //this is the counter explained in the following lines</a>
<a name="391"><span class="lineNum">     391 </span>            : </a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :         for (ElementsArrayType::iterator it = it_begin; it != it_end; ++it) //looping all the elements</span></a>
<a name="393"><span class="lineNum">     393 </span>            :         {</a>
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 :             ++current_element;</span></a>
<a name="395"><span class="lineNum">     395 </span>            :             number_of_cuts = 0 ;</a>
<a name="396"><span class="lineNum">     396 </span>            :             exact_nodes = 0 ;</a>
<a name="397"><span class="lineNum">     397 </span>            :             Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = it-&gt;GetGeometry(); //geometry of the element</a>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :             for(unsigned int i = 0; i &lt; it-&gt;GetGeometry().size() ; i++)          //size = 4 ; nodes per element. NOTICE WE'LL BE LOOPING THE EDGES TWICE. THIS IS A WASTE OF TIME BUT MAKES IT EASIER TO IDENTITY ELEMENTS. LOOK BELOW.</span></a>
<a name="399"><span class="lineNum">     399 </span>            :                 //when we have a triangle inside a thetraedra, its edges (or nodes) must be cut 3 times by the plane. if we loop all 2 times we can have a counter. when it's = 6 then we have a triangle. when tetraedras are cutted 8 times then we have 2 triangles (or a cuatrilateral, the same)</a>
<a name="400"><span class="lineNum">     400 </span>            :             {</a>
<a name="401"><span class="lineNum">     401 </span><span class="lineNoCov">          0 :                 node_coord[0] = geom[i].X();</span></a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :                 node_coord[1] = geom[i].Y();</span></a>
<a name="403"><span class="lineNum">     403 </span><span class="lineNoCov">          0 :                 node_coord[2] = geom[i].Z();</span></a>
<a name="404"><span class="lineNum">     404 </span>            :                 noalias(temp_dist) = node_coord;</a>
<a name="405"><span class="lineNum">     405 </span>            :                 noalias(temp_dist) -= Xp;             //temp_dist =node_coord-Xpoint</a>
<a name="406"><span class="lineNum">     406 </span>            :                 dist_node_point = inner_prod(temp_dist,versor);     // dist = (xnode-xp)*versor closest point-plane distance</a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 for(unsigned int j = 0; j &lt; it-&gt;GetGeometry().size() ; j++)          //  looping on the neighbours</span></a>
<a name="408"><span class="lineNum">     408 </span>            :                 {</a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 :                     if (i != j)  //(cant link node with itself)</span></a>
<a name="410"><span class="lineNum">     410 </span>            :                     {</a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :                         neigh_coord[0] = geom[j].X();</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 :                         neigh_coord[1] = geom[j].Y();</span></a>
<a name="413"><span class="lineNum">     413 </span><span class="lineNoCov">          0 :                         neigh_coord[2] = geom[j].Z();</span></a>
<a name="414"><span class="lineNum">     414 </span>            :                         noalias(temp_dist) = neigh_coord;</a>
<a name="415"><span class="lineNum">     415 </span>            :                         noalias(temp_dist) -= Xp;             //temp_dist =node_coord-Xpoint</a>
<a name="416"><span class="lineNum">     416 </span>            :                         dist_neigh_point = inner_prod(temp_dist,versor);     // dist = (xnode-xp)*versor closest point-plane distance</a>
<a name="417"><span class="lineNum">     417 </span>            :                         //        dist_node_neigh = sqrt( pow((node_coord[0]- neigh_coord[0]),2) + pow((node_coord[1]- neigh_coord[1]),2) + pow((node_coord[2]- neigh_coord[2]),2) ); // looks ugly, doesn't it? it's supposed to calculate the distance</a>
<a name="418"><span class="lineNum">     418 </span>            :                         //now that we have the two points of the edge defined we can check whether it is cut by the plane or not</a>
<a name="419"><span class="lineNum">     419 </span>            :                         bool isovernode=false;   // if true, then it can't be between the nodes</a>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :                         if (fabs(dist_node_point) &lt; (tolerance)) //then our node is part of the plane (this should have been done before the loop on neighbours, but this way it is easier to read .</span></a>
<a name="422"><span class="lineNum">     422 </span>            :                         {</a>
<a name="423"><span class="lineNum">     423 </span><span class="lineNoCov">          0 :                             int index_i = geom[i].Id() -1 ; // i node id</span></a>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 :                             Coord(index_i, index_i) = -2;                     //saving a -2 in the diagonal</span></a>
<a name="425"><span class="lineNum">     425 </span>            :                             isovernode=true;</a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :                             number_of_cuts += 2; //since its neighbour wont take this case as a cut, we must save 2 cuts instead of one. (to reach number_of_cuts=6),</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :                             ++exact_nodes;</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :                             list_matching_nodes[i]= geom[i].Id();</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineNoCov">          0 :                             break;</span></a>
<a name="430"><span class="lineNum">     430 </span>            :                         }</a>
<a name="431"><span class="lineNum">     431 </span>            :                         //check this last condition, used to avoid talking points that belong to other node. might cause some problems when the plane is almost paralel to an edge. to be improved! (it seems to be working correcly even when the edge is part of the plane.)</a>
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 :                         if ((dist_node_point*dist_neigh_point) &lt; 0.0 &amp;&amp; isovernode==false &amp;&amp; (fabs(dist_neigh_point)&gt;(tolerance))) // this means one is on top of the plane and the other on the bottom, no need to do more checks, it's in between!</span></a>
<a name="433"><span class="lineNum">     433 </span>            :                         {</a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 :                             int index_i = geom[i].Id() - 1;     //i node id</span></a>
<a name="435"><span class="lineNum">     435 </span><span class="lineNoCov">          0 :                             int index_j = geom[j].Id() - 1;     //j node id</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :                             if (index_j &gt; index_i)  Coord(index_i, index_j) = -2;    //saving a -2 in the upper side of the matrix</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :                             else Coord(index_j, index_i) = -2;</span></a>
<a name="438"><span class="lineNum">     438 </span><span class="lineNoCov">          0 :                             number_of_cuts += 1;</span></a>
<a name="439"><span class="lineNum">     439 </span>            :                         }</a>
<a name="440"><span class="lineNum">     440 </span>            :                     } //closing the i!=j if</a>
<a name="441"><span class="lineNum">     441 </span>            :                 } //closing the neighbour loop</a>
<a name="442"><span class="lineNum">     442 </span>            :             } //closing the nodes loop</a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span>            :             //now we have to save the data. we should get a list with the elements that will genereate triangles and the total number of triangles</a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :             Elems_In_Plane[current_element-1] = 0 ; //we initialize as 0</span></a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :             if (exact_nodes!=3)   //this means at least one new node has to be generated</span></a>
<a name="447"><span class="lineNum">     447 </span>            :             {</a>
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 :                 if (number_of_cuts == 6)     //it can be 8, in that case we have 2 triangles (the cut generates a square)</span></a>
<a name="449"><span class="lineNum">     449 </span>            :                 {</a>
<a name="450"><span class="lineNum">     450 </span><span class="lineNoCov">          0 :                     number_of_triangles +=1;</span></a>
<a name="451"><span class="lineNum">     451 </span><span class="lineNoCov">          0 :                     Elems_In_Plane[current_element-1] = 1 ; //i still don't know the number of the node so i'll have to do another loop later to assign to define node id's of each triangular element</span></a>
<a name="452"><span class="lineNum">     452 </span>            :                 }</a>
<a name="453"><span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 else if (number_of_cuts == 8 ) // 2 triangles in the element!</span></a>
<a name="454"><span class="lineNum">     454 </span>            :                 {</a>
<a name="455"><span class="lineNum">     455 </span><span class="lineNoCov">          0 :                     number_of_triangles +=2;</span></a>
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 :                     Elems_In_Plane[ current_element-1] = 2 ;</span></a>
<a name="457"><span class="lineNum">     457 </span>            :                 }</a>
<a name="458"><span class="lineNum">     458 </span>            :             }</a>
<a name="459"><span class="lineNum">     459 </span>            :             else   //ok, now we'll only add the element if the normal of the plane matches the one of the triangle (created poiting towards the fourth node of the tetraedra)</a>
<a name="460"><span class="lineNum">     460 </span>            :             {</a>
<a name="461"><span class="lineNum">     461 </span>            :                 bool found_fourth_node=true; //this is the node that defines the normal of the element</a>
<a name="462"><span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 for(unsigned int i = 0; i &lt; it-&gt;GetGeometry().size() ; i++)          //size = 4 ; nodes per element. NOTICE WE'LL BE LOOPING THE EDGES TWICE. THIS IS A WASTE OF TIME BUT MAKES IT EASIER TO IDENTITY ELEMENTS. LOOK BELOW.</span></a>
<a name="463"><span class="lineNum">     463 </span>            :                 {</a>
<a name="464"><span class="lineNum">     464 </span>            :                     found_fourth_node=true;</a>
<a name="465"><span class="lineNum">     465 </span><span class="lineNoCov">          0 :                     for (unsigned int aux_index=0; aux_index!=4; ++aux_index)  // we define our plane now</span></a>
<a name="466"><span class="lineNum">     466 </span>            :                     {</a>
<a name="467"><span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         if (geom[i].Id()==list_matching_nodes[aux_index] &amp;&amp; list_matching_nodes[aux_index]!=0)</span></a>
<a name="468"><span class="lineNum">     468 </span>            :                         {</a>
<a name="469"><span class="lineNum">     469 </span>            :                             found_fourth_node=false;</a>
<a name="470"><span class="lineNum">     470 </span>            :                             //break;   //ok, we have the coordinates of the new node. now we have to mame sure</a>
<a name="471"><span class="lineNum">     471 </span>            :                         }</a>
<a name="472"><span class="lineNum">     472 </span>            :                     }</a>
<a name="473"><span class="lineNum">     473 </span><span class="lineNoCov">          0 :                     if (found_fourth_node==true)</span></a>
<a name="474"><span class="lineNum">     474 </span>            :                     {</a>
<a name="475"><span class="lineNum">     475 </span><span class="lineNoCov">          0 :                         node_coord[0] = geom[i].X();</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :                         node_coord[1] = geom[i].Y();</span></a>
<a name="477"><span class="lineNum">     477 </span><span class="lineNoCov">          0 :                         node_coord[2] = geom[i].Z();</span></a>
<a name="478"><span class="lineNum">     478 </span><span class="lineNoCov">          0 :                         break;</span></a>
<a name="479"><span class="lineNum">     479 </span>            :                     }</a>
<a name="480"><span class="lineNum">     480 </span>            :                 }</a>
<a name="481"><span class="lineNum">     481 </span>            :                 //now we check if the point has a positive distance to the plane. if true we will add a new triangle (property of the element). otherwise not</a>
<a name="482"><span class="lineNum">     482 </span>            :                 //not that this means that this triangle should be added by the neighbour tetraedra( which would return a positive distance)</a>
<a name="483"><span class="lineNum">     483 </span>            :                 //so if we're in a boundary of the domain, make sure that the (normal of) the cutting plane points towards the model. otherwise you'll have missing triangles</a>
<a name="484"><span class="lineNum">     484 </span>            :                 noalias(temp_dist) = node_coord;</a>
<a name="485"><span class="lineNum">     485 </span>            :                 noalias(temp_dist) -= Xp;             //temp_dist =node_coord-Xpoint</a>
<a name="486"><span class="lineNum">     486 </span>            :                 dist_node_point = inner_prod(temp_dist,versor);     // dist = (xnode-xp)*versor closest point-plane distance</a>
<a name="487"><span class="lineNum">     487 </span><span class="lineNoCov">          0 :                 if  (dist_node_point&gt;=0.0)</span></a>
<a name="488"><span class="lineNum">     488 </span>            :                 {</a>
<a name="489"><span class="lineNum">     489 </span><span class="lineNoCov">          0 :                     if (number_of_cuts == 6)    //this should not be necessary, but it's kept just in case (almost plain elements?)</span></a>
<a name="490"><span class="lineNum">     490 </span>            :                     {</a>
<a name="491"><span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         number_of_triangles +=1;</span></a>
<a name="492"><span class="lineNum">     492 </span><span class="lineNoCov">          0 :                         Elems_In_Plane[current_element-1] = 1 ;</span></a>
<a name="493"><span class="lineNum">     493 </span>            :                     }</a>
<a name="494"><span class="lineNum">     494 </span><span class="lineNoCov">          0 :                     else if (number_of_cuts == 8 )</span></a>
<a name="495"><span class="lineNum">     495 </span>            :                     {</a>
<a name="496"><span class="lineNum">     496 </span><span class="lineNoCov">          0 :                         number_of_triangles +=2;</span></a>
<a name="497"><span class="lineNum">     497 </span><span class="lineNoCov">          0 :                         Elems_In_Plane[ current_element-1] = 2 ;</span></a>
<a name="498"><span class="lineNum">     498 </span>            :                     }</a>
<a name="499"><span class="lineNum">     499 </span>            :                 }</a>
<a name="500"><span class="lineNum">     500 </span>            :             }</a>
<a name="501"><span class="lineNum">     501 </span>            :         } //closing the elem loop</a>
<a name="502"><span class="lineNum">     502 </span><span class="lineNoCov">          0 :         KRATOS_WATCH(number_of_triangles);</span></a>
<a name="503"><span class="lineNum">     503 </span>            : </a>
<a name="504"><span class="lineNum">     504 </span><span class="lineNoCov">          0 :     } //closing &quot;FirstLoop&quot;</span></a>
<a name="505"><span class="lineNum">     505 </span>            : </a>
<a name="506"><span class="lineNum">     506 </span>            : </a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :     ///************************************************************************************************</a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span><span class="lineNoCov">          0 :     void Create_List_Of_New_Nodes_Mod(ModelPart&amp; this_model_part, ModelPart&amp; new_model_part, boost::numeric::ublas::compressed_matrix&lt;int&gt;&amp; Coord, DenseVector&lt;int&gt; &amp;List_New_Nodes,</span></a>
<a name="511"><span class="lineNum">     511 </span>            :                                       DenseVector&lt;array_1d&lt;int, 2 &gt; &gt;&amp; Position_Node) //plane number = 1 -- inf (but the first one should be always one!</a>
<a name="512"><span class="lineNum">     512 </span>            :     {</a>
<a name="513"><span class="lineNum">     513 </span>            : </a>
<a name="514"><span class="lineNum">     514 </span>            :         unsigned int number_of_new_nodes = 0;</a>
<a name="515"><span class="lineNum">     515 </span>            :         //NodesArrayType&amp; pNodes = this_model_part.Nodes();</a>
<a name="516"><span class="lineNum">     516 </span>            :         typedef boost::numeric::ublas::compressed_matrix&lt;int&gt;::iterator1 i1_t;</a>
<a name="517"><span class="lineNum">     517 </span>            :         typedef boost::numeric::ublas::compressed_matrix&lt;int&gt;::iterator2 i2_t;</a>
<a name="518"><span class="lineNum">     518 </span>            : </a>
<a name="519"><span class="lineNum">     519 </span>            :         ///*WARNING</a>
<a name="520"><span class="lineNum">     520 </span><span class="lineNoCov">          0 :         for (i1_t i1 = Coord.begin1(); i1 != Coord.end1(); ++i1)</span></a>
<a name="521"><span class="lineNum">     521 </span>            :         {</a>
<a name="522"><span class="lineNum">     522 </span><span class="lineNoCov">          0 :             for (i2_t i2 = i1.begin(); i2 != i1.end(); ++i2)</span></a>
<a name="523"><span class="lineNum">     523 </span>            :             {</a>
<a name="524"><span class="lineNum">     524 </span><span class="lineNoCov">          0 :                 if (Coord(i2.index1(), i2.index2()) == -2)</span></a>
<a name="525"><span class="lineNum">     525 </span>            :                 {</a>
<a name="526"><span class="lineNum">     526 </span><span class="lineNoCov">          0 :                     number_of_new_nodes++;                          //this should work without any change</span></a>
<a name="527"><span class="lineNum">     527 </span>            :                 }</a>
<a name="528"><span class="lineNum">     528 </span>            :             }</a>
<a name="529"><span class="lineNum">     529 </span>            :         }</a>
<a name="530"><span class="lineNum">     530 </span>            : </a>
<a name="531"><span class="lineNum">     531 </span>            :         ///* New Id de los Nodos</a>
<a name="532"><span class="lineNum">     532 </span><span class="lineNoCov">          0 :         List_New_Nodes.resize(number_of_new_nodes);</span></a>
<a name="533"><span class="lineNum">     533 </span>            :         //int total_node = pNodes.size();</a>
<a name="534"><span class="lineNum">     534 </span><span class="lineNoCov">          0 :         if (new_model_part.Nodes().size()!=0)  //it means this is not the first plane that has to be created</span></a>
<a name="535"><span class="lineNum">     535 </span>            :         {</a>
<a name="536"><span class="lineNum">     536 </span>            :             NodesArrayType&amp; rNodes_new = new_model_part.Nodes();        //i need the model part just to check the id of the new nodes.</a>
<a name="537"><span class="lineNum">     537 </span>            :             NodesArrayType::iterator it_end_node_new = rNodes_new.ptr_end();</a>
<a name="538"><span class="lineNum">     538 </span>            :             NodesArrayType::iterator it_begin_node_new = rNodes_new.ptr_begin();</a>
<a name="539"><span class="lineNum">     539 </span><span class="lineNoCov">          0 :             List_New_Nodes[0]=(it_end_node_new-it_begin_node_new)+1;</span></a>
<a name="540"><span class="lineNum">     540 </span>            :             KRATOS_WATCH(&quot;New Cutting Plane&quot;)</a>
<a name="541"><span class="lineNum">     541 </span><span class="lineNoCov">          0 :             first_cutting_plane = false;</span></a>
<a name="542"><span class="lineNum">     542 </span>            :         }</a>
<a name="543"><span class="lineNum">     543 </span>            :         else</a>
<a name="544"><span class="lineNum">     544 </span>            :         {</a>
<a name="545"><span class="lineNum">     545 </span><span class="lineNoCov">          0 :                         if (List_New_Nodes.size() &gt; 0)</span></a>
<a name="546"><span class="lineNum">     546 </span>            :                         {</a>
<a name="547"><span class="lineNum">     547 </span><span class="lineNoCov">          0 :                                 List_New_Nodes[0]=1;</span></a>
<a name="548"><span class="lineNum">     548 </span>            :                                 KRATOS_WATCH(&quot;First Cutting Plane&quot;);</a>
<a name="549"><span class="lineNum">     549 </span><span class="lineNoCov">          0 :                                 first_cutting_plane = true;</span></a>
<a name="550"><span class="lineNum">     550 </span>            :                         }</a>
<a name="551"><span class="lineNum">     551 </span>            :         }</a>
<a name="552"><span class="lineNum">     552 </span>            : </a>
<a name="553"><span class="lineNum">     553 </span><span class="lineNoCov">          0 :         for (unsigned int i = 1; i &lt; number_of_new_nodes; i++)</span></a>
<a name="554"><span class="lineNum">     554 </span>            :         {</a>
<a name="555"><span class="lineNum">     555 </span><span class="lineNoCov">          0 :             List_New_Nodes[i] = List_New_Nodes[0] + i;      //just a list. necessary because other cutting planes might have been generated before</span></a>
<a name="556"><span class="lineNum">     556 </span>            :         }</a>
<a name="557"><span class="lineNum">     557 </span>            : </a>
<a name="558"><span class="lineNum">     558 </span>            :         ///* setting edges -2 to the new id of the new node</a>
<a name="559"><span class="lineNum">     559 </span><span class="lineNoCov">          0 :         Position_Node.resize(number_of_new_nodes);</span></a>
<a name="560"><span class="lineNum">     560 </span>            :         unsigned int index = 0;</a>
<a name="561"><span class="lineNum">     561 </span><span class="lineNoCov">          0 :         for (i1_t i1 = Coord.begin1(); i1 != Coord.end1(); ++i1)</span></a>
<a name="562"><span class="lineNum">     562 </span>            :         {</a>
<a name="563"><span class="lineNum">     563 </span><span class="lineNoCov">          0 :             for (i2_t i2 = i1.begin(); i2 != i1.end(); ++i2)</span></a>
<a name="564"><span class="lineNum">     564 </span>            :             {</a>
<a name="565"><span class="lineNum">     565 </span><span class="lineNoCov">          0 :                 if (Coord(i2.index1(), i2.index2()) == -2)</span></a>
<a name="566"><span class="lineNum">     566 </span>            :                 {</a>
<a name="567"><span class="lineNum">     567 </span><span class="lineNoCov">          0 :                     Coord(i2.index1(), i2.index2()) = List_New_Nodes[index];</span></a>
<a name="568"><span class="lineNum">     568 </span><span class="lineNoCov">          0 :                     Position_Node[index][0] = i2.index1() + 1;</span></a>
<a name="569"><span class="lineNum">     569 </span><span class="lineNoCov">          0 :                     Position_Node[index][1] = i2.index2() + 1;                     //in the diagonal terms both indexes should point to the same node but still should work i guess</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :                     index++;</span></a>
<a name="571"><span class="lineNum">     571 </span>            :                 }</a>
<a name="572"><span class="lineNum">     572 </span>            :             }</a>
<a name="573"><span class="lineNum">     573 </span>            :         }</a>
<a name="574"><span class="lineNum">     574 </span>            : </a>
<a name="575"><span class="lineNum">     575 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="576"><span class="lineNum">     576 </span>            : </a>
<a name="577"><span class="lineNum">     577 </span>            :     ///************************************************************************************************</a>
<a name="578"><span class="lineNum">     578 </span>            : </a>
<a name="579"><span class="lineNum">     579 </span><span class="lineNoCov">          0 :     void Calculate_Coordinate_And_Insert_New_Nodes_Mod(ModelPart&amp; this_model_part, ModelPart&amp; new_model_part,</span></a>
<a name="580"><span class="lineNum">     580 </span>            :             const DenseVector&lt;array_1d&lt;int, 2 &gt; &gt;&amp; Position_Node,</a>
<a name="581"><span class="lineNum">     581 </span>            :             const DenseVector&lt;int&gt; &amp;List_New_Nodes,</a>
<a name="582"><span class="lineNum">     582 </span>            :             const array_1d&lt;double, 3 &gt;&amp; versor, const array_1d&lt;double, 3 &gt;&amp; Xp, double tolerance)//,</a>
<a name="583"><span class="lineNum">     583 </span>            :     {</a>
<a name="584"><span class="lineNum">     584 </span>            : </a>
<a name="585"><span class="lineNum">     585 </span>            :         array_1d&lt;double, 3 &gt; Coord_Node_1;</a>
<a name="586"><span class="lineNum">     586 </span>            :         array_1d&lt;double, 3 &gt; Coord_Node_2;</a>
<a name="587"><span class="lineNum">     587 </span>            :         array_1d&lt;double, 3 &gt; temp_dist;</a>
<a name="588"><span class="lineNum">     588 </span>            :         array_1d&lt;double, 3 &gt; Xp_1;</a>
<a name="589"><span class="lineNum">     589 </span>            :         array_1d&lt;double, 3 &gt; Xp_2;</a>
<a name="590"><span class="lineNum">     590 </span>            :         array_1d&lt;double, 3 &gt; intersection;</a>
<a name="591"><span class="lineNum">     591 </span>            :         double dist_node_point;</a>
<a name="592"><span class="lineNum">     592 </span>            : //        double dist_node_neigh;</a>
<a name="593"><span class="lineNum">     593 </span>            :         //double dist_neigh_point;</a>
<a name="594"><span class="lineNum">     594 </span>            :         double dist_node_intersect;</a>
<a name="595"><span class="lineNum">     595 </span>            :         double weight;</a>
<a name="596"><span class="lineNum">     596 </span>            :         DenseVector&lt; array_1d&lt;double, 3 &gt; &gt; Coordinate_New_Node;</a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :         Coordinate_New_Node.resize(Position_Node.size());</span></a>
<a name="598"><span class="lineNum">     598 </span>            :         //unsigned int step_data_size = this_model_part.GetNodalSolutionStepDataSize();</a>
<a name="599"><span class="lineNum">     599 </span>            :         //Node &lt; 3 &gt; ::DofsContainerType&amp; reference_dofs = (this_model_part.NodesBegin())-&gt;GetDofs();</a>
<a name="600"><span class="lineNum">     600 </span>            : </a>
<a name="601"><span class="lineNum">     601 </span><span class="lineNoCov">          0 :         for (unsigned int i = 0; i &lt; Position_Node.size(); i++) //looping the new nodes</span></a>
<a name="602"><span class="lineNum">     602 </span>            :         {</a>
<a name="603"><span class="lineNum">     603 </span>            : </a>
<a name="604"><span class="lineNum">     604 </span>            :             /// calculating the coordinate of the new nodes</a>
<a name="605"><span class="lineNum">     605 </span>            :             const int&amp; node_i = Position_Node[i][0];</a>
<a name="606"><span class="lineNum">     606 </span>            :             const int&amp; node_j = Position_Node[i][1];</a>
<a name="607"><span class="lineNum">     607 </span><span class="lineNoCov">          0 :             auto it_node1 = this_model_part.Nodes()(node_i);</span></a>
<a name="608"><span class="lineNum">     608 </span>            :             //std::size_t pos1 = it_node1 - this_model_part.NodesBegin();</a>
<a name="609"><span class="lineNum">     609 </span>            :             noalias(Coord_Node_1) = it_node1-&gt;Coordinates();</a>
<a name="610"><span class="lineNum">     610 </span><span class="lineNoCov">          0 :             auto it_node2 = this_model_part.Nodes()(node_j);</span></a>
<a name="611"><span class="lineNum">     611 </span>            :             //std::size_t pos2 = it_node2 - this_model_part.NodesBegin();</a>
<a name="612"><span class="lineNum">     612 </span>            :             noalias(Coord_Node_2) = it_node2-&gt;Coordinates();</a>
<a name="613"><span class="lineNum">     613 </span>            :             //ok, now we have both coordinates. now we must define a weight coefficient based on the distance.</a>
<a name="614"><span class="lineNum">     614 </span>            :             //this coeff will be =node_plane_distance/node_neigh_distance (linear interpolation)</a>
<a name="615"><span class="lineNum">     615 </span>            :             noalias(temp_dist) = Coord_Node_1;</a>
<a name="616"><span class="lineNum">     616 </span>            :             noalias(temp_dist) -= Xp;             //temp_dist =node_coord-Xpoint</a>
<a name="617"><span class="lineNum">     617 </span>            :             dist_node_point = inner_prod(temp_dist,versor);     // dist = (xnode-xp)*versor closest point-plane distance</a>
<a name="618"><span class="lineNum">     618 </span><span class="lineNoCov">          0 :             dist_node_point = fabs (dist_node_point);</span></a>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<a name="620"><span class="lineNum">     620 </span><span class="lineNoCov">          0 :             Xp_1 = Xp - Coord_Node_1;</span></a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :             Xp_2 = Coord_Node_2 - Coord_Node_1;</span></a>
<a name="622"><span class="lineNum">     622 </span><span class="lineNoCov">          0 :             dist_node_intersect = (inner_prod(versor,Xp_1)) / (inner_prod(versor,Xp_2)) ; //line-plane interesection, this is a RELATIVE distance. ====&gt;   point= Node1 + (Node2-Node1)*dist_node_intersect</span></a>
<a name="623"><span class="lineNum">     623 </span>            : //            dist_node_neigh = sqrt( pow((Coord_Node_1[0]- Coord_Node_2[0]),2) + pow((Coord_Node_1[1]- Coord_Node_2[1]),2) + pow((Coord_Node_1[2]- Coord_Node_2[2]),2) ) ; // distance between node and neighbour</a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :             if (dist_node_point&lt;=(tolerance))  dist_node_intersect=0.0;  // if it's too close to the first node then we just set the weight as 1</span></a>
<a name="625"><span class="lineNum">     625 </span><span class="lineNoCov">          0 :             weight = (1.0 - dist_node_intersect) ;  // dist_node_neigh;</span></a>
<a name="626"><span class="lineNum">     626 </span>            :             //weight = dist_node_point / dist_node_neigh ; MAL!</a>
<a name="627"><span class="lineNum">     627 </span>            :             //noalias(Weight_New_Nodes[i]) = weight;</a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :             if (weight &gt; 1.05) KRATOS_WATCH(&quot;**** something's wrong! weight higher than 1! ****&quot;);</span></a>
<a name="629"><span class="lineNum">     629 </span>            :             //KRATOS_WATCH(i); KRATOS_WATCH(weight);</a>
<a name="630"><span class="lineNum">     630 </span><span class="lineNoCov">          0 :             for (unsigned int index=0; index!=3; ++index) //we loop the 3 coordinates)</span></a>
<a name="631"><span class="lineNum">     631 </span><span class="lineNoCov">          0 :                 if (Position_Node[i][0]!=Position_Node[i][1])</span></a>
<a name="632"><span class="lineNum">     632 </span><span class="lineNoCov">          0 :                     Coordinate_New_Node[i][index] = Coord_Node_1[index] + (dist_node_intersect) * (Coord_Node_2[index] - Coord_Node_1[index]);</span></a>
<a name="633"><span class="lineNum">     633 </span>            :                 else</a>
<a name="634"><span class="lineNum">     634 </span><span class="lineNoCov">          0 :                     Coordinate_New_Node[i][index] = Coord_Node_1[index]; //when both nodes are the same it doesnt make any sense to interpolate</span></a>
<a name="635"><span class="lineNum">     635 </span>            : </a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :             temp_dist= Coordinate_New_Node[i] - Xp;</span></a>
<a name="637"><span class="lineNum">     637 </span>            :             dist_node_point = inner_prod(versor,temp_dist);</a>
<a name="638"><span class="lineNum">     638 </span>            :             /// inserting the new node in the model part</a>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 :             Node &lt; 3 &gt; ::Pointer pnode = new_model_part.CreateNewNode(List_New_Nodes[i], Coordinate_New_Node[i][0], Coordinate_New_Node[i][1], Coordinate_New_Node[i][2]);  //recordar que es el nueevo model part!!</span></a>
<a name="640"><span class="lineNum">     640 </span>            :             pnode-&gt;SetBufferSize(this_model_part.NodesBegin()-&gt;GetBufferSize());</a>
<a name="641"><span class="lineNum">     641 </span>            : </a>
<a name="642"><span class="lineNum">     642 </span>            :             //it_node1 = this_model_part.NodesBegin() + pos1;</a>
<a name="643"><span class="lineNum">     643 </span>            :             //it_node2 = this_model_part.NodesBegin() + pos2;</a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span>            :             pnode-&gt;GetValue(FATHER_NODES).resize(0);</a>
<a name="646"><span class="lineNum">     646 </span><span class="lineNoCov">          0 :             pnode-&gt;GetValue(FATHER_NODES).push_back( Node&lt;3&gt;::WeakPointer( it_node1 ) );       //saving data about fathers in the model part</span></a>
<a name="647"><span class="lineNum">     647 </span><span class="lineNoCov">          0 :             pnode-&gt;GetValue(FATHER_NODES).push_back( Node&lt;3&gt;::WeakPointer( it_node2 ) );</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineNoCov">          0 :             pnode-&gt; GetValue(WEIGHT_FATHER_NODES) = weight;</span></a>
<a name="649"><span class="lineNum">     649 </span>            : </a>
<a name="650"><span class="lineNum">     650 </span><span class="lineNoCov">          0 :             pnode-&gt;X0() = weight * (it_node1-&gt;X0())  +  (1.0 - weight) * it_node2-&gt;X0();</span></a>
<a name="651"><span class="lineNum">     651 </span><span class="lineNoCov">          0 :             pnode-&gt;Y0() = weight * (it_node1-&gt;Y0())  +  (1.0 - weight) * it_node2-&gt;Y0();</span></a>
<a name="652"><span class="lineNum">     652 </span><span class="lineNoCov">          0 :             pnode-&gt;Z0() = weight * (it_node1-&gt;Z0())  +  (1.0 - weight) * it_node2-&gt;Z0();</span></a>
<a name="653"><span class="lineNum">     653 </span>            :         }</a>
<a name="654"><span class="lineNum">     654 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="655"><span class="lineNum">     655 </span>            : </a>
<a name="656"><span class="lineNum">     656 </span>            :     ///**********************************************************************************</a>
<a name="657"><span class="lineNum">     657 </span>            : </a>
<a name="658"><span class="lineNum">     658 </span>            : </a>
<a name="659"><span class="lineNum">     659 </span><span class="lineNoCov">          0 :     void GenerateElements (ModelPart&amp; this_model_part, ModelPart&amp; new_model_part, DenseVector&lt;int&gt; Elems_In_Plane, boost::numeric::ublas::compressed_matrix&lt;int&gt;&amp; Coord, const array_1d&lt;double, 3 &gt;&amp; versor, int plane_number)</span></a>
<a name="660"><span class="lineNum">     660 </span>            :     {</a>
<a name="661"><span class="lineNum">     661 </span>            :         array_1d&lt;double, 3 &gt; temp_vector1;</a>
<a name="662"><span class="lineNum">     662 </span>            :         array_1d&lt;double, 3 &gt; temp_vector2;</a>
<a name="663"><span class="lineNum">     663 </span>            :         array_1d&lt;double, 3 &gt; temp_vector3;</a>
<a name="664"><span class="lineNum">     664 </span>            :         array_1d&lt;double, 3 &gt; temp_vector4;</a>
<a name="665"><span class="lineNum">     665 </span>            :         array_1d&lt;double, 3 &gt; temp_vector5;</a>
<a name="666"><span class="lineNum">     666 </span>            :         array_1d&lt;int, 6 &gt; nodes_for_2triang; //to be used when there are 2 triangles</a>
<a name="667"><span class="lineNum">     667 </span>            :         double dist2; //to be used when there are 2 triangles in the tetraedra</a>
<a name="668"><span class="lineNum">     668 </span>            :         double dist3;</a>
<a name="669"><span class="lineNum">     669 </span>            :         double control;</a>
<a name="670"><span class="lineNum">     670 </span>            :         unsigned int temp_int;</a>
<a name="671"><span class="lineNum">     671 </span>            :         unsigned int first_element=0;</a>
<a name="672"><span class="lineNum">     672 </span>            : </a>
<a name="673"><span class="lineNum">     673 </span>            :         ElementsArrayType&amp; rElements_old = this_model_part.Elements();</a>
<a name="674"><span class="lineNum">     674 </span>            :         ElementsArrayType::iterator it_begin_old = rElements_old.ptr_begin();</a>
<a name="675"><span class="lineNum">     675 </span>            :         ElementsArrayType::iterator it_end_old = rElements_old.ptr_end();</a>
<a name="676"><span class="lineNum">     676 </span>            : </a>
<a name="677"><span class="lineNum">     677 </span>            :         ElementsArrayType&amp; rElements_new = new_model_part.Elements();</a>
<a name="678"><span class="lineNum">     678 </span>            :         ElementsArrayType::iterator it_begin_new = rElements_new.ptr_begin();</a>
<a name="679"><span class="lineNum">     679 </span>            :         ElementsArrayType::iterator it_end_new = rElements_new.ptr_end();</a>
<a name="680"><span class="lineNum">     680 </span>            : </a>
<a name="681"><span class="lineNum">     681 </span><span class="lineNoCov">          0 :         if (first_cutting_plane == false)  //it means this is not the first plane that has to be created</span></a>
<a name="682"><span class="lineNum">     682 </span>            :         {</a>
<a name="683"><span class="lineNum">     683 </span><span class="lineNoCov">          0 :             first_element=(it_end_new-it_begin_new);</span></a>
<a name="684"><span class="lineNum">     684 </span>            :             KRATOS_WATCH(&quot;New Cutting Plane&quot;)</a>
<a name="685"><span class="lineNum">     685 </span>            :             KRATOS_WATCH(first_element)</a>
<a name="686"><span class="lineNum">     686 </span>            :         }</a>
<a name="687"><span class="lineNum">     687 </span>            :         else</a>
<a name="688"><span class="lineNum">     688 </span>            :         {</a>
<a name="689"><span class="lineNum">     689 </span>            :             first_element=0;                      //or we're creating the first elements of the model part</a>
<a name="690"><span class="lineNum">     690 </span>            :             KRATOS_WATCH(&quot;First Cutting Plane&quot;);</a>
<a name="691"><span class="lineNum">     691 </span>            :         }</a>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<a name="693"><span class="lineNum">     693 </span><span class="lineNoCov">          0 :         Condition const&amp; rReferenceCondition = KratosComponents&lt;Condition&gt;::Get(&quot;SurfaceCondition3D3N&quot;);</span></a>
<a name="694"><span class="lineNum">     694 </span><span class="lineNoCov">          0 :         Properties::Pointer properties = this_model_part.GetMesh().pGetProperties(plane_number);</span></a>
<a name="695"><span class="lineNum">     695 </span>            : </a>
<a name="696"><span class="lineNum">     696 </span>            :         int number_of_triangles =  0;</a>
<a name="697"><span class="lineNum">     697 </span>            :         int current_element= 0;</a>
<a name="698"><span class="lineNum">     698 </span>            :         unsigned int triangle_nodes= 0;  // number of nodes already saved (of the current element)</a>
<a name="699"><span class="lineNum">     699 </span>            :         bool new_node = false ; //used to check whether the current node has been saved or not</a>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<a name="701"><span class="lineNum">     701 </span>            :         array_1d&lt;int, 4 &gt; TriangleNodesArray; //nodes of the element to be generated. 4 in case they're 2 triangles</a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :         for (unsigned int k=0; k!=4; ++k)</span></a>
<a name="703"><span class="lineNum">     703 </span>            :         {</a>
<a name="704"><span class="lineNum">     704 </span><span class="lineNoCov">          0 :             TriangleNodesArray[k] = -1;   //initializing in -1, meaning we have no nodes yet</span></a>
<a name="705"><span class="lineNum">     705 </span>            :         }</a>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<a name="707"><span class="lineNum">     707 </span>            :         ///we enter the element loop</a>
<a name="708"><span class="lineNum">     708 </span><span class="lineNoCov">          0 :         for (ElementsArrayType::iterator it = it_begin_old; it != it_end_old; ++it)</span></a>
<a name="709"><span class="lineNum">     709 </span>            :         {</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineNoCov">          0 :             ++current_element;</span></a>
<a name="711"><span class="lineNum">     711 </span>            :             triangle_nodes = 0; //starting, no nodes yet</a>
<a name="712"><span class="lineNum">     712 </span>            :             ///we eter in the if for only one triangle in the tetraedra</a>
<a name="713"><span class="lineNum">     713 </span><span class="lineNoCov">          0 :             if (Elems_In_Plane[current_element-1] == 1 ) //do not forget than can be both 1 or 2 triangles per tetraedra. this is the simplest case. no need to check anything, we just create an element with the 3 nodes</span></a>
<a name="714"><span class="lineNum">     714 </span>            :             {</a>
<a name="715"><span class="lineNum">     715 </span>            :                 //checking element conectivities</a>
<a name="716"><span class="lineNum">     716 </span><span class="lineNoCov">          0 :                 for(unsigned int i = 0; i &lt; it-&gt;GetGeometry().size() ; i++)</span></a>
<a name="717"><span class="lineNum">     717 </span>            :                 {</a>
<a name="718"><span class="lineNum">     718 </span>            :                     Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = it-&gt;GetGeometry(); //i node of the element</a>
<a name="719"><span class="lineNum">     719 </span><span class="lineNoCov">          0 :                     for(unsigned int j = 0; j &lt; it-&gt;GetGeometry().size() ; j++) //j node of the element</span></a>
<a name="720"><span class="lineNum">     720 </span>            :                     {</a>
<a name="721"><span class="lineNum">     721 </span>            :                         new_node= true; //by default it's a new node</a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :                         int index_i = geom[i].Id() - 1;     //i node id</span></a>
<a name="723"><span class="lineNum">     723 </span><span class="lineNoCov">          0 :                         int index_j = geom[j].Id() - 1;</span></a>
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 :                         for (unsigned int l=0; l!=3; ++l)</span></a>
<a name="725"><span class="lineNum">     725 </span>            :                         {</a>
<a name="726"><span class="lineNum">     726 </span><span class="lineNoCov">          0 :                             if(TriangleNodesArray[l]==Coord(index_i, index_j) //if we have already saved this node or it has not been cutted, then we have no new node to add (coord(i,j)=-1)</span></a>
<a name="727"><span class="lineNum">     727 </span><span class="lineNoCov">          0 :                                     || Coord(index_i, index_j) &lt;1 )</span></a>
<a name="728"><span class="lineNum">     728 </span>            :                                 new_node=false;</a>
<a name="729"><span class="lineNum">     729 </span>            :                         }</a>
<a name="730"><span class="lineNum">     730 </span>            :                         //if it's a new node and the indexes are correct:</a>
<a name="731"><span class="lineNum">     731 </span><span class="lineNoCov">          0 :                         if (new_node &amp;&amp; index_i&lt;=index_j)</span></a>
<a name="732"><span class="lineNum">     732 </span>            :                         {</a>
<a name="733"><span class="lineNum">     733 </span><span class="lineNoCov">          0 :                             TriangleNodesArray[triangle_nodes]=Coord(index_i, index_j) ;</span></a>
<a name="734"><span class="lineNum">     734 </span><span class="lineNoCov">          0 :                             triangle_nodes++;</span></a>
<a name="735"><span class="lineNum">     735 </span>            :                         }</a>
<a name="736"><span class="lineNum">     736 </span><span class="lineNoCov">          0 :                         if (triangle_nodes ==3) break;               //if we have already found 3 nodes then we can exit</span></a>
<a name="737"><span class="lineNum">     737 </span>            :                     } //closing j node loop</a>
<a name="738"><span class="lineNum">     738 </span><span class="lineNoCov">          0 :                     if (triangle_nodes ==3) break;               //egal</span></a>
<a name="739"><span class="lineNum">     739 </span>            :                 } //closing j node loop</a>
<a name="740"><span class="lineNum">     740 </span>            :                 //now we have to check that the normal of the element matches the one of the plane (they could have opposite directions)</a>
<a name="741"><span class="lineNum">     741 </span><span class="lineNoCov">          0 :                 ModelPart::NodesContainerType::iterator it_node1 =  new_model_part.Nodes().find(TriangleNodesArray[0]);</span></a>
<a name="742"><span class="lineNum">     742 </span>            :                 noalias(temp_vector1) = it_node1-&gt;Coordinates(); //node 1</a>
<a name="743"><span class="lineNum">     743 </span>            : </a>
<a name="744"><span class="lineNum">     744 </span><span class="lineNoCov">          0 :                 it_node1 = new_model_part.Nodes().find(TriangleNodesArray[1]);</span></a>
<a name="745"><span class="lineNum">     745 </span>            :                 noalias(temp_vector2) = it_node1-&gt;Coordinates(); //node 2</a>
<a name="746"><span class="lineNum">     746 </span>            : </a>
<a name="747"><span class="lineNum">     747 </span><span class="lineNoCov">          0 :                 it_node1 = new_model_part.Nodes().find(TriangleNodesArray[2]);</span></a>
<a name="748"><span class="lineNum">     748 </span>            :                 noalias(temp_vector3) = it_node1-&gt;Coordinates(); //nodo 3</a>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<a name="750"><span class="lineNum">     750 </span>            :                 temp_vector3 -=temp_vector1; //first edge</a>
<a name="751"><span class="lineNum">     751 </span>            :                 temp_vector2 -=temp_vector1; //second edge</a>
<a name="752"><span class="lineNum">     752 </span>            : </a>
<a name="753"><span class="lineNum">     753 </span>            : </a>
<a name="754"><span class="lineNum">     754 </span>            :                 MathUtils&lt;double&gt;::CrossProduct(temp_vector4, temp_vector2 , temp_vector3) ; //multiplying the 2 edges gives us a normal vector to the element</a>
<a name="755"><span class="lineNum">     755 </span>            : </a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :                 if (inner_prod(temp_vector4,versor)&lt;0.0) //if the signs do not match then they have opposite directions</span></a>
<a name="757"><span class="lineNum">     757 </span>            :                 {</a>
<a name="758"><span class="lineNum">     758 </span>            :                     temp_int= TriangleNodesArray[2];</a>
<a name="759"><span class="lineNum">     759 </span><span class="lineNoCov">          0 :                     TriangleNodesArray[2] =  TriangleNodesArray[1];</span></a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :                     TriangleNodesArray[1] =  temp_int;              //we switch 2 nodes and ready</span></a>
<a name="761"><span class="lineNum">     761 </span>            :                 }</a>
<a name="762"><span class="lineNum">     762 </span>            : </a>
<a name="763"><span class="lineNum">     763 </span>            :                 //generate new Elements</a>
<a name="764"><span class="lineNum">     764 </span>            :                 Triangle3D3&lt;Node&lt;3&gt; &gt; geom(</a>
<a name="765"><span class="lineNum">     765 </span><span class="lineNoCov">          0 :                     new_model_part.Nodes()(TriangleNodesArray[0]),</span></a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :                     new_model_part.Nodes()(TriangleNodesArray[1]),</span></a>
<a name="767"><span class="lineNum">     767 </span><span class="lineNoCov">          0 :                     new_model_part.Nodes()(TriangleNodesArray[2])</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineNoCov">          0 :                 );</span></a>
<a name="769"><span class="lineNum">     769 </span>            : </a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :                 Condition::Pointer p_condition = rReferenceCondition.Create(number_of_triangles+1+first_element, geom, properties); //creating the element using the reference element. notice we are using the first element to avoid overriting nodes created by other cutting planes</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :                 new_model_part.Conditions().push_back(p_condition);</span></a>
<a name="772"><span class="lineNum">     772 </span><span class="lineNoCov">          0 :                 ++number_of_triangles;</span></a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span><span class="lineNoCov">          0 :                 for (int counter=0; counter!=4; ++counter) TriangleNodesArray[counter]=0;</span></a>
<a name="775"><span class="lineNum">     775 </span>            :             }//closing if elems_in_plane==6 (1 triangle)</a>
<a name="776"><span class="lineNum">     776 </span>            : </a>
<a name="777"><span class="lineNum">     777 </span>            : </a>
<a name="778"><span class="lineNum">     778 </span>            :             ///entering now the if for 2 triangles inside the tetraedra.</a>
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :             if (Elems_In_Plane[current_element-1] == 2)  //now we have 2 elements. we cant just create 2 elements with a random node order because they might overlap and not cover the whole area defined by the trapezoid</span></a>
<a name="780"><span class="lineNum">     780 </span>            :             {</a>
<a name="781"><span class="lineNum">     781 </span>            :                 //to fix this we'll first create a plane. see below</a>
<a name="782"><span class="lineNum">     782 </span>            : </a>
<a name="783"><span class="lineNum">     783 </span>            :                 //checking conectivities to find nodes</a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :                 for(unsigned int i = 0; i &lt; it-&gt;GetGeometry().size() ; i++) //nodo i</span></a>
<a name="785"><span class="lineNum">     785 </span>            :                 {</a>
<a name="786"><span class="lineNum">     786 </span>            :                     Geometry&lt;Node&lt;3&gt; &gt;&amp;geom = it-&gt;GetGeometry();</a>
<a name="787"><span class="lineNum">     787 </span><span class="lineNoCov">          0 :                     for(unsigned int j = 0; j &lt; it-&gt;GetGeometry().size() ; j++) //nodo j</span></a>
<a name="788"><span class="lineNum">     788 </span>            :                     {</a>
<a name="789"><span class="lineNum">     789 </span>            :                         new_node= true;</a>
<a name="790"><span class="lineNum">     790 </span><span class="lineNoCov">          0 :                         int index_i = geom[i].Id() - 1;</span></a>
<a name="791"><span class="lineNum">     791 </span><span class="lineNoCov">          0 :                         int index_j = geom[j].Id() - 1;</span></a>
<a name="792"><span class="lineNum">     792 </span><span class="lineNoCov">          0 :                         for (unsigned int l=0; l!=3; ++l)</span></a>
<a name="793"><span class="lineNum">     793 </span>            :                         {</a>
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 :                             if(TriangleNodesArray[l]==Coord(index_i, index_j) //same as the part with only one triangle (look above)</span></a>
<a name="795"><span class="lineNum">     795 </span><span class="lineNoCov">          0 :                                     || Coord(index_i, index_j) &lt; 1 )</span></a>
<a name="796"><span class="lineNum">     796 </span>            :                             {</a>
<a name="797"><span class="lineNum">     797 </span>            :                                 new_node=false;</a>
<a name="798"><span class="lineNum">     798 </span>            :                             }</a>
<a name="799"><span class="lineNum">     799 </span>            :                         }</a>
<a name="800"><span class="lineNum">     800 </span><span class="lineNoCov">          0 :                         if (new_node &amp;&amp; index_i&lt;index_j)</span></a>
<a name="801"><span class="lineNum">     801 </span>            :                         {</a>
<a name="802"><span class="lineNum">     802 </span><span class="lineNoCov">          0 :                             TriangleNodesArray[triangle_nodes]=Coord(index_i, index_j) ;</span></a>
<a name="803"><span class="lineNum">     803 </span><span class="lineNoCov">          0 :                             triangle_nodes++;</span></a>
<a name="804"><span class="lineNum">     804 </span>            :                         }</a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :                         if (triangle_nodes ==4) break;               //once we've found the 4 nodes we can exit</span></a>
<a name="806"><span class="lineNum">     806 </span>            :                     } //closing i loop</a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 :                     if (triangle_nodes ==4) break;</span></a>
<a name="808"><span class="lineNum">     808 </span>            :                 }</a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span>            :                 //now we have to start checking the angles. the easiest way (i think) is creating a new plane using the original plane and a segment created by 2 nodes</a>
<a name="811"><span class="lineNum">     811 </span>            :                 // using crossproduct we get a perpendicular plane. (either point can be used as origin).</a>
<a name="812"><span class="lineNum">     812 </span>            :                 //since the cuadrilateral is created by the cut of teatraedra,</a>
<a name="813"><span class="lineNum">     813 </span>            :                 //none of its internal angles can exceed 180 degrees and hence our new plane divides the cuadrilateral into 2 triangles if the distances to the other points have different signs (one on top and the other on the bottom of this new plane)</a>
<a name="814"><span class="lineNum">     814 </span>            :                 //otherwise this edge is just an edge of the cuadrilateral and we have to look for another.</a>
<a name="815"><span class="lineNum">     815 </span>            :                 //so let's begin! (we'll keep an origin node and we'll loop different nodes as the end of the segment till we find one that satisfies our criteria)</a>
<a name="816"><span class="lineNum">     816 </span><span class="lineNoCov">          0 :                 ModelPart::NodesContainerType::iterator it_node1 =  new_model_part.Nodes().find(TriangleNodesArray[0]);</span></a>
<a name="817"><span class="lineNum">     817 </span>            :                 noalias(temp_vector1) = it_node1-&gt;Coordinates(); //nodo 1 (origin)</a>
<a name="818"><span class="lineNum">     818 </span>            :                 int jjj;</a>
<a name="819"><span class="lineNum">     819 </span>            :                 int kkk;</a>
<a name="820"><span class="lineNum">     820 </span>            : </a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :                 for (int iii=1; iii!=4; ++iii)     //end node of the segment that will be used to create the plane (will be contained too)</span></a>
<a name="822"><span class="lineNum">     822 </span>            :                 {</a>
<a name="823"><span class="lineNum">     823 </span>            :                     //  KRATOS_WATCH(iii);</a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :                     it_node1=new_model_part.Nodes().find(TriangleNodesArray[iii]); //i node. we always keep node 0 as origin</span></a>
<a name="825"><span class="lineNum">     825 </span>            :                     noalias(temp_vector2) = it_node1-&gt;Coordinates(); //node2 (end)</a>
<a name="826"><span class="lineNum">     826 </span>            :                     noalias(temp_vector3) = temp_vector2 - temp_vector1; //segment 1-2</a>
<a name="827"><span class="lineNum">     827 </span>            :                     //now i have to create the new plane</a>
<a name="828"><span class="lineNum">     828 </span>            :                     MathUtils&lt;double&gt;::CrossProduct(temp_vector4, versor , temp_vector3); //done. now temp_vector4 is the (normal to the) new plane, perpendicular to the one containing the triangles</a>
<a name="829"><span class="lineNum">     829 </span>            :                     //the origin of the plane is temp_vector1 (temp_vector2 could also be used)</a>
<a name="830"><span class="lineNum">     830 </span>            :                     //now we need to check distances to the other nodes (i+2 (let's call them jjj and i+3=kkk since we can't go futher than i=3)</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 :                     if (iii==1)</span></a>
<a name="832"><span class="lineNum">     832 </span>            :                     {</a>
<a name="833"><span class="lineNum">     833 </span>            :                         jjj=2;</a>
<a name="834"><span class="lineNum">     834 </span>            :                         kkk=3;</a>
<a name="835"><span class="lineNum">     835 </span>            :                     }</a>
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 :                     else if (iii==2)</span></a>
<a name="837"><span class="lineNum">     837 </span>            :                     {</a>
<a name="838"><span class="lineNum">     838 </span>            :                         jjj=3;</a>
<a name="839"><span class="lineNum">     839 </span>            :                         kkk=1;</a>
<a name="840"><span class="lineNum">     840 </span>            :                     }</a>
<a name="841"><span class="lineNum">     841 </span>            :                     else</a>
<a name="842"><span class="lineNum">     842 </span>            :                     {</a>
<a name="843"><span class="lineNum">     843 </span>            :                         jjj=2;</a>
<a name="844"><span class="lineNum">     844 </span>            :                         kkk=1;</a>
<a name="845"><span class="lineNum">     845 </span>            :                     }</a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :                     it_node1=new_model_part.Nodes().find(TriangleNodesArray[jjj]);</span></a>
<a name="848"><span class="lineNum">     848 </span>            :                     noalias(temp_vector2) = it_node1-&gt;Coordinates(); //one of the remaining nodes;</a>
<a name="849"><span class="lineNum">     849 </span>            : </a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :                     it_node1=new_model_part.Nodes().find(TriangleNodesArray[kkk]);</span></a>
<a name="851"><span class="lineNum">     851 </span>            :                     noalias(temp_vector3) = it_node1-&gt;Coordinates(); //the other remaining node;</a>
<a name="852"><span class="lineNum">     852 </span>            : </a>
<a name="853"><span class="lineNum">     853 </span>            :                     noalias(temp_vector2) -=temp_vector1;   // minus origin point of the plane</a>
<a name="854"><span class="lineNum">     854 </span>            :                     noalias(temp_vector3) -=temp_vector1;</a>
<a name="855"><span class="lineNum">     855 </span>            : </a>
<a name="856"><span class="lineNum">     856 </span>            :                     dist2= inner_prod(temp_vector2,temp_vector4);  // dot product</a>
<a name="857"><span class="lineNum">     857 </span>            :                     dist3= inner_prod(temp_vector3,temp_vector4);</a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :                     control=dist2*dist3;</span></a>
<a name="859"><span class="lineNum">     859 </span>            :                     //and that's it. we now have to check if the distance have different signs. to do so we multiply :</a>
<a name="860"><span class="lineNum">     860 </span><span class="lineNoCov">          0 :                     if (control&lt;0.0) //we have the right one! one node on each side of the plane generated by nodes 0 and iii</span></a>
<a name="861"><span class="lineNum">     861 </span>            :                     {</a>
<a name="862"><span class="lineNum">     862 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[0] = TriangleNodesArray[0] ;</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[1] = TriangleNodesArray[jjj];</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[2] = TriangleNodesArray[iii]; //finish first triangle</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[3] = TriangleNodesArray[iii];</span></a>
<a name="866"><span class="lineNum">     866 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[4] = TriangleNodesArray[kkk];</span></a>
<a name="867"><span class="lineNum">     867 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[5] = TriangleNodesArray[0]; //finish 2nd triangle</span></a>
<a name="868"><span class="lineNum">     868 </span>            :                         //      KRATOS_WATCH(nodes_for_2triang);</a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :                         break; //no need to keep looking, we can exit the loop</span></a>
<a name="870"><span class="lineNum">     870 </span>            : </a>
<a name="871"><span class="lineNum">     871 </span>            :                     } //closing the if</a>
<a name="872"><span class="lineNum">     872 </span>            : </a>
<a name="873"><span class="lineNum">     873 </span>            :                 }//by the time this finishes i should already have TriangleNodesArray</a>
<a name="874"><span class="lineNum">     874 </span>            : </a>
<a name="875"><span class="lineNum">     875 </span>            : </a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span>            : </a>
<a name="878"><span class="lineNum">     878 </span>            :                 //checking if the normal to our element is oriented correctly, just as we did when we had only 1 triangle (not commented here)</a>
<a name="879"><span class="lineNum">     879 </span><span class="lineNoCov">          0 :                 for (int index=0 ; index !=2 ; ++index) //for triangle 1 and 2</span></a>
<a name="880"><span class="lineNum">     880 </span>            :                 {</a>
<a name="881"><span class="lineNum">     881 </span>            : </a>
<a name="882"><span class="lineNum">     882 </span><span class="lineNoCov">          0 :                     it_node1 =  new_model_part.Nodes().find(nodes_for_2triang[index*3+0]);</span></a>
<a name="883"><span class="lineNum">     883 </span>            :                     noalias(temp_vector1) = it_node1-&gt;Coordinates(); //node 1</a>
<a name="884"><span class="lineNum">     884 </span>            : </a>
<a name="885"><span class="lineNum">     885 </span><span class="lineNoCov">          0 :                     it_node1 = new_model_part.Nodes().find(nodes_for_2triang[index*3+1]);</span></a>
<a name="886"><span class="lineNum">     886 </span>            :                     noalias(temp_vector2) = it_node1-&gt;Coordinates(); //node 2</a>
<a name="887"><span class="lineNum">     887 </span>            : </a>
<a name="888"><span class="lineNum">     888 </span><span class="lineNoCov">          0 :                     it_node1 = new_model_part.Nodes().find(nodes_for_2triang[index*3+2]);</span></a>
<a name="889"><span class="lineNum">     889 </span>            :                     noalias(temp_vector3) = it_node1-&gt;Coordinates(); //node 3</a>
<a name="890"><span class="lineNum">     890 </span>            : </a>
<a name="891"><span class="lineNum">     891 </span>            :                     temp_vector3 -=temp_vector1;</a>
<a name="892"><span class="lineNum">     892 </span>            :                     temp_vector2 -=temp_vector1;</a>
<a name="893"><span class="lineNum">     893 </span>            :                     MathUtils&lt;double&gt;::CrossProduct(temp_vector4, temp_vector2 , temp_vector3) ;</a>
<a name="894"><span class="lineNum">     894 </span>            : </a>
<a name="895"><span class="lineNum">     895 </span><span class="lineNoCov">          0 :                     if (inner_prod(temp_vector4,versor)&lt;0.0)</span></a>
<a name="896"><span class="lineNum">     896 </span>            :                     {</a>
<a name="897"><span class="lineNum">     897 </span>            :                         temp_int= nodes_for_2triang[index*3+2];</a>
<a name="898"><span class="lineNum">     898 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[index*3+2] =  nodes_for_2triang[index*3+1];</span></a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :                         nodes_for_2triang[index*3+1] =  temp_int;</span></a>
<a name="900"><span class="lineNum">     900 </span>            :                     }</a>
<a name="901"><span class="lineNum">     901 </span>            : </a>
<a name="902"><span class="lineNum">     902 </span>            :                     Triangle3D3&lt;Node&lt;3&gt; &gt; geom(</a>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 :                         new_model_part.Nodes()(nodes_for_2triang[index*3+0]),</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :                         new_model_part.Nodes()(nodes_for_2triang[index*3+1]),</span></a>
<a name="905"><span class="lineNum">     905 </span><span class="lineNoCov">          0 :                         new_model_part.Nodes()(nodes_for_2triang[index*3+2])</span></a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :                     );</span></a>
<a name="907"><span class="lineNum">     907 </span>            : </a>
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 :                     Condition::Pointer p_condition = rReferenceCondition.Create(number_of_triangles+1+first_element, geom, properties);</span></a>
<a name="909"><span class="lineNum">     909 </span>            : </a>
<a name="910"><span class="lineNum">     910 </span><span class="lineNoCov">          0 :                     new_model_part.Conditions().push_back(p_condition);</span></a>
<a name="911"><span class="lineNum">     911 </span><span class="lineNoCov">          0 :                     ++number_of_triangles;</span></a>
<a name="912"><span class="lineNum">     912 </span>            : </a>
<a name="913"><span class="lineNum">     913 </span><span class="lineNoCov">          0 :                     for (int counter=0; counter!=4; ++counter) TriangleNodesArray[counter]=0;//resetting, just in case</span></a>
<a name="914"><span class="lineNum">     914 </span>            :                 }//cierro el index</a>
<a name="915"><span class="lineNum">     915 </span>            :             }//closing if elems_in_plane=2</a>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<a name="917"><span class="lineNum">     917 </span>            :         }//closing element loops</a>
<a name="918"><span class="lineNum">     918 </span>            : </a>
<a name="919"><span class="lineNum">     919 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="920"><span class="lineNum">     920 </span>            : </a>
<a name="921"><span class="lineNum">     921 </span>            :     ///************************************************************************************************</a>
<a name="922"><span class="lineNum">     922 </span>            :     ///************************************************************************************************</a>
<a name="923"><span class="lineNum">     923 </span>            : </a>
<a name="924"><span class="lineNum">     924 </span>            : </a>
<a name="925"><span class="lineNum">     925 </span>            :     ///UPDATECUTDATA: THIS FUNCTION UPDATES THE DATA OF THE NEW MODEL PART READING FROM THE DATA OF THE FATHER NODES (and weight factor)</a>
<a name="926"><span class="lineNum">     926 </span>            :     /** interpolates data form the origin model part into the new model part (containing the cutting planes)</a>
<a name="927"><span class="lineNum">     927 </span>            :      * @param new_model_part . destination model part</a>
<a name="928"><span class="lineNum">     928 </span>            :      * @param old_model_part . origin model part</a>
<a name="929"><span class="lineNum">     929 </span>            :      **/</a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :     void UpdateCutData( ModelPart&amp; new_model_part, ModelPart&amp; old_model_part)</span></a>
<a name="931"><span class="lineNum">     931 </span>            :     {</a>
<a name="932"><span class="lineNum">     932 </span>            :         KRATOS_WATCH(&quot;Updating Cut Data&quot;);</a>
<a name="933"><span class="lineNum">     933 </span><span class="lineNoCov">          0 :         int step_data_size = old_model_part.GetNodalSolutionStepDataSize();</span></a>
<a name="934"><span class="lineNum">     934 </span>            : </a>
<a name="935"><span class="lineNum">     935 </span>            :         //looping the nodes, no data is assigned to elements</a>
<a name="936"><span class="lineNum">     936 </span><span class="lineNoCov">          0 :         for (ModelPart::NodesContainerType::iterator it = new_model_part.NodesBegin(); it != new_model_part.NodesEnd(); it++)</span></a>
<a name="937"><span class="lineNum">     937 </span>            :         {</a>
<a name="938"><span class="lineNum">     938 </span>            :             double* node0_data = it-&gt;GetValue(FATHER_NODES)[0].SolutionStepData().Data(0); //current step only, (since we'll call this every timestep</a>
<a name="939"><span class="lineNum">     939 </span>            :             double* node1_data = it-&gt;GetValue(FATHER_NODES)[1].SolutionStepData().Data(0);</a>
<a name="940"><span class="lineNum">     940 </span><span class="lineNoCov">          0 :             double    weight   = it-&gt;GetValue(WEIGHT_FATHER_NODES);</span></a>
<a name="941"><span class="lineNum">     941 </span>            :             double* step_data = (it)-&gt;SolutionStepData().Data(0);</a>
<a name="942"><span class="lineNum">     942 </span>            : </a>
<a name="943"><span class="lineNum">     943 </span>            :             //now we only have to copy the information from node_data to step_data</a>
<a name="944"><span class="lineNum">     944 </span><span class="lineNoCov">          0 :             for(int j= 0; j&lt; step_data_size; j++)  //looping all the variables and interpolating using weight</span></a>
<a name="945"><span class="lineNum">     945 </span>            :             {</a>
<a name="946"><span class="lineNum">     946 </span><span class="lineNoCov">          0 :                 step_data[j] = weight*node0_data[j] + (1.0-weight)*node1_data[j];</span></a>
<a name="947"><span class="lineNum">     947 </span>            :             }</a>
<a name="948"><span class="lineNum">     948 </span>            :         }//closing node loop</a>
<a name="949"><span class="lineNum">     949 </span><span class="lineNoCov">          0 :     }//closing subroutine</span></a>
<a name="950"><span class="lineNum">     950 </span>            : </a>
<a name="951"><span class="lineNum">     951 </span>            : </a>
<a name="952"><span class="lineNum">     952 </span>            : </a>
<a name="953"><span class="lineNum">     953 </span>            : ///********************************************************************************************************</a>
<a name="954"><span class="lineNum">     954 </span>            : ///********************************************************************************************************</a>
<a name="955"><span class="lineNum">     955 </span>            : </a>
<a name="956"><span class="lineNum">     956 </span>            : </a>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            : private:</a>
<a name="960"><span class="lineNum">     960 </span>            :     double smallest_edge; //</a>
<a name="961"><span class="lineNum">     961 </span>            :     bool first_cutting_plane; // to avoid checking again if we're working on the new cutting plane or if some have already been created</a>
<a name="962"><span class="lineNum">     962 </span>            : </a>
<a name="963"><span class="lineNum">     963 </span>            : };</a>
<a name="964"><span class="lineNum">     964 </span>            : }</a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span>            : </a>
<a name="967"><span class="lineNum">     967 </span>            : </a>
<a name="968"><span class="lineNum">     968 </span>            : #endif</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
