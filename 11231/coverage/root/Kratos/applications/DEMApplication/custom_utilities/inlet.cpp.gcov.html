<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /root/Kratos/applications/DEMApplication/custom_utilities/inlet.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">root/Kratos/applications/DEMApplication/custom_utilities</a> - inlet.cpp<span style="font-size: 80%;"> (source / <a href="inlet.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">418</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-17 13:51:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : //</a>
<a name="2"><span class="lineNum">       2 </span>            : // Author:</a>
<a name="3"><span class="lineNum">       3 </span>            : // Miguel Angel Celigueta maceli@cimne.upc.edu</a>
<a name="4"><span class="lineNum">       4 </span>            : //</a>
<a name="5"><span class="lineNum">       5 </span>            : </a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;string&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : #include &lt;iostream&gt;</a>
<a name="8"><span class="lineNum">       8 </span>            : #include &lt;random&gt;</a>
<a name="9"><span class="lineNum">       9 </span>            : #include &lt;functional&gt;</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            : #include &quot;inlet.h&quot;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;create_and_destroy.h&quot;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &quot;custom_elements/spheric_continuum_particle.h&quot;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &quot;custom_elements/cluster3D.h&quot;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &quot;custom_constitutive/DEM_discontinuum_constitutive_law.h&quot;</a>
<a name="16"><span class="lineNum">      16 </span>            : #include &quot;custom_constitutive/DEM_continuum_constitutive_law.h&quot;</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &quot;dem_fem_utilities.h&quot;</a>
<a name="18"><span class="lineNum">      18 </span>            : #include &quot;GeometryFunctions.h&quot;</a>
<a name="19"><span class="lineNum">      19 </span>            : </a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            : namespace Kratos {</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span><span class="lineNoCov">          0 :     inline double CalculateNormalizedIndentation(SphericParticle&amp; elem_it_1, SphericParticle&amp; elem_it_2) {</span></a>
<a name="24"><span class="lineNum">      24 </span>            :         const array_1d&lt;double,3&gt;&amp; coordinates_1 = elem_it_1.GetGeometry()[0].Coordinates();</a>
<a name="25"><span class="lineNum">      25 </span>            :         const array_1d&lt;double,3&gt;&amp; coordinates_2 = elem_it_2.GetGeometry()[0].Coordinates();</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span><span class="lineNoCov">          0 :         const double distance = std::sqrt((coordinates_1[0]- coordinates_2[0]) * (coordinates_1[0] - coordinates_2[0]) +</span></a>
<a name="28"><span class="lineNum">      28 </span><span class="lineNoCov">          0 :                                           (coordinates_1[1]- coordinates_2[1]) * (coordinates_1[1] - coordinates_2[1]) +</span></a>
<a name="29"><span class="lineNum">      29 </span><span class="lineNoCov">          0 :                                           (coordinates_1[2]- coordinates_2[2]) * (coordinates_1[2] - coordinates_2[2]));</span></a>
<a name="30"><span class="lineNum">      30 </span>            : </a>
<a name="31"><span class="lineNum">      31 </span><span class="lineNoCov">          0 :         const double radius_sum = elem_it_1.GetInteractionRadius() + elem_it_2.GetInteractionRadius();</span></a>
<a name="32"><span class="lineNum">      32 </span><span class="lineNoCov">          0 :         double indentation = radius_sum - distance;</span></a>
<a name="33"><span class="lineNum">      33 </span>            : </a>
<a name="34"><span class="lineNum">      34 </span><span class="lineNoCov">          0 :         indentation /= radius_sum;</span></a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span><span class="lineNoCov">          0 :         return indentation;</span></a>
<a name="37"><span class="lineNum">      37 </span>            :     }</a>
<a name="38"><span class="lineNum">      38 </span>            : </a>
<a name="39"><span class="lineNum">      39 </span><span class="lineNoCov">          0 :     bool SortSubModelPartsByName(ModelPart* A, ModelPart* B) {</span></a>
<a name="40"><span class="lineNum">      40 </span><span class="lineNoCov">          0 :         return (A-&gt;Name() &lt; B-&gt;Name());</span></a>
<a name="41"><span class="lineNum">      41 </span>            :     }</a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            :     /// Constructor</a>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<a name="45"><span class="lineNum">      45 </span><span class="lineNoCov">          0 :     DEM_Inlet::DEM_Inlet(ModelPart&amp; inlet_modelpart, const int seed):</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineNoCov">          0 :                         DEM_Inlet(inlet_modelpart, Parameters(R&quot;({})&quot;), seed){}</span></a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span><span class="lineNoCov">          0 :     DEM_Inlet::DEM_Inlet(ModelPart&amp; inlet_modelpart, const Parameters&amp; r_inlet_settings, const int seed):</span></a>
<a name="49"><span class="lineNum">      49 </span><span class="lineNoCov">          0 :      mInletModelPart(inlet_modelpart), mInletsSettings(Parameters(r_inlet_settings))</span></a>
<a name="50"><span class="lineNum">      50 </span>            :         {</a>
<a name="51"><span class="lineNum">      51 </span><span class="lineNoCov">          0 :         const int number_of_submodelparts = inlet_modelpart.NumberOfSubModelParts();</span></a>
<a name="52"><span class="lineNum">      52 </span><span class="lineNoCov">          0 :         mPartialParticleToInsert.resize(number_of_submodelparts);</span></a>
<a name="53"><span class="lineNum">      53 </span><span class="lineNoCov">          0 :         mLastInjectionTimes.resize(number_of_submodelparts);</span></a>
<a name="54"><span class="lineNum">      54 </span>            :         //mTotalNumberOfDetachedParticles.resize(number_of_submodelparts, false);</a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :         mLayerRemoved.resize(number_of_submodelparts);</span></a>
<a name="56"><span class="lineNum">      56 </span><span class="lineNoCov">          0 :         mNumberOfParticlesInjected.resize(number_of_submodelparts);</span></a>
<a name="57"><span class="lineNum">      57 </span><span class="lineNoCov">          0 :         mMassInjected.resize(number_of_submodelparts);</span></a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 :         std::mt19937 gen(seed);</span></a>
<a name="60"><span class="lineNum">      60 </span><span class="lineNoCov">          0 :         mGenerator = gen;</span></a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            :         int smp_iterator_number = 0;</a>
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 :         for (ModelPart::SubModelPartsContainerType::iterator sub_model_part = inlet_modelpart.SubModelPartsBegin(); sub_model_part != inlet_modelpart.SubModelPartsEnd(); ++sub_model_part) {</span></a>
<a name="64"><span class="lineNum">      64 </span><span class="lineNoCov">          0 :             mPartialParticleToInsert[smp_iterator_number] = 0.0;</span></a>
<a name="65"><span class="lineNum">      65 </span><span class="lineNoCov">          0 :             mLastInjectionTimes[smp_iterator_number] = 0.0;</span></a>
<a name="66"><span class="lineNum">      66 </span>            :             mLayerRemoved[smp_iterator_number] = false;</a>
<a name="67"><span class="lineNum">      67 </span>            :             //mTotalNumberOfDetachedParticles[smp_iterator_number] = 0.0;</a>
<a name="68"><span class="lineNum">      68 </span><span class="lineNoCov">          0 :             mNumberOfParticlesInjected[smp_iterator_number] = 0;</span></a>
<a name="69"><span class="lineNum">      69 </span><span class="lineNoCov">          0 :             mMassInjected[smp_iterator_number] = 0.0;</span></a>
<a name="70"><span class="lineNum">      70 </span><span class="lineNoCov">          0 :             smp_iterator_number++;</span></a>
<a name="71"><span class="lineNum">      71 </span>            :         }</a>
<a name="72"><span class="lineNum">      72 </span>            : </a>
<a name="73"><span class="lineNum">      73 </span><span class="lineNoCov">          0 :         mFirstInjectionIsDone = false;</span></a>
<a name="74"><span class="lineNum">      74 </span><span class="lineNoCov">          0 :         mBallsModelPartHasSphericity = false;</span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineNoCov">          0 :         mBallsModelPartHasRotation   = false;</span></a>
<a name="76"><span class="lineNum">      76 </span><span class="lineNoCov">          0 :         mTotalNumberOfParticlesInjected = 0;</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineNoCov">          0 :         mTotalMassInjected = 0.0;</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineNoCov">          0 :         SetNormalizedMaxIndentationForRelease(0.0);</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineNoCov">          0 :         SetNormalizedMaxIndentationForNewParticleCreation(0.0);</span></a>
<a name="80"><span class="lineNum">      80 </span>            : </a>
<a name="81"><span class="lineNum">      81 </span><span class="lineNoCov">          0 :         mWarningTooSmallInlet = false;</span></a>
<a name="82"><span class="lineNum">      82 </span><span class="lineNoCov">          0 :         mWarningTooSmallInletForMassFlow = false;</span></a>
<a name="83"><span class="lineNum">      83 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="84"><span class="lineNum">      84 </span>            : </a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span><span class="lineNoCov">          0 :     void DEM_Inlet::CheckSubModelPart(ModelPart&amp; smp) {</span></a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, RADIUS);</span></a>
<a name="88"><span class="lineNum">      88 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, IDENTIFIER);</span></a>
<a name="89"><span class="lineNum">      89 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, VELOCITY);</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, MAX_RAND_DEVIATION_ANGLE);</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, PROPERTIES_ID);</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, INLET_START_TIME);</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, INLET_STOP_TIME);</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, ELEMENT_TYPE);</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, INJECTOR_ELEMENT_TYPE);</span></a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, CONTAINS_CLUSTERS);</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :         CheckIfSubModelPartHasVariable(smp, RIGID_BODY_MOTION);</span></a>
<a name="98"><span class="lineNum">      98 </span>            : </a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :         if(smp[RIGID_BODY_MOTION]){</span></a>
<a name="100"><span class="lineNum">     100 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, LINEAR_VELOCITY);</span></a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, ANGULAR_VELOCITY);</span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, ANGULAR_VELOCITY_START_TIME);</span></a>
<a name="103"><span class="lineNum">     103 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, ANGULAR_VELOCITY_STOP_TIME);</span></a>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, ANGULAR_VELOCITY_PERIOD);</span></a>
<a name="105"><span class="lineNum">     105 </span>            :         }</a>
<a name="106"><span class="lineNum">     106 </span>            : </a>
<a name="107"><span class="lineNum">     107 </span><span class="lineNoCov">          0 :         if(smp[IMPOSED_MASS_FLOW_OPTION]){</span></a>
<a name="108"><span class="lineNum">     108 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, MASS_FLOW);</span></a>
<a name="109"><span class="lineNum">     109 </span>            :         } else {</a>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 :             CheckIfSubModelPartHasVariable(smp, INLET_NUMBER_OF_PARTICLES);</span></a>
<a name="111"><span class="lineNum">     111 </span>            :         }</a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="113"><span class="lineNum">     113 </span>            : </a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :     double DEM_Inlet::SetDistributionMeanRadius(ModelPart&amp; mp) {</span></a>
<a name="115"><span class="lineNum">     115 </span>            :         double mean_radius = 0.0;</a>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span><span class="lineNoCov">          0 :         if (mp[PROBABILITY_DISTRIBUTION] == &quot;piecewise_linear&quot; || mp[PROBABILITY_DISTRIBUTION] == &quot;discrete&quot;){</span></a>
<a name="118"><span class="lineNum">     118 </span><span class="lineNoCov">          0 :             mean_radius = mInletsRandomVariables[mp.Name()]-&gt;GetMean();</span></a>
<a name="119"><span class="lineNum">     119 </span>            :         }</a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span>            :         else {</a>
<a name="122"><span class="lineNum">     122 </span><span class="lineNoCov">          0 :             mean_radius = mp[RADIUS];</span></a>
<a name="123"><span class="lineNum">     123 </span>            :         }</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span><span class="lineNoCov">          0 :         return mean_radius;</span></a>
<a name="126"><span class="lineNum">     126 </span>            :     }</a>
<a name="127"><span class="lineNum">     127 </span>            : </a>
<a name="128"><span class="lineNum">     128 </span><span class="lineNoCov">          0 :     double DEM_Inlet::SetMaxDistributionRadius(ModelPart&amp; mp) {</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :         return 1.5 * GetMaxRadius(mp);</span></a>
<a name="130"><span class="lineNum">     130 </span>            :     }</a>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<a name="132"><span class="lineNum">     132 </span><span class="lineNoCov">          0 :     double DEM_Inlet::GetMaxRadius(ModelPart&amp; mp){</span></a>
<a name="133"><span class="lineNum">     133 </span>            :         double max_radius = 0.0;</a>
<a name="134"><span class="lineNum">     134 </span>            : </a>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 :         if (mp[PROBABILITY_DISTRIBUTION] == &quot;piecewise_linear&quot; || mp[PROBABILITY_DISTRIBUTION] == &quot;discrete&quot;){</span></a>
<a name="136"><span class="lineNum">     136 </span><span class="lineNoCov">          0 :             const array_1d&lt;double, 2&gt;&amp; support = mInletsRandomVariables[mp.Name()]-&gt;GetSupport();</span></a>
<a name="137"><span class="lineNum">     137 </span><span class="lineNoCov">          0 :             max_radius = support[1];</span></a>
<a name="138"><span class="lineNum">     138 </span>            :         }</a>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span>            :         else {</a>
<a name="141"><span class="lineNum">     141 </span><span class="lineNoCov">          0 :             max_radius = mp[RADIUS];</span></a>
<a name="142"><span class="lineNum">     142 </span>            :         }</a>
<a name="143"><span class="lineNum">     143 </span>            : </a>
<a name="144"><span class="lineNum">     144 </span><span class="lineNoCov">          0 :         return max_radius;</span></a>
<a name="145"><span class="lineNum">     145 </span>            :     }</a>
<a name="146"><span class="lineNum">     146 </span>            : </a>
<a name="147"><span class="lineNum">     147 </span>            : </a>
<a name="148"><span class="lineNum">     148 </span><span class="lineNoCov">          0 :     void DEM_Inlet::InitializeDEM_Inlet(ModelPart&amp; r_modelpart, ParticleCreatorDestructor&amp; creator, const bool using_strategy_for_continuum) {</span></a>
<a name="149"><span class="lineNum">     149 </span>            : </a>
<a name="150"><span class="lineNum">     150 </span><span class="lineNoCov">          0 :         mStrategyForContinuum = using_strategy_for_continuum;</span></a>
<a name="151"><span class="lineNum">     151 </span>            :         unsigned int&amp; max_Id=creator.mMaxNodeId;</a>
<a name="152"><span class="lineNum">     152 </span>            :         //CreatePropertiesProxies(mFastProperties, mInletModelPart);</a>
<a name="153"><span class="lineNum">     153 </span><span class="lineNoCov">          0 :         mFastProperties = PropertiesProxiesManager().GetPropertiesProxies(r_modelpart);</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineNoCov">          0 :         VariablesList r_modelpart_nodal_variables_list = r_modelpart.GetNodalSolutionStepVariablesList();</span></a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span><span class="lineNoCov">          0 :         if (r_modelpart_nodal_variables_list.Has(PARTICLE_SPHERICITY)) mBallsModelPartHasSphericity = true;</span></a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span><span class="lineNoCov">          0 :         if (r_modelpart.GetProcessInfo()[ROTATION_OPTION]) {</span></a>
<a name="159"><span class="lineNum">     159 </span><span class="lineNoCov">          0 :             mBallsModelPartHasRotation = true;</span></a>
<a name="160"><span class="lineNum">     160 </span><span class="lineNoCov">          0 :             mInletModelPart.GetProcessInfo()[ROTATION_OPTION] = true;</span></a>
<a name="161"><span class="lineNum">     161 </span>            :         }</a>
<a name="162"><span class="lineNum">     162 </span>            :         else {</a>
<a name="163"><span class="lineNum">     163 </span><span class="lineNoCov">          0 :             mInletModelPart.GetProcessInfo()[ROTATION_OPTION] = false;</span></a>
<a name="164"><span class="lineNum">     164 </span>            :         }</a>
<a name="165"><span class="lineNum">     165 </span>            : </a>
<a name="166"><span class="lineNum">     166 </span>            :         int smp_number = 0;</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span><span class="lineNoCov">          0 :         for (ModelPart::SubModelPartsContainerType::iterator smp_it = mInletModelPart.SubModelPartsBegin(); smp_it != mInletModelPart.SubModelPartsEnd(); ++smp_it) {</span></a>
<a name="169"><span class="lineNum">     169 </span><span class="lineNoCov">          0 :             ModelPart* mp = &amp;*smp_it;</span></a>
<a name="170"><span class="lineNum">     170 </span><span class="lineNoCov">          0 :             mListOfSubModelParts.push_back(mp);</span></a>
<a name="171"><span class="lineNum">     171 </span>            :         }</a>
<a name="172"><span class="lineNum">     172 </span><span class="lineNoCov">          0 :         std::sort(mListOfSubModelParts.begin(), mListOfSubModelParts.end(), SortSubModelPartsByName);</span></a>
<a name="173"><span class="lineNum">     173 </span>            : </a>
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :         for(int i=0; i&lt;(int)mListOfSubModelParts.size(); i++) {</span></a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span><span class="lineNoCov">          0 :             ModelPart&amp; mp = *mListOfSubModelParts[i];</span></a>
<a name="177"><span class="lineNum">     177 </span>            : </a>
<a name="178"><span class="lineNum">     178 </span><span class="lineNoCov">          0 :             CheckSubModelPart(mp);</span></a>
<a name="179"><span class="lineNum">     179 </span>            : </a>
<a name="180"><span class="lineNum">     180 </span><span class="lineNoCov">          0 :             int mesh_size = mp.NumberOfNodes();</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineNoCov">          0 :             if (!mesh_size) continue;</span></a>
<a name="182"><span class="lineNum">     182 </span>            :             ModelPart::NodesContainerType::ContainerType&amp; all_nodes = mp.NodesArray();</a>
<a name="183"><span class="lineNum">     183 </span><span class="lineNoCov">          0 :             std::string&amp; identifier = mp[IDENTIFIER];</span></a>
<a name="184"><span class="lineNum">     184 </span>            :             mp[INLET_INITIAL_VELOCITY] = mp[LINEAR_VELOCITY];    //This is the velocity of the moving injector of particles</a>
<a name="185"><span class="lineNum">     185 </span>            :             mp[INLET_INITIAL_PARTICLES_VELOCITY] = mp[VELOCITY]; //This is the initial velocity vector of the injected particles</a>
<a name="186"><span class="lineNum">     186 </span>            : </a>
<a name="187"><span class="lineNum">     187 </span>            :             array_1d&lt;double, 3&gt;&amp; inlet_velocity = mp[VELOCITY];</a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span><span class="lineNoCov">          0 :             KRATOS_ERROR_IF((inlet_velocity[0] == 0.0) &amp;&amp; (inlet_velocity[1] == 0.0) &amp;&amp; (inlet_velocity[2] == 0.0)) &lt;&lt; &quot;The inlet velocity cannot be zero for group &quot; &lt;&lt; identifier &lt;&lt; std::endl;</span></a>
<a name="190"><span class="lineNum">     190 </span>            : </a>
<a name="191"><span class="lineNum">     191 </span><span class="lineNoCov">          0 :             double max_rand_dev_angle = mp[MAX_RAND_DEVIATION_ANGLE];</span></a>
<a name="192"><span class="lineNum">     192 </span>            : </a>
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 :             KRATOS_ERROR_IF(max_rand_dev_angle &lt; 0.0 || max_rand_dev_angle &gt; 89.5) &lt;&lt; &quot;The velocity deviation angle must be between 0 and 89.5 degrees for group &quot;&lt;&lt; identifier &lt;&lt; std::endl;</span></a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span><span class="lineNoCov">          0 :             Properties::Pointer p_properties = r_modelpart.pGetProperties(mp[PROPERTIES_ID]);</span></a>
<a name="196"><span class="lineNum">     196 </span><span class="lineNoCov">          0 :             int general_properties_id = p_properties-&gt;Id();</span></a>
<a name="197"><span class="lineNum">     197 </span>            : </a>
<a name="198"><span class="lineNum">     198 </span>            :             PropertiesProxy* p_fast_properties = NULL;</a>
<a name="199"><span class="lineNum">     199 </span>            : </a>
<a name="200"><span class="lineNum">     200 </span><span class="lineNoCov">          0 :             for (unsigned int i = 0; i &lt; mFastProperties.size(); i++) {</span></a>
<a name="201"><span class="lineNum">     201 </span><span class="lineNoCov">          0 :                 int fast_properties_id = mFastProperties[i].GetId();</span></a>
<a name="202"><span class="lineNum">     202 </span><span class="lineNoCov">          0 :                 if (fast_properties_id == general_properties_id) {</span></a>
<a name="203"><span class="lineNum">     203 </span>            :                     p_fast_properties = &amp;(mFastProperties[i]);</a>
<a name="204"><span class="lineNum">     204 </span><span class="lineNoCov">          0 :                     break;</span></a>
<a name="205"><span class="lineNum">     205 </span>            :                 }</a>
<a name="206"><span class="lineNum">     206 </span><span class="lineNoCov">          0 :                 mLastInjectionTimes[smp_number] = mp[INLET_START_TIME];</span></a>
<a name="207"><span class="lineNum">     207 </span>            :             }</a>
<a name="208"><span class="lineNum">     208 </span>            : </a>
<a name="209"><span class="lineNum">     209 </span><span class="lineNoCov">          0 :             if (mp[PROBABILITY_DISTRIBUTION] == &quot;piecewise_linear&quot; || mp[PROBABILITY_DISTRIBUTION] == &quot;discrete&quot;){</span></a>
<a name="210"><span class="lineNum">     210 </span><span class="lineNoCov">          0 :                 if (!mInletsSettings.Has(mp.Name())){</span></a>
<a name="211"><span class="lineNum">     211 </span><span class="lineNoCov">          0 :                     KRATOS_ERROR &lt;&lt; &quot;dem_inlet_settings does not contain settings for the inlet&quot; &lt;&lt; mp.Name() &lt;&lt; &quot;. Please, provide them.&quot;;</span></a>
<a name="212"><span class="lineNum">     212 </span>            :                 }</a>
<a name="213"><span class="lineNum">     213 </span><span class="lineNoCov">          0 :                 const Parameters&amp; inlet_settings = mInletsSettings[mp.Name()];</span></a>
<a name="214"><span class="lineNum">     214 </span><span class="lineNoCov">          0 :                 mInletsRandomSettings.emplace(mp.Name(), inlet_settings[&quot;random_variable_settings&quot;]);</span></a>
<a name="215"><span class="lineNum">     215 </span><span class="lineNoCov">          0 :                 const Parameters&amp; rv_settings = mInletsRandomSettings[mp.Name()];</span></a>
<a name="216"><span class="lineNum">     216 </span><span class="lineNoCov">          0 :                 int seed = rv_settings[&quot;seed&quot;].GetInt();</span></a>
<a name="217"><span class="lineNum">     217 </span><span class="lineNoCov">          0 :                 if (!rv_settings[&quot;do_use_seed&quot;].GetBool()){</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 :                     seed = std::random_device{}();</span></a>
<a name="219"><span class="lineNum">     219 </span>            :                 }</a>
<a name="220"><span class="lineNum">     220 </span><span class="lineNoCov">          0 :                 if (mp[PROBABILITY_DISTRIBUTION] == &quot;piecewise_linear&quot;){</span></a>
<a name="221"><span class="lineNum">     221 </span>            : </a>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 :                     mInletsRandomVariables[mp.Name()] = std::unique_ptr&lt;PiecewiseLinearRandomVariable&gt;(new PiecewiseLinearRandomVariable(rv_settings, seed));</span></a>
<a name="223"><span class="lineNum">     223 </span>            :                 }</a>
<a name="224"><span class="lineNum">     224 </span>            : </a>
<a name="225"><span class="lineNum">     225 </span><span class="lineNoCov">          0 :                 else if (mp[PROBABILITY_DISTRIBUTION] == &quot;discrete&quot;){</span></a>
<a name="226"><span class="lineNum">     226 </span><span class="lineNoCov">          0 :                     mInletsRandomVariables[mp.Name()] = std::unique_ptr&lt;DiscreteRandomVariable&gt;(new DiscreteRandomVariable(rv_settings, seed));</span></a>
<a name="227"><span class="lineNum">     227 </span>            :                 }</a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span>            :                 else {</a>
<a name="230"><span class="lineNum">     230 </span><span class="lineNoCov">          0 :                     KRATOS_ERROR &lt;&lt; &quot;Unknown DEM inlet random variable: &quot; &lt;&lt; mp[PROBABILITY_DISTRIBUTION] &lt;&lt; &quot;.&quot;;</span></a>
<a name="231"><span class="lineNum">     231 </span>            :                 }</a>
<a name="232"><span class="lineNum">     232 </span>            :             }</a>
<a name="233"><span class="lineNum">     233 </span>            : </a>
<a name="234"><span class="lineNum">     234 </span><span class="lineNoCov">          0 :             double max_radius = SetMaxDistributionRadius(mp);</span></a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span><span class="lineNoCov">          0 :             if (!mp[MINIMUM_RADIUS]) {</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineNoCov">          0 :                 mp[MINIMUM_RADIUS] = 0.5 * mp[RADIUS];</span></a>
<a name="238"><span class="lineNum">     238 </span>            :             }</a>
<a name="239"><span class="lineNum">     239 </span><span class="lineNoCov">          0 :             if (!mp[MAXIMUM_RADIUS]) {</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :                 mp[MAXIMUM_RADIUS] = max_radius;</span></a>
<a name="241"><span class="lineNum">     241 </span>            :             }</a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span>            :             Element::Pointer dummy_element_pointer;</a>
<a name="244"><span class="lineNum">     244 </span>            :             std::string&amp; ElementNameString = mp[INJECTOR_ELEMENT_TYPE];</a>
<a name="245"><span class="lineNum">     245 </span>            :             const Element&amp; r_reference_element = KratosComponents&lt;Element&gt;::Get(ElementNameString);</a>
<a name="246"><span class="lineNum">     246 </span>            : </a>
<a name="247"><span class="lineNum">     247 </span><span class="lineNoCov">          0 :             for (int i = 0; i &lt; mesh_size; i++) {</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineNoCov">          0 :                 Element* p_element = creator.ElementCreatorWithPhysicalParameters(r_modelpart,</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :                                                                                 max_Id+1,</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :                                                                                 all_nodes[i],</span></a>
<a name="251"><span class="lineNum">     251 </span>            :                                                                                 dummy_element_pointer,</a>
<a name="252"><span class="lineNum">     252 </span>            :                                                                                 p_properties,</a>
<a name="253"><span class="lineNum">     253 </span>            :                                                                                 mp,</a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :                                                                                 mInletsRandomVariables,</span></a>
<a name="255"><span class="lineNum">     255 </span>            :                                                                                 r_reference_element,</a>
<a name="256"><span class="lineNum">     256 </span>            :                                                                                 p_fast_properties,</a>
<a name="257"><span class="lineNum">     257 </span><span class="lineNoCov">          0 :                                                                                 mBallsModelPartHasSphericity,</span></a>
<a name="258"><span class="lineNum">     258 </span><span class="lineNoCov">          0 :                                                                                 mBallsModelPartHasRotation,</span></a>
<a name="259"><span class="lineNum">     259 </span>            :                                                                                 true,</a>
<a name="260"><span class="lineNum">     260 </span>            :                                                                                 mp.Elements());</a>
<a name="261"><span class="lineNum">     261 </span>            : </a>
<a name="262"><span class="lineNum">     262 </span><span class="lineNoCov">          0 :                 FixInjectorConditions(p_element);</span></a>
<a name="263"><span class="lineNum">     263 </span><span class="lineNoCov">          0 :                 max_Id++;</span></a>
<a name="264"><span class="lineNum">     264 </span>            :                 /*if(mStrategyForContinuum){</a>
<a name="265"><span class="lineNum">     265 </span>            :                     SphericContinuumParticle* p_continuum_spheric_particle = dynamic_cast&lt;SphericContinuumParticle*&gt;(p_element);</a>
<a name="266"><span class="lineNum">     266 </span>            :                     p_continuum_spheric_particle-&gt;mContinuumInitialNeighborsSize=0;</a>
<a name="267"><span class="lineNum">     267 </span>            :                     p_continuum_spheric_particle-&gt;mInitialNeighborsSize=0;</a>
<a name="268"><span class="lineNum">     268 </span>            :                 }*/</a>
<a name="269"><span class="lineNum">     269 </span>            :             }</a>
<a name="270"><span class="lineNum">     270 </span><span class="lineNoCov">          0 :             smp_number++;</span></a>
<a name="271"><span class="lineNum">     271 </span>            :         } //for smp_it</a>
<a name="272"><span class="lineNum">     272 </span><span class="lineNoCov">          0 :     } //InitializeDEM_Inlet</span></a>
<a name="273"><span class="lineNum">     273 </span>            : </a>
<a name="274"><span class="lineNum">     274 </span><span class="lineNoCov">          0 :     void DEM_Inlet::DettachElements(ModelPart&amp; r_modelpart, unsigned int&amp; max_Id) {</span></a>
<a name="275"><span class="lineNum">     275 </span>            : </a>
<a name="276"><span class="lineNum">     276 </span>            :         ProcessInfo&amp; r_process_info = r_modelpart.GetProcessInfo();</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            :         ///DIMENSION</a>
<a name="279"><span class="lineNum">     279 </span><span class="lineNoCov">          0 :         int dimension = r_process_info[DOMAIN_SIZE];</span></a>
<a name="280"><span class="lineNum">     280 </span>            : </a>
<a name="281"><span class="lineNum">     281 </span>            :         typedef ElementsArrayType::iterator ElementIterator;</a>
<a name="282"><span class="lineNum">     282 </span>            :         // This vector collects the ids of the particles that have been dettached</a>
<a name="283"><span class="lineNum">     283 </span>            :         // so that their id can be removed from the mOriginInletSubmodelPartIndexes map</a>
<a name="284"><span class="lineNum">     284 </span>            :         std::vector&lt;int&gt; ids_to_remove;</a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :         #pragma omp parallel</span></a>
<a name="287"><span class="lineNum">     287 </span>            :         {</a>
<a name="288"><span class="lineNum">     288 </span>            :         std::vector&lt;int&gt; ids_to_remove_partial;</a>
<a name="289"><span class="lineNum">     289 </span>            :         #pragma omp for</a>
<a name="290"><span class="lineNum">     290 </span>            :         for (int k = 0; k &lt; (int)r_modelpart.GetCommunicator().LocalMesh().Elements().size(); k++) {</a>
<a name="291"><span class="lineNum">     291 </span>            :             ElementIterator elem_it = r_modelpart.GetCommunicator().LocalMesh().Elements().ptr_begin() + k;</a>
<a name="292"><span class="lineNum">     292 </span>            :             if (elem_it-&gt;IsNot(NEW_ENTITY)) continue;</a>
<a name="293"><span class="lineNum">     293 </span>            :             if (elem_it-&gt;Is(DEMFlags::BELONGS_TO_A_CLUSTER)) continue;</a>
<a name="294"><span class="lineNum">     294 </span>            : </a>
<a name="295"><span class="lineNum">     295 </span>            :             SphericParticle&amp; spheric_particle = dynamic_cast&lt;SphericParticle&amp;&gt;(*elem_it);</a>
<a name="296"><span class="lineNum">     296 </span>            :             Node&amp; r_node = spheric_particle.GetGeometry()[0];</a>
<a name="297"><span class="lineNum">     297 </span>            : </a>
<a name="298"><span class="lineNum">     298 </span>            :             bool have_just_stopped_touching = true;</a>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<a name="300"><span class="lineNum">     300 </span>            :             for (unsigned int i = 0; i &lt; spheric_particle.mNeighbourElements.size(); i++) {</a>
<a name="301"><span class="lineNum">     301 </span>            :                 SphericParticle* p_neighbour_particle = spheric_particle.mNeighbourElements[i];</a>
<a name="302"><span class="lineNum">     302 </span>            :                 if(p_neighbour_particle == NULL) continue;</a>
<a name="303"><span class="lineNum">     303 </span>            : </a>
<a name="304"><span class="lineNum">     304 </span>            :                 Node&amp; neighbour_node = p_neighbour_particle-&gt;GetGeometry()[0];</a>
<a name="305"><span class="lineNum">     305 </span>            : </a>
<a name="306"><span class="lineNum">     306 </span>            :                 const double indentation = CalculateNormalizedIndentation(spheric_particle, *p_neighbour_particle);</a>
<a name="307"><span class="lineNum">     307 </span>            :                 const bool indentation_is_significant_for_release = indentation &gt; mNormalizedMaxIndentationForRelease*spheric_particle.GetInteractionRadius();</a>
<a name="308"><span class="lineNum">     308 </span>            :                 const bool indentation_is_significant_for_injection = indentation &gt; mNormalizedMaxIndentationForNewParticleCreation*spheric_particle.GetInteractionRadius();</a>
<a name="309"><span class="lineNum">     309 </span>            :                 const bool i_am_injected_he_is_injector = r_node.IsNot(BLOCKED) &amp;&amp; neighbour_node.Is(BLOCKED);</a>
<a name="310"><span class="lineNum">     310 </span>            :                 const bool i_am_injector_he_is_injected = r_node.Is(BLOCKED) &amp;&amp; neighbour_node.IsNot(BLOCKED);</a>
<a name="311"><span class="lineNum">     311 </span>            : </a>
<a name="312"><span class="lineNum">     312 </span>            :                 if (i_am_injected_he_is_injector &amp;&amp; indentation_is_significant_for_release) {</a>
<a name="313"><span class="lineNum">     313 </span>            :                     have_just_stopped_touching = false;</a>
<a name="314"><span class="lineNum">     314 </span>            :                     UpdateInjectedParticleVelocity(spheric_particle, *p_neighbour_particle);</a>
<a name="315"><span class="lineNum">     315 </span>            :                     break;</a>
<a name="316"><span class="lineNum">     316 </span>            :                 }</a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span>            :                 if (i_am_injector_he_is_injected &amp;&amp; indentation_is_significant_for_injection) {</a>
<a name="319"><span class="lineNum">     319 </span>            :                     have_just_stopped_touching = false;</a>
<a name="320"><span class="lineNum">     320 </span>            :                     break;</a>
<a name="321"><span class="lineNum">     321 </span>            :                 }</a>
<a name="322"><span class="lineNum">     322 </span>            :             }</a>
<a name="323"><span class="lineNum">     323 </span>            : </a>
<a name="324"><span class="lineNum">     324 </span>            :             if (have_just_stopped_touching) {</a>
<a name="325"><span class="lineNum">     325 </span>            :                 if (r_node.IsNot(BLOCKED)) {//The ball must be freed</a>
<a name="326"><span class="lineNum">     326 </span>            :                     RemoveInjectionConditions(spheric_particle, dimension);</a>
<a name="327"><span class="lineNum">     327 </span>            :                     ids_to_remove_partial.push_back(spheric_particle.Id());</a>
<a name="328"><span class="lineNum">     328 </span>            :                     UpdateTotalThroughput(spheric_particle);</a>
<a name="329"><span class="lineNum">     329 </span>            :                 }</a>
<a name="330"><span class="lineNum">     330 </span>            :                 else {</a>
<a name="331"><span class="lineNum">     331 </span>            :                     //Inlet BLOCKED nodes are ACTIVE when injecting, so when they cease to be in contact with other balls, ACTIVE is set to 'false', as they become available for injecting new elements.</a>
<a name="332"><span class="lineNum">     332 </span>            :                     r_node.Set(ACTIVE, false);</a>
<a name="333"><span class="lineNum">     333 </span>            :                     elem_it-&gt;Set(ACTIVE, false);</a>
<a name="334"><span class="lineNum">     334 </span>            :                 }</a>
<a name="335"><span class="lineNum">     335 </span>            :             }</a>
<a name="336"><span class="lineNum">     336 </span>            :         }</a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span>            :         // removing dettached particle ids from map</a>
<a name="339"><span class="lineNum">     339 </span>            :         #pragma omp critical</a>
<a name="340"><span class="lineNum">     340 </span>            :         {</a>
<a name="341"><span class="lineNum">     341 </span>            :             ids_to_remove.insert(ids_to_remove.end(), ids_to_remove_partial.begin(), ids_to_remove_partial.end());</a>
<a name="342"><span class="lineNum">     342 </span>            : </a>
<a name="343"><span class="lineNum">     343 </span>            :             for (unsigned int i = 0; i &lt; ids_to_remove.size(); ++i){</a>
<a name="344"><span class="lineNum">     344 </span>            :                 mOriginInletSubmodelPartIndexes.erase(ids_to_remove[i]);</a>
<a name="345"><span class="lineNum">     345 </span>            :             }</a>
<a name="346"><span class="lineNum">     346 </span>            :         }</a>
<a name="347"><span class="lineNum">     347 </span>            :     }</a>
<a name="348"><span class="lineNum">     348 </span>            : </a>
<a name="349"><span class="lineNum">     349 </span><span class="lineNoCov">          0 :     } //Dettach</span></a>
<a name="350"><span class="lineNum">     350 </span>            : </a>
<a name="351"><span class="lineNum">     351 </span><span class="lineNoCov">          0 :     void DEM_Inlet::UpdateInjectedParticleVelocity(Element&amp; particle, Element&amp; injector_element)</span></a>
<a name="352"><span class="lineNum">     352 </span>            :     {</a>
<a name="353"><span class="lineNum">     353 </span>            :         Node&amp; central_node = particle.GetGeometry()[0];</a>
<a name="354"><span class="lineNum">     354 </span><span class="lineNoCov">          0 :         const array_1d&lt;double, 3 &gt;&amp; ejection_velocity = mInletModelPart.GetSubModelPart(mOriginInletSubmodelPartIndexes[particle.Id()])[VELOCITY];</span></a>
<a name="355"><span class="lineNum">     355 </span>            :         const array_1d&lt;double, 3 &gt;&amp; injector_velocity = injector_element.GetGeometry()[0].FastGetSolutionStepValue(VELOCITY);</a>
<a name="356"><span class="lineNum">     356 </span>            :         array_1d&lt;double, 3 &gt;&amp; velocity = central_node.FastGetSolutionStepValue(VELOCITY);</a>
<a name="357"><span class="lineNum">     357 </span>            :         noalias(velocity) = ejection_velocity + injector_velocity;</a>
<a name="358"><span class="lineNum">     358 </span><span class="lineNoCov">          0 :         if (central_node.SolutionStepsDataHas(VELOCITY_OLD)){</span></a>
<a name="359"><span class="lineNum">     359 </span>            :             array_1d&lt;double, 3 &gt;&amp; velocity_old = central_node.FastGetSolutionStepValue(VELOCITY_OLD);</a>
<a name="360"><span class="lineNum">     360 </span>            :             noalias(velocity_old) = velocity;</a>
<a name="361"><span class="lineNum">     361 </span>            :         }</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="363"><span class="lineNum">     363 </span>            : </a>
<a name="364"><span class="lineNum">     364 </span><span class="lineNoCov">          0 :     void DEM_Inlet::FixInjectorConditions(Element* p_element){}</span></a>
<a name="365"><span class="lineNum">     365 </span>            : </a>
<a name="366"><span class="lineNum">     366 </span><span class="lineNoCov">          0 :     void DEM_Inlet::FixInjectionConditions(Element* p_element, Element* p_injector_element)</span></a>
<a name="367"><span class="lineNum">     367 </span>            :     {</a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :         UpdateInjectedParticleVelocity(*p_element, *p_injector_element);</span></a>
<a name="369"><span class="lineNum">     369 </span>            : </a>
<a name="370"><span class="lineNum">     370 </span>            :         Node&amp; node = p_element-&gt;GetGeometry()[0];</a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_X)-&gt;FixDof();</span></a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_Y)-&gt;FixDof();</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_Z)-&gt;FixDof();</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_X)-&gt;FixDof();</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_Y)-&gt;FixDof();</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_Z)-&gt;FixDof();</span></a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_X, true);</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_Y, true);</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_Z, true);</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_X, true);</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_Y, true);</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_Z, true);</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="385"><span class="lineNum">     385 </span>            : </a>
<a name="386"><span class="lineNum">     386 </span><span class="lineNoCov">          0 :     void DEM_Inlet::CheckDistanceAndSetFlag(ModelPart&amp; r_modelpart)</span></a>
<a name="387"><span class="lineNum">     387 </span>            :     {</a>
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 :         ElementsArrayType&amp; rElements = r_modelpart.GetCommunicator().LocalMesh().Elements();</span></a>
<a name="389"><span class="lineNum">     389 </span><span class="lineNoCov">          0 :         block_for_each(rElements, [&amp;](ModelPart::ElementType&amp; rElement) {</span></a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :             if (rElement.Is(BLOCKED)) return;</span></a>
<a name="391"><span class="lineNum">     391 </span><span class="lineNoCov">          0 :             SphericParticle&amp; spheric_particle = dynamic_cast&lt;SphericParticle&amp;&gt;(rElement);</span></a>
<a name="392"><span class="lineNum">     392 </span>            : </a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :             if (!(*(spheric_particle.mpInlet))[DENSE_INLET]) return;</span></a>
<a name="394"><span class="lineNum">     394 </span>            :                 Node&amp; node = spheric_particle.GetGeometry()[0];</a>
<a name="395"><span class="lineNum">     395 </span>            : </a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :             if (!node.Is(DEMFlags::CUMULATIVE_ZONE)) return;</span></a>
<a name="397"><span class="lineNum">     397 </span>            : </a>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :             const array_1d&lt;double,3&gt;&amp; inlet_velocity = (*(spheric_particle.mpInlet))[VELOCITY];</span></a>
<a name="399"><span class="lineNum">     399 </span><span class="lineNoCov">          0 :             const double inlet_velocity_magnitude = DEM_MODULUS_3(inlet_velocity);</span></a>
<a name="400"><span class="lineNum">     400 </span>            :             const array_1d&lt;double, 3&gt; unitary_inlet_velocity =  inlet_velocity/inlet_velocity_magnitude;</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span><span class="lineNoCov">          0 :             const array_1d&lt;double,3&gt;&amp; initial_coordinates = node.GetInitialPosition();</span></a>
<a name="403"><span class="lineNum">     403 </span>            :             const array_1d&lt;double,3&gt;&amp; coordinates = node.Coordinates();</a>
<a name="404"><span class="lineNum">     404 </span>            :             const array_1d&lt;double,3&gt; distance = coordinates - initial_coordinates;</a>
<a name="405"><span class="lineNum">     405 </span><span class="lineNoCov">          0 :             const double reference_distance = 15.0 * (*(spheric_particle.mpInlet))[RADIUS];</span></a>
<a name="406"><span class="lineNum">     406 </span>            : </a>
<a name="407"><span class="lineNum">     407 </span>            :             /// Projection over injection axis</a>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :             const double projected_distance = DEM_INNER_PRODUCT_3(distance, unitary_inlet_velocity);</span></a>
<a name="409"><span class="lineNum">     409 </span>            : </a>
<a name="410"><span class="lineNum">     410 </span><span class="lineNoCov">          0 :             if (projected_distance &gt; reference_distance) {</span></a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :                     node.Set(DEMFlags::CUMULATIVE_ZONE, false);</span></a>
<a name="412"><span class="lineNum">     412 </span><span class="lineNoCov">          0 :                     spheric_particle.Set(DEMFlags::CUMULATIVE_ZONE, false);</span></a>
<a name="413"><span class="lineNum">     413 </span>            :             }</a>
<a name="414"><span class="lineNum">     414 </span>            :         });</a>
<a name="415"><span class="lineNum">     415 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="416"><span class="lineNum">     416 </span>            : </a>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :     void DEM_Inlet::RemoveInjectionConditions(Element&amp; element, int dimension)</span></a>
<a name="419"><span class="lineNum">     419 </span>            :     {</a>
<a name="420"><span class="lineNum">     420 </span>            :         Node&amp; node = element.GetGeometry()[0];</a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_X, false);</span></a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_Y, false);</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_VEL_Z, false);</span></a>
<a name="424"><span class="lineNum">     424 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_X, false);</span></a>
<a name="425"><span class="lineNum">     425 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_Y, false);</span></a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :         node.Set(DEMFlags::FIXED_ANG_VEL_Z, false);</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :         element.Set(NEW_ENTITY, 0);</span></a>
<a name="428"><span class="lineNum">     428 </span><span class="lineNoCov">          0 :         node.Set(NEW_ENTITY, 0);</span></a>
<a name="429"><span class="lineNum">     429 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_X)-&gt;FreeDof();</span></a>
<a name="430"><span class="lineNum">     430 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_Y)-&gt;FreeDof();</span></a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :         node.pGetDof(VELOCITY_Z)-&gt;FreeDof();</span></a>
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_X)-&gt;FreeDof();</span></a>
<a name="433"><span class="lineNum">     433 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_Y)-&gt;FreeDof();</span></a>
<a name="434"><span class="lineNum">     434 </span><span class="lineNoCov">          0 :         node.pGetDof(ANGULAR_VELOCITY_Z)-&gt;FreeDof();</span></a>
<a name="435"><span class="lineNum">     435 </span>            : </a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :         const int id = element.Id();</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :         ModelPart&amp; inlet_to_which_it_belongs = mInletModelPart.GetSubModelPart(mOriginInletSubmodelPartIndexes[id]);</span></a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span><span class="lineNoCov">          0 :         array_1d&lt;double, 3 &gt; ejection_velocity_copy = inlet_to_which_it_belongs[VELOCITY];</span></a>
<a name="440"><span class="lineNum">     440 </span>            :         array_1d&lt;double, 3 &gt;&amp; velocity = node.FastGetSolutionStepValue(VELOCITY);</a>
<a name="441"><span class="lineNum">     441 </span>            :         noalias(velocity) -= ejection_velocity_copy;</a>
<a name="442"><span class="lineNum">     442 </span>            : </a>
<a name="443"><span class="lineNum">     443 </span><span class="lineNoCov">          0 :         const double max_rand_deviation_angle = inlet_to_which_it_belongs[MAX_RAND_DEVIATION_ANGLE];</span></a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :         if (dimension==2){AddRandomPerpendicularComponentToGivenVector2D(ejection_velocity_copy, max_rand_deviation_angle);}</span></a>
<a name="445"><span class="lineNum">     445 </span><span class="lineNoCov">          0 :         else {AddRandomPerpendicularComponentToGivenVector(ejection_velocity_copy, max_rand_deviation_angle);}</span></a>
<a name="446"><span class="lineNum">     446 </span>            :         noalias(velocity) += ejection_velocity_copy;</a>
<a name="447"><span class="lineNum">     447 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="448"><span class="lineNum">     448 </span>            : </a>
<a name="449"><span class="lineNum">     449 </span><span class="lineNoCov">          0 :     void DEM_Inlet::DettachClusters(ModelPart&amp; r_clusters_modelpart, unsigned int&amp; max_Id) {</span></a>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<a name="451"><span class="lineNum">     451 </span>            :         ProcessInfo&amp; r_process_info = r_clusters_modelpart.GetProcessInfo();</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span>            :         ///DIMENSION</a>
<a name="454"><span class="lineNum">     454 </span><span class="lineNoCov">          0 :         int dimension = r_process_info[DOMAIN_SIZE];</span></a>
<a name="455"><span class="lineNum">     455 </span>            :         typedef ElementsArrayType::iterator ElementIterator;</a>
<a name="456"><span class="lineNum">     456 </span>            :         std::vector&lt;int&gt; ids_to_remove;</a>
<a name="457"><span class="lineNum">     457 </span>            : </a>
<a name="458"><span class="lineNum">     458 </span><span class="lineNoCov">          0 :         #pragma omp parallel</span></a>
<a name="459"><span class="lineNum">     459 </span>            :         {</a>
<a name="460"><span class="lineNum">     460 </span>            :         std::vector&lt;int&gt; ids_to_remove_partial;</a>
<a name="461"><span class="lineNum">     461 </span>            :         #pragma omp for</a>
<a name="462"><span class="lineNum">     462 </span>            :          for (int k = 0; k &lt; (int)r_clusters_modelpart.GetCommunicator().LocalMesh().Elements().size(); k++) {</a>
<a name="463"><span class="lineNum">     463 </span>            :             ElementIterator elem_it = r_clusters_modelpart.GetCommunicator().LocalMesh().Elements().ptr_begin() + k;</a>
<a name="464"><span class="lineNum">     464 </span>            :             if (elem_it-&gt;IsNot(NEW_ENTITY)) continue;</a>
<a name="465"><span class="lineNum">     465 </span>            : </a>
<a name="466"><span class="lineNum">     466 </span>            :             Kratos::Cluster3D&amp; r_cluster = dynamic_cast&lt;Kratos::Cluster3D&amp;&gt;(*elem_it);</a>
<a name="467"><span class="lineNum">     467 </span>            : </a>
<a name="468"><span class="lineNum">     468 </span>            :             bool still_touching=false;</a>
<a name="469"><span class="lineNum">     469 </span>            : </a>
<a name="470"><span class="lineNum">     470 </span>            :             for (unsigned int j = 0; j &lt; r_cluster.GetSpheres().size(); j++) { //loop over the spheres of the cluster</a>
<a name="471"><span class="lineNum">     471 </span>            :                 SphericParticle* spheric_particle = r_cluster.GetSpheres()[j];</a>
<a name="472"><span class="lineNum">     472 </span>            :                 SphericParticle* p_neighbour;</a>
<a name="473"><span class="lineNum">     473 </span>            :                 for (unsigned int i = 0; i &lt; spheric_particle-&gt;mNeighbourElements.size(); i++) { //loop over the neighbor spheres of each sphere of the cluster</a>
<a name="474"><span class="lineNum">     474 </span>            :                     p_neighbour = spheric_particle-&gt;mNeighbourElements[i];</a>
<a name="475"><span class="lineNum">     475 </span>            : </a>
<a name="476"><span class="lineNum">     476 </span>            :                     if (p_neighbour-&gt;GetGeometry()[0].Is(BLOCKED)) {</a>
<a name="477"><span class="lineNum">     477 </span>            :                         still_touching = true;</a>
<a name="478"><span class="lineNum">     478 </span>            :                         break;</a>
<a name="479"><span class="lineNum">     479 </span>            :                     }</a>
<a name="480"><span class="lineNum">     480 </span>            :                 }</a>
<a name="481"><span class="lineNum">     481 </span>            : </a>
<a name="482"><span class="lineNum">     482 </span>            :                 if (still_touching){</a>
<a name="483"><span class="lineNum">     483 </span>            :                     UpdateInjectedParticleVelocity(r_cluster, *p_neighbour);</a>
<a name="484"><span class="lineNum">     484 </span>            :                     break;</a>
<a name="485"><span class="lineNum">     485 </span>            :                 }</a>
<a name="486"><span class="lineNum">     486 </span>            :             }</a>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span>            :             if (!still_touching) { //The ball must be freed</a>
<a name="489"><span class="lineNum">     489 </span>            :                 RemoveInjectionConditions(r_cluster, dimension);</a>
<a name="490"><span class="lineNum">     490 </span>            :                 ids_to_remove_partial.push_back(r_cluster.Id());</a>
<a name="491"><span class="lineNum">     491 </span>            : </a>
<a name="492"><span class="lineNum">     492 </span>            :                 UpdateTotalThroughput(r_cluster);</a>
<a name="493"><span class="lineNum">     493 </span>            : </a>
<a name="494"><span class="lineNum">     494 </span>            :                 for (unsigned int j = 0; j &lt; r_cluster.GetSpheres().size(); j++) { //loop over the spheres of the cluster</a>
<a name="495"><span class="lineNum">     495 </span>            :                     SphericParticle* spheric_particle = r_cluster.GetSpheres()[j];</a>
<a name="496"><span class="lineNum">     496 </span>            :                     Node&amp; node_it = spheric_particle-&gt;GetGeometry()[0];</a>
<a name="497"><span class="lineNum">     497 </span>            :                     spheric_particle-&gt;Set(NEW_ENTITY, 0);</a>
<a name="498"><span class="lineNum">     498 </span>            :                     node_it.Set(NEW_ENTITY, 0);</a>
<a name="499"><span class="lineNum">     499 </span>            :                 }</a>
<a name="500"><span class="lineNum">     500 </span>            :             }</a>
<a name="501"><span class="lineNum">     501 </span>            :         }</a>
<a name="502"><span class="lineNum">     502 </span>            : </a>
<a name="503"><span class="lineNum">     503 </span>            :         // removing dettached particle ids from map</a>
<a name="504"><span class="lineNum">     504 </span>            :         #pragma omp critical</a>
<a name="505"><span class="lineNum">     505 </span>            :         {</a>
<a name="506"><span class="lineNum">     506 </span>            :             ids_to_remove.insert(ids_to_remove.end(), ids_to_remove_partial.begin(), ids_to_remove_partial.end());</a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span>            :             for (unsigned int i = 0; i &lt; ids_to_remove.size(); ++i){</a>
<a name="509"><span class="lineNum">     509 </span>            :                 mOriginInletSubmodelPartIndexes.erase(ids_to_remove[i]);</a>
<a name="510"><span class="lineNum">     510 </span>            :             }</a>
<a name="511"><span class="lineNum">     511 </span>            :         }</a>
<a name="512"><span class="lineNum">     512 </span>            :         }</a>
<a name="513"><span class="lineNum">     513 </span><span class="lineNoCov">          0 :     } //DettachClusters</span></a>
<a name="514"><span class="lineNum">     514 </span>            : </a>
<a name="515"><span class="lineNum">     515 </span><span class="lineNoCov">          0 :     bool DEM_Inlet::OneNeighbourInjectorIsInjecting(const Element::Pointer&amp; element) {</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineNoCov">          0 :         SphericParticle&amp; spheric_particle = dynamic_cast&lt;SphericParticle&amp;&gt;(*element);</span></a>
<a name="517"><span class="lineNum">     517 </span><span class="lineNoCov">          0 :         for(int i=0; i&lt;(int)spheric_particle.mNeighbourElements.size(); i++) {</span></a>
<a name="518"><span class="lineNum">     518 </span><span class="lineNoCov">          0 :             if(spheric_particle.mNeighbourElements[i]-&gt;Is(BLOCKED) &amp;&amp; spheric_particle.mNeighbourElements[i]-&gt;Is(ACTIVE)) {</span></a>
<a name="519"><span class="lineNum">     519 </span>            :                 return true;</a>
<a name="520"><span class="lineNum">     520 </span>            :             }</a>
<a name="521"><span class="lineNum">     521 </span>            :         }</a>
<a name="522"><span class="lineNum">     522 </span>            :         return false;</a>
<a name="523"><span class="lineNum">     523 </span>            :     }</a>
<a name="524"><span class="lineNum">     524 </span>            : </a>
<a name="525"><span class="lineNum">     525 </span>            : </a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span><span class="lineNoCov">          0 :     void DEM_Inlet::InitializeStep(ModelPart&amp; r_modelpart) {</span></a>
<a name="528"><span class="lineNum">     528 </span>            : </a>
<a name="529"><span class="lineNum">     529 </span>            :         bool is_there_any_dense_inlet = false;</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineNoCov">          0 :         for(int i=0; i&lt;(int)mListOfSubModelParts.size(); i++) {</span></a>
<a name="531"><span class="lineNum">     531 </span><span class="lineNoCov">          0 :             ModelPart&amp; mp = *mListOfSubModelParts[i];</span></a>
<a name="532"><span class="lineNum">     532 </span><span class="lineNoCov">          0 :             if (mp[DENSE_INLET]) {</span></a>
<a name="533"><span class="lineNum">     533 </span>            :                 is_there_any_dense_inlet = true;</a>
<a name="534"><span class="lineNum">     534 </span>            :                 break;</a>
<a name="535"><span class="lineNum">     535 </span>            :             }</a>
<a name="536"><span class="lineNum">     536 </span>            :         }</a>
<a name="537"><span class="lineNum">     537 </span><span class="lineNoCov">          0 :         if (is_there_any_dense_inlet){</span></a>
<a name="538"><span class="lineNum">     538 </span><span class="lineNoCov">          0 :             CheckDistanceAndSetFlag(r_modelpart);}</span></a>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<a name="540"><span class="lineNum">     540 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="541"><span class="lineNum">     541 </span>            : </a>
<a name="542"><span class="lineNum">     542 </span><span class="lineNoCov">          0 :     void DEM_Inlet::CreateElementsFromInletMesh(ModelPart&amp; r_modelpart, ModelPart&amp; r_clusters_modelpart, ParticleCreatorDestructor&amp; creator) {</span></a>
<a name="543"><span class="lineNum">     543 </span><span class="lineNoCov">          0 :         InitializeStep(r_modelpart);</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineNoCov">          0 :         unsigned int&amp; max_Id=creator.mMaxNodeId;</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineNoCov">          0 :         const double current_time = r_modelpart.GetProcessInfo()[TIME];</span></a>
<a name="546"><span class="lineNum">     546 </span><span class="lineNoCov">          0 :         DettachElements(r_modelpart, max_Id);</span></a>
<a name="547"><span class="lineNum">     547 </span><span class="lineNoCov">          0 :         DettachClusters(r_clusters_modelpart, max_Id);</span></a>
<a name="548"><span class="lineNum">     548 </span>            : </a>
<a name="549"><span class="lineNum">     549 </span>            :         int smp_number = 0;</a>
<a name="550"><span class="lineNum">     550 </span>            :         int inter_smp_number = 0;</a>
<a name="551"><span class="lineNum">     551 </span>            : </a>
<a name="552"><span class="lineNum">     552 </span><span class="lineNoCov">          0 :         for(int i=0; i&lt;(int)mListOfSubModelParts.size(); i++) {</span></a>
<a name="553"><span class="lineNum">     553 </span><span class="lineNoCov">          0 :             ModelPart&amp; mp = *mListOfSubModelParts[i];</span></a>
<a name="554"><span class="lineNum">     554 </span>            : </a>
<a name="555"><span class="lineNum">     555 </span><span class="lineNoCov">          0 :             const double inlet_start_time = mp[INLET_START_TIME];</span></a>
<a name="556"><span class="lineNum">     556 </span><span class="lineNoCov">          0 :             if (current_time &lt; inlet_start_time) continue;</span></a>
<a name="557"><span class="lineNum">     557 </span>            : </a>
<a name="558"><span class="lineNum">     558 </span><span class="lineNoCov">          0 :             const int mesh_size_elements = mp.NumberOfElements();</span></a>
<a name="559"><span class="lineNum">     559 </span>            : </a>
<a name="560"><span class="lineNum">     560 </span>            :             ModelPart::ElementsContainerType::ContainerType&amp; all_elements = mp.ElementsArray();</a>
<a name="561"><span class="lineNum">     561 </span>            : </a>
<a name="562"><span class="lineNum">     562 </span><span class="lineNoCov">          0 :             if (current_time &gt; mp[INLET_STOP_TIME]) {</span></a>
<a name="563"><span class="lineNum">     563 </span><span class="lineNoCov">          0 :                 if (mLayerRemoved[inter_smp_number]) continue;</span></a>
<a name="564"><span class="lineNum">     564 </span><span class="lineNoCov">          0 :                 for (int i = 0; i &lt; mesh_size_elements; i++) {</span></a>
<a name="565"><span class="lineNum">     565 </span><span class="lineNoCov">          0 :                     all_elements[i]-&gt;Set(TO_ERASE, true);</span></a>
<a name="566"><span class="lineNum">     566 </span><span class="lineNoCov">          0 :                     all_elements[i]-&gt;GetGeometry()[0].Set(TO_ERASE, true);</span></a>
<a name="567"><span class="lineNum">     567 </span>            :                 }</a>
<a name="568"><span class="lineNum">     568 </span>            :                 mLayerRemoved[inter_smp_number] = true;</a>
<a name="569"><span class="lineNum">     569 </span><span class="lineNoCov">          0 :                 inter_smp_number++;</span></a>
<a name="570"><span class="lineNum">     570 </span><span class="lineNoCov">          0 :                 continue;</span></a>
<a name="571"><span class="lineNum">     571 </span><span class="lineNoCov">          0 :             }</span></a>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<a name="573"><span class="lineNum">     573 </span><span class="lineNoCov">          0 :             int total_mesh_size_accross_mpi_processes = r_modelpart.GetCommunicator().GetDataCommunicator().SumAll(mesh_size_elements);</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineNoCov">          0 :             const double this_mpi_process_portion_of_inlet_mesh = (double) mesh_size_elements / (double) total_mesh_size_accross_mpi_processes;</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineNoCov">          0 :             double num_part_surface_time = GetInputNumberOfParticles(mp);</span></a>
<a name="576"><span class="lineNum">     576 </span><span class="lineNoCov">          0 :             num_part_surface_time *= this_mpi_process_portion_of_inlet_mesh;</span></a>
<a name="577"><span class="lineNum">     577 </span><span class="lineNoCov">          0 :             const double delta_t = current_time - mLastInjectionTimes[smp_number]; // FLUID DELTA_T CAN BE USED ALSO, it will depend on how often we call this function</span></a>
<a name="578"><span class="lineNum">     578 </span>            :             double surface = 1.0; //inlet_surface, this should probably be projected to velocity vector</a>
<a name="579"><span class="lineNum">     579 </span>            : </a>
<a name="580"><span class="lineNum">     580 </span>            :             int number_of_particles_to_insert = 0;</a>
<a name="581"><span class="lineNum">     581 </span><span class="lineNoCov">          0 :             const double mass_flow = mp[MASS_FLOW];</span></a>
<a name="582"><span class="lineNum">     582 </span><span class="lineNoCov">          0 :             const bool imposed_mass_flow_option = mp.Has(IMPOSED_MASS_FLOW_OPTION) &amp;&amp; mp[IMPOSED_MASS_FLOW_OPTION];</span></a>
<a name="583"><span class="lineNum">     583 </span>            :             if(imposed_mass_flow_option){</a>
<a name="584"><span class="lineNum">     584 </span>            :                 number_of_particles_to_insert = mesh_size_elements; // The maximum possible, to increase random.</a>
<a name="585"><span class="lineNum">     585 </span>            : </a>
<a name="586"><span class="lineNum">     586 </span><span class="lineNoCov">          0 :                 if(mass_flow) {</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineNoCov">          0 :                     const double mean_radius = SetDistributionMeanRadius(mp);</span></a>
<a name="588"><span class="lineNum">     588 </span><span class="lineNoCov">          0 :                     const double density = r_modelpart.GetProperties(mp[PROPERTIES_ID])[PARTICLE_DENSITY];</span></a>
<a name="589"><span class="lineNum">     589 </span><span class="lineNoCov">          0 :                     const double estimated_mass_of_a_particle = density * 4.0/3.0 * Globals::Pi * mean_radius * mean_radius * mean_radius;</span></a>
<a name="590"><span class="lineNum">     590 </span><span class="lineNoCov">          0 :                     const double maximum_time_until_release = estimated_mass_of_a_particle * mesh_size_elements / mass_flow;</span></a>
<a name="591"><span class="lineNum">     591 </span><span class="lineNoCov">          0 :                     const double minimum_velocity = mean_radius * 3.0 / maximum_time_until_release; //The distance necessary to get out of the injector, over the time.</span></a>
<a name="592"><span class="lineNum">     592 </span>            :                     array_1d&lt;double, 3&gt; &amp; proposed_velocity = mp[INLET_INITIAL_PARTICLES_VELOCITY];</a>
<a name="593"><span class="lineNum">     593 </span>            :                     double&amp; limited_velocity = mp[INLET_MAX_PARTICLES_VELOCITY];</a>
<a name="594"><span class="lineNum">     594 </span><span class="lineNoCov">          0 :                     const double modulus_of_proposed_velocity = DEM_MODULUS_3(proposed_velocity);</span></a>
<a name="595"><span class="lineNum">     595 </span>            :                     const double factor = 2.0;</a>
<a name="596"><span class="lineNum">     596 </span><span class="lineNoCov">          0 :                     double injection_speed = factor * minimum_velocity;</span></a>
<a name="597"><span class="lineNum">     597 </span><span class="lineNoCov">          0 :                     const bool dense_option = mp[DENSE_INLET];</span></a>
<a name="598"><span class="lineNum">     598 </span><span class="lineNoCov">          0 :                     if (!dense_option &amp;&amp; injection_speed &gt; limited_velocity) {injection_speed = limited_velocity;}</span></a>
<a name="599"><span class="lineNum">     599 </span><span class="lineNoCov">          0 :                     DEM_MULTIPLY_BY_SCALAR_3(proposed_velocity, injection_speed / modulus_of_proposed_velocity);</span></a>
<a name="600"><span class="lineNum">     600 </span>            :                 }</a>
<a name="601"><span class="lineNum">     601 </span>            :             }</a>
<a name="602"><span class="lineNum">     602 </span>            :             else {</a>
<a name="603"><span class="lineNum">     603 </span>            :                 //calculate number of particles to insert from input data</a>
<a name="604"><span class="lineNum">     604 </span><span class="lineNoCov">          0 :                 const double double_number_of_particles_to_insert = num_part_surface_time * delta_t * surface + mPartialParticleToInsert[smp_number];</span></a>
<a name="605"><span class="lineNum">     605 </span>            : </a>
<a name="606"><span class="lineNum">     606 </span><span class="lineNoCov">          0 :                 if (double_number_of_particles_to_insert &lt; INT_MAX){ // otherwise the precision is not enough to see the residuals</span></a>
<a name="607"><span class="lineNum">     607 </span><span class="lineNoCov">          0 :                     number_of_particles_to_insert = std::trunc(double_number_of_particles_to_insert);</span></a>
<a name="608"><span class="lineNum">     608 </span><span class="lineNoCov">          0 :                     mPartialParticleToInsert[smp_number] = double_number_of_particles_to_insert - number_of_particles_to_insert;</span></a>
<a name="609"><span class="lineNum">     609 </span>            :                 }</a>
<a name="610"><span class="lineNum">     610 </span>            : </a>
<a name="611"><span class="lineNum">     611 </span>            :                 else {</a>
<a name="612"><span class="lineNum">     612 </span>            :                     number_of_particles_to_insert = INT_MAX;</a>
<a name="613"><span class="lineNum">     613 </span>            :                 }</a>
<a name="614"><span class="lineNum">     614 </span>            :             }</a>
<a name="615"><span class="lineNum">     615 </span>            : </a>
<a name="616"><span class="lineNum">     616 </span><span class="lineNoCov">          0 :             if (number_of_particles_to_insert) {</span></a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span><span class="lineNoCov">          0 :                 ModelPart::ElementsContainerType::ContainerType valid_elements(mesh_size_elements); //This is a new vector we are going to work on</span></a>
<a name="619"><span class="lineNum">     619 </span>            :                 int valid_elements_length = 0;</a>
<a name="620"><span class="lineNum">     620 </span>            : </a>
<a name="621"><span class="lineNum">     621 </span><span class="lineNoCov">          0 :                 for (int i = 0; i &lt; mesh_size_elements; i++) {</span></a>
<a name="622"><span class="lineNum">     622 </span><span class="lineNoCov">          0 :                     if (all_elements[i]-&gt;IsNot(ACTIVE) &amp;&amp; !OneNeighbourInjectorIsInjecting(all_elements[i])) {</span></a>
<a name="623"><span class="lineNum">     623 </span><span class="lineNoCov">          0 :                         valid_elements[valid_elements_length] = all_elements[i];</span></a>
<a name="624"><span class="lineNum">     624 </span><span class="lineNoCov">          0 :                         valid_elements_length++;</span></a>
<a name="625"><span class="lineNum">     625 </span>            :                     } // (push_back) //Inlet BLOCKED nodes are ACTIVE when injecting, but once they are not in contact with other balls, ACTIVE can be reseted.</a>
<a name="626"><span class="lineNum">     626 </span>            :                 }</a>
<a name="627"><span class="lineNum">     627 </span>            : </a>
<a name="628"><span class="lineNum">     628 </span><span class="lineNoCov">          0 :                  if (valid_elements_length &lt; number_of_particles_to_insert) {</span></a>
<a name="629"><span class="lineNum">     629 </span>            :                     number_of_particles_to_insert = valid_elements_length;</a>
<a name="630"><span class="lineNum">     630 </span><span class="lineNoCov">          0 :                     if(!imposed_mass_flow_option){</span></a>
<a name="631"><span class="lineNum">     631 </span><span class="lineNoCov">          0 :                         ThrowWarningTooSmallInlet(mp);</span></a>
<a name="632"><span class="lineNum">     632 </span>            :                     }</a>
<a name="633"><span class="lineNum">     633 </span>            :                 }</a>
<a name="634"><span class="lineNum">     634 </span>            : </a>
<a name="635"><span class="lineNum">     635 </span>            :                 PropertiesProxy* p_fast_properties = NULL;</a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :                 int general_properties_id = r_modelpart.GetProperties(mp[PROPERTIES_ID]).Id();</span></a>
<a name="637"><span class="lineNum">     637 </span><span class="lineNoCov">          0 :                 for (unsigned int i = 0; i &lt; mFastProperties.size(); i++) {</span></a>
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 :                     int fast_properties_id = mFastProperties[i].GetId();</span></a>
<a name="639"><span class="lineNum">     639 </span><span class="lineNoCov">          0 :                     if (fast_properties_id == general_properties_id) {</span></a>
<a name="640"><span class="lineNum">     640 </span>            :                         p_fast_properties = &amp;(mFastProperties[i]);</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineNoCov">          0 :                         break;</span></a>
<a name="642"><span class="lineNum">     642 </span>            :                     }</a>
<a name="643"><span class="lineNum">     643 </span>            :                 }</a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span>            :                 const array_1d&lt;double, 3&gt; angular_velocity = mp[ANGULAR_VELOCITY];</a>
<a name="646"><span class="lineNum">     646 </span><span class="lineNoCov">          0 :                 const double mod_angular_velocity = MathUtils&lt;double&gt;::Norm3(angular_velocity);</span></a>
<a name="647"><span class="lineNum">     647 </span><span class="lineNoCov">          0 :                 const double angular_velocity_start_time = mp[ANGULAR_VELOCITY_START_TIME];</span></a>
<a name="648"><span class="lineNum">     648 </span><span class="lineNoCov">          0 :                 const double angular_velocity_stop_time = mp[ANGULAR_VELOCITY_STOP_TIME];</span></a>
<a name="649"><span class="lineNum">     649 </span><span class="lineNoCov">          0 :                 const double angular_period = mp[ANGULAR_VELOCITY_PERIOD];</span></a>
<a name="650"><span class="lineNum">     650 </span>            :                 array_1d&lt;double, 3&gt; angular_velocity_changed, new_axes1, new_axes2, new_axes3;</a>
<a name="651"><span class="lineNum">     651 </span>            : </a>
<a name="652"><span class="lineNum">     652 </span>            :                 // The objective of the function call that follows is to rotate the inlet velocity, thus preserving perpendicularity with respect to the inlet plane.</a>
<a name="653"><span class="lineNum">     653 </span>            :                 // Here we compute the three axis new_axes1, new_axes2, new_axes3 where we will have to project the initial inlet velocity to obtain the actual inlet velocity.</a>
<a name="654"><span class="lineNum">     654 </span><span class="lineNoCov">          0 :                 GeometryFunctions::RotateGridOfNodes(current_time, angular_velocity_start_time, angular_velocity_stop_time, angular_velocity_changed,</span></a>
<a name="655"><span class="lineNum">     655 </span>            :                                                      angular_period, mod_angular_velocity, angular_velocity, new_axes1, new_axes2, new_axes3);</a>
<a name="656"><span class="lineNum">     656 </span>            : </a>
<a name="657"><span class="lineNum">     657 </span>            :                 array_1d&lt;double, 3&gt; inlet_initial_velocity = mp[INLET_INITIAL_VELOCITY];</a>
<a name="658"><span class="lineNum">     658 </span>            :                 array_1d&lt;double, 3&gt; inlet_initial_particles_velocity = mp[INLET_INITIAL_PARTICLES_VELOCITY];</a>
<a name="659"><span class="lineNum">     659 </span>            :                 // Dot product to compute the updated inlet velocity from the initial one:</a>
<a name="660"><span class="lineNum">     660 </span><span class="lineNoCov">          0 :                 mp[LINEAR_VELOCITY] = new_axes1 * inlet_initial_velocity[0] + new_axes2 * inlet_initial_velocity[1] + new_axes3 * inlet_initial_velocity[2];</span></a>
<a name="661"><span class="lineNum">     661 </span><span class="lineNoCov">          0 :                 mp[VELOCITY] = new_axes1 * inlet_initial_particles_velocity[0] + new_axes2 * inlet_initial_particles_velocity[1] + new_axes3 * inlet_initial_particles_velocity[2];</span></a>
<a name="662"><span class="lineNum">     662 </span>            :                 std::string&amp; ElementNameString = mp[ELEMENT_TYPE];</a>
<a name="663"><span class="lineNum">     663 </span>            :                 const Element&amp; r_reference_element = KratosComponents&lt;Element&gt;::Get(ElementNameString);</a>
<a name="664"><span class="lineNum">     664 </span>            : </a>
<a name="665"><span class="lineNum">     665 </span><span class="lineNoCov">          0 :                 Properties::Pointer p_properties = r_modelpart.pGetProperties(mp[PROPERTIES_ID]);</span></a>
<a name="666"><span class="lineNum">     666 </span>            : </a>
<a name="667"><span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 const double mass_that_should_have_been_inserted_so_far = mass_flow * (current_time - inlet_start_time);</span></a>
<a name="668"><span class="lineNum">     668 </span>            : </a>
<a name="669"><span class="lineNum">     669 </span>            :                 std::uniform_int_distribution&lt;&gt; distrib(0, valid_elements_length - 1);</a>
<a name="670"><span class="lineNum">     670 </span>            : </a>
<a name="671"><span class="lineNum">     671 </span>            :                 int i=0;</a>
<a name="672"><span class="lineNum">     672 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; number_of_particles_to_insert; i++) {</span></a>
<a name="673"><span class="lineNum">     673 </span>            : </a>
<a name="674"><span class="lineNum">     674 </span><span class="lineNoCov">          0 :                     if (imposed_mass_flow_option) {</span></a>
<a name="675"><span class="lineNum">     675 </span><span class="lineNoCov">          0 :                         if(GetPartialMassInjectedSoFar(smp_number) &gt;= mass_that_should_have_been_inserted_so_far ) {</span></a>
<a name="676"><span class="lineNum">     676 </span>            :                             break;</a>
<a name="677"><span class="lineNum">     677 </span>            :                         }</a>
<a name="678"><span class="lineNum">     678 </span>            :                     }</a>
<a name="679"><span class="lineNum">     679 </span>            : </a>
<a name="680"><span class="lineNum">     680 </span><span class="lineNoCov">          0 :                     int random_pos = mGenerator() % valid_elements_length;</span></a>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<a name="682"><span class="lineNum">     682 </span><span class="lineNoCov">          0 :                     Element* p_injector_element = valid_elements[random_pos].get();</span></a>
<a name="683"><span class="lineNum">     683 </span>            : </a>
<a name="684"><span class="lineNum">     684 </span><span class="lineNoCov">          0 :                     if (mp[CONTAINS_CLUSTERS] == false) {</span></a>
<a name="685"><span class="lineNum">     685 </span><span class="lineNoCov">          0 :                         SphericParticle* p_spheric_particle = creator.ElementCreatorWithPhysicalParameters(r_modelpart,</span></a>
<a name="686"><span class="lineNum">     686 </span><span class="lineNoCov">          0 :                                                                                     max_Id+1,</span></a>
<a name="687"><span class="lineNum">     687 </span>            :                                                                                     valid_elements[random_pos]-&gt;GetGeometry()(0),</a>
<a name="688"><span class="lineNum">     688 </span>            :                                                                                     valid_elements[random_pos],</a>
<a name="689"><span class="lineNum">     689 </span>            :                                                                                     //This only works for random_pos as real position in the vector if</a>
<a name="690"><span class="lineNum">     690 </span>            :                                                                                     //we use ModelPart::NodesContainerType::ContainerType instead of ModelPart::NodesContainerType</a>
<a name="691"><span class="lineNum">     691 </span>            :                                                                                     p_properties,</a>
<a name="692"><span class="lineNum">     692 </span>            :                                                                                     mp,</a>
<a name="693"><span class="lineNum">     693 </span><span class="lineNoCov">          0 :                                                                                     mInletsRandomVariables,</span></a>
<a name="694"><span class="lineNum">     694 </span>            :                                                                                     r_reference_element,</a>
<a name="695"><span class="lineNum">     695 </span>            :                                                                                     p_fast_properties,</a>
<a name="696"><span class="lineNum">     696 </span><span class="lineNoCov">          0 :                                                                                     mBallsModelPartHasSphericity,</span></a>
<a name="697"><span class="lineNum">     697 </span><span class="lineNoCov">          0 :                                                                                     mBallsModelPartHasRotation,</span></a>
<a name="698"><span class="lineNum">     698 </span>            :                                                                                     false,</a>
<a name="699"><span class="lineNum">     699 </span>            :                                                                                     mp.Elements());</a>
<a name="700"><span class="lineNum">     700 </span>            : </a>
<a name="701"><span class="lineNum">     701 </span><span class="lineNoCov">          0 :                         mOriginInletSubmodelPartIndexes[p_spheric_particle-&gt;Id()] = mp.Name();</span></a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :                         FixInjectionConditions(p_spheric_particle, p_injector_element);</span></a>
<a name="703"><span class="lineNum">     703 </span><span class="lineNoCov">          0 :                         UpdatePartialThroughput(*p_spheric_particle, smp_number);</span></a>
<a name="704"><span class="lineNum">     704 </span><span class="lineNoCov">          0 :                         max_Id++;</span></a>
<a name="705"><span class="lineNum">     705 </span>            :                     }</a>
<a name="706"><span class="lineNum">     706 </span>            :                     else {</a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span><span class="lineNoCov">          0 :                         int number_of_added_spheres = 0;</span></a>
<a name="709"><span class="lineNum">     709 </span>            :                         std::vector&lt;SphericParticle*&gt; new_component_spheres;</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineNoCov">          0 :                         Cluster3D* p_cluster = creator.ClusterCreatorWithPhysicalParameters(r_modelpart,</span></a>
<a name="711"><span class="lineNum">     711 </span>            :                                                                                             r_clusters_modelpart,</a>
<a name="712"><span class="lineNum">     712 </span><span class="lineNoCov">          0 :                                                                                             max_Id+1,</span></a>
<a name="713"><span class="lineNum">     713 </span>            :                                                                                             valid_elements[random_pos]-&gt;GetGeometry()(0),</a>
<a name="714"><span class="lineNum">     714 </span>            :                                                                                             valid_elements[random_pos],</a>
<a name="715"><span class="lineNum">     715 </span>            :                                                                                             //This only works for random_pos as real position in the vector if</a>
<a name="716"><span class="lineNum">     716 </span>            :                                                                                             //we use ModelPart::NodesContainerType::ContainerType instead of ModelPart::NodesContainerType</a>
<a name="717"><span class="lineNum">     717 </span>            :                                                                                             p_properties,</a>
<a name="718"><span class="lineNum">     718 </span>            :                                                                                             mp,</a>
<a name="719"><span class="lineNum">     719 </span>            :                                                                                             r_reference_element,</a>
<a name="720"><span class="lineNum">     720 </span>            :                                                                                             p_fast_properties,</a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :                                                                                             mBallsModelPartHasSphericity,</span></a>
<a name="722"><span class="lineNum">     722 </span><span class="lineNoCov">          0 :                                                                                             mBallsModelPartHasRotation,</span></a>
<a name="723"><span class="lineNum">     723 </span>            :                                                                                             mp.Elements(),</a>
<a name="724"><span class="lineNum">     724 </span>            :                                                                                             number_of_added_spheres,</a>
<a name="725"><span class="lineNum">     725 </span><span class="lineNoCov">          0 :                                                                                             mStrategyForContinuum,</span></a>
<a name="726"><span class="lineNum">     726 </span>            :                                                                                             new_component_spheres);</a>
<a name="727"><span class="lineNum">     727 </span>            : </a>
<a name="728"><span class="lineNum">     728 </span><span class="lineNoCov">          0 :                         max_Id += number_of_added_spheres;</span></a>
<a name="729"><span class="lineNum">     729 </span><span class="lineNoCov">          0 :                         if (p_cluster) {</span></a>
<a name="730"><span class="lineNum">     730 </span><span class="lineNoCov">          0 :                             mOriginInletSubmodelPartIndexes[p_cluster-&gt;Id()] = mp.Name();</span></a>
<a name="731"><span class="lineNum">     731 </span><span class="lineNoCov">          0 :                             UpdateInjectedParticleVelocity(*p_cluster, *p_injector_element);</span></a>
<a name="732"><span class="lineNum">     732 </span>            :                         }</a>
<a name="733"><span class="lineNum">     733 </span>            : </a>
<a name="734"><span class="lineNum">     734 </span>            :                         else {</a>
<a name="735"><span class="lineNum">     735 </span><span class="lineNoCov">          0 :                             for (unsigned int i = 0; i &lt; new_component_spheres.size(); ++i) {</span></a>
<a name="736"><span class="lineNum">     736 </span><span class="lineNoCov">          0 :                                 mOriginInletSubmodelPartIndexes[new_component_spheres[i]-&gt;Id()] = mp.Name();</span></a>
<a name="737"><span class="lineNum">     737 </span><span class="lineNoCov">          0 :                                 UpdateInjectedParticleVelocity(*new_component_spheres[i], *p_injector_element);</span></a>
<a name="738"><span class="lineNum">     738 </span>            : </a>
<a name="739"><span class="lineNum">     739 </span>            :                             }</a>
<a name="740"><span class="lineNum">     740 </span>            :                         }</a>
<a name="741"><span class="lineNum">     741 </span>            :                     }</a>
<a name="742"><span class="lineNum">     742 </span>            : </a>
<a name="743"><span class="lineNum">     743 </span><span class="lineNoCov">          0 :                     valid_elements[random_pos]-&gt;Set(ACTIVE); //Inlet BLOCKED nodes are ACTIVE when injecting, but once they are not in contact with other balls, ACTIVE can be reseted.</span></a>
<a name="744"><span class="lineNum">     744 </span><span class="lineNoCov">          0 :                     valid_elements[random_pos]-&gt;GetGeometry()[0].Set(ACTIVE);</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineNoCov">          0 :                     valid_elements[random_pos] = valid_elements[valid_elements_length - 1]; //Last position overwrites random_pos</span></a>
<a name="746"><span class="lineNum">     746 </span>            :                     valid_elements_length--; //we remove last position and next random_pos has one less option</a>
<a name="747"><span class="lineNum">     747 </span>            :                 }</a>
<a name="748"><span class="lineNum">     748 </span>            : </a>
<a name="749"><span class="lineNum">     749 </span><span class="lineNoCov">          0 :                 if(imposed_mass_flow_option) {</span></a>
<a name="750"><span class="lineNum">     750 </span><span class="lineNoCov">          0 :                     if (i == number_of_particles_to_insert &amp;&amp; (GetPartialMassInjectedSoFar(smp_number) &lt; mass_that_should_have_been_inserted_so_far ) &amp;&amp; mFirstInjectionIsDone == true) {</span></a>
<a name="751"><span class="lineNum">     751 </span><span class="lineNoCov">          0 :                         ThrowWarningTooSmallInletForMassFlow(mp);</span></a>
<a name="752"><span class="lineNum">     752 </span>            :                     }</a>
<a name="753"><span class="lineNum">     753 </span>            :                 }</a>
<a name="754"><span class="lineNum">     754 </span>            : </a>
<a name="755"><span class="lineNum">     755 </span><span class="lineNoCov">          0 :             } //if (number_of_particles_to_insert)</span></a>
<a name="756"><span class="lineNum">     756 </span><span class="lineNoCov">          0 :             mLastInjectionTimes[smp_number] = current_time;</span></a>
<a name="757"><span class="lineNum">     757 </span><span class="lineNoCov">          0 :             smp_number++;</span></a>
<a name="758"><span class="lineNum">     758 </span>            :         } // for smp_it</a>
<a name="759"><span class="lineNum">     759 </span>            : </a>
<a name="760"><span class="lineNum">     760 </span><span class="lineNoCov">          0 :         creator.RemoveUnusedNodesOfTheClustersModelPart(r_clusters_modelpart);</span></a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :         mFirstInjectionIsDone = true;</span></a>
<a name="762"><span class="lineNum">     762 </span>            : </a>
<a name="763"><span class="lineNum">     763 </span><span class="lineNoCov">          0 :     }    //CreateElementsFromInletMesh</span></a>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<a name="765"><span class="lineNum">     765 </span>            : </a>
<a name="766"><span class="lineNum">     766 </span><span class="lineNoCov">          0 :     void DEM_Inlet::AddRandomPerpendicularComponentToGivenVector2D(array_1d&lt;double, 3 &gt;&amp; vector, const double angle_in_radians)</span></a>
<a name="767"><span class="lineNum">     767 </span>            :     {</a>
<a name="768"><span class="lineNum">     768 </span>            :         KRATOS_TRY</a>
<a name="769"><span class="lineNum">     769 </span>            : </a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :         const double vector_modulus = DEM_MODULUS_3(vector);</span></a>
<a name="771"><span class="lineNum">     771 </span>            :         array_1d&lt;double, 3 &gt; unitary_vector;</a>
<a name="772"><span class="lineNum">     772 </span>            :         noalias(unitary_vector) = vector / vector_modulus;</a>
<a name="773"><span class="lineNum">     773 </span>            :         array_1d&lt;double, 3 &gt; normal_1;</a>
<a name="774"><span class="lineNum">     774 </span>            :         array_1d&lt;double, 3 &gt; normal_2;</a>
<a name="775"><span class="lineNum">     775 </span>            : </a>
<a name="776"><span class="lineNum">     776 </span><span class="lineNoCov">          0 :         if (std::abs(unitary_vector[0])&gt;=0.707) {</span></a>
<a name="777"><span class="lineNum">     777 </span><span class="lineNoCov">          0 :             normal_1[0]= unitary_vector[1];</span></a>
<a name="778"><span class="lineNum">     778 </span><span class="lineNoCov">          0 :             normal_1[1]= - unitary_vector[0];</span></a>
<a name="779"><span class="lineNum">     779 </span><span class="lineNoCov">          0 :             normal_1[2]= 0.0;</span></a>
<a name="780"><span class="lineNum">     780 </span>            :         }</a>
<a name="781"><span class="lineNum">     781 </span>            :         else {</a>
<a name="782"><span class="lineNum">     782 </span><span class="lineNoCov">          0 :             normal_1[0]= unitary_vector[1];</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineNoCov">          0 :             normal_1[1]= unitary_vector[0];</span></a>
<a name="784"><span class="lineNum">     784 </span><span class="lineNoCov">          0 :             normal_1[2]= 0.0;</span></a>
<a name="785"><span class="lineNum">     785 </span>            :         }</a>
<a name="786"><span class="lineNum">     786 </span>            : </a>
<a name="787"><span class="lineNum">     787 </span>            :         //normalize(normal_1);</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineNoCov">          0 :         const double distance0 = DEM_MODULUS_3(normal_1);</span></a>
<a name="789"><span class="lineNum">     789 </span><span class="lineNoCov">          0 :         const double inv_distance0 = (distance0 != 0.0) ? 1.0 / distance0 : 0.00;</span></a>
<a name="790"><span class="lineNum">     790 </span><span class="lineNoCov">          0 :         normal_1[0] *= inv_distance0;</span></a>
<a name="791"><span class="lineNum">     791 </span><span class="lineNoCov">          0 :         normal_1[1] *= inv_distance0;</span></a>
<a name="792"><span class="lineNum">     792 </span>            : </a>
<a name="793"><span class="lineNum">     793 </span><span class="lineNoCov">          0 :         const double radius = tan(angle_in_radians) * vector_modulus;</span></a>
<a name="794"><span class="lineNum">     794 </span><span class="lineNoCov">          0 :         const double radius_square = radius * radius;</span></a>
<a name="795"><span class="lineNum">     795 </span><span class="lineNoCov">          0 :         double local_added_vector_modulus_square = radius_square + 1.0;</span></a>
<a name="796"><span class="lineNum">     796 </span><span class="lineNoCov">          0 :         array_1d&lt;double, 3&gt; local_added_vector; local_added_vector[0] = local_added_vector[1] = local_added_vector[2] = 0.0;</span></a>
<a name="797"><span class="lineNum">     797 </span>            : </a>
<a name="798"><span class="lineNum">     798 </span><span class="lineNoCov">          0 :         while (local_added_vector_modulus_square &gt; radius_square) {</span></a>
<a name="799"><span class="lineNum">     799 </span><span class="lineNoCov">          0 :             local_added_vector[0] = 2.0*radius * (double)rand() / (double)RAND_MAX - radius;</span></a>
<a name="800"><span class="lineNum">     800 </span><span class="lineNoCov">          0 :             local_added_vector_modulus_square = local_added_vector[0]*local_added_vector[0];</span></a>
<a name="801"><span class="lineNum">     801 </span>            :         }</a>
<a name="802"><span class="lineNum">     802 </span>            :         noalias(vector) += local_added_vector[0] * normal_1;</a>
<a name="803"><span class="lineNum">     803 </span>            :         KRATOS_CATCH(&quot;&quot;)</a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="805"><span class="lineNum">     805 </span>            : </a>
<a name="806"><span class="lineNum">     806 </span>            : </a>
<a name="807"><span class="lineNum">     807 </span><span class="lineNoCov">          0 :     void DEM_Inlet::AddRandomPerpendicularComponentToGivenVector(array_1d&lt;double, 3 &gt;&amp; vector, const double angle_in_radians)</span></a>
<a name="808"><span class="lineNum">     808 </span>            :     {</a>
<a name="809"><span class="lineNum">     809 </span>            :         KRATOS_TRY</a>
<a name="810"><span class="lineNum">     810 </span><span class="lineNoCov">          0 :         const double vector_modulus = DEM_MODULUS_3(vector);</span></a>
<a name="811"><span class="lineNum">     811 </span>            :         array_1d&lt;double, 3 &gt; unitary_vector;</a>
<a name="812"><span class="lineNum">     812 </span>            :         noalias(unitary_vector) = vector / vector_modulus;</a>
<a name="813"><span class="lineNum">     813 </span>            :         array_1d&lt;double, 3 &gt; normal_1;</a>
<a name="814"><span class="lineNum">     814 </span>            :         array_1d&lt;double, 3 &gt; normal_2;</a>
<a name="815"><span class="lineNum">     815 </span>            : </a>
<a name="816"><span class="lineNum">     816 </span><span class="lineNoCov">          0 :         if (std::abs(unitary_vector[0])&gt;=0.577) {</span></a>
<a name="817"><span class="lineNum">     817 </span><span class="lineNoCov">          0 :             normal_1[0]= - unitary_vector[1];</span></a>
<a name="818"><span class="lineNum">     818 </span><span class="lineNoCov">          0 :             normal_1[1]= unitary_vector[0];</span></a>
<a name="819"><span class="lineNum">     819 </span><span class="lineNoCov">          0 :             normal_1[2]= 0.0;</span></a>
<a name="820"><span class="lineNum">     820 </span>            :         }</a>
<a name="821"><span class="lineNum">     821 </span><span class="lineNoCov">          0 :         else if (std::abs(unitary_vector[1])&gt;=0.577) {</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineNoCov">          0 :             normal_1[0]= 0.0;</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineNoCov">          0 :             normal_1[1]= - unitary_vector[2];</span></a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :             normal_1[2]= unitary_vector[1];</span></a>
<a name="825"><span class="lineNum">     825 </span>            :         }</a>
<a name="826"><span class="lineNum">     826 </span>            :         else {</a>
<a name="827"><span class="lineNum">     827 </span><span class="lineNoCov">          0 :             normal_1[0]= unitary_vector[2];</span></a>
<a name="828"><span class="lineNum">     828 </span><span class="lineNoCov">          0 :             normal_1[1]= 0.0;</span></a>
<a name="829"><span class="lineNum">     829 </span><span class="lineNoCov">          0 :             normal_1[2]= - unitary_vector[0];</span></a>
<a name="830"><span class="lineNum">     830 </span>            :         }</a>
<a name="831"><span class="lineNum">     831 </span>            : </a>
<a name="832"><span class="lineNum">     832 </span>            :         //normalize(normal_1);</a>
<a name="833"><span class="lineNum">     833 </span><span class="lineNoCov">          0 :         const double distance0 = DEM_MODULUS_3(normal_1);</span></a>
<a name="834"><span class="lineNum">     834 </span><span class="lineNoCov">          0 :         const double inv_distance0 = (distance0 != 0.0) ? 1.0 / distance0 : 0.00;</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineNoCov">          0 :         normal_1[0] *= inv_distance0;</span></a>
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 :         normal_1[1] *= inv_distance0;</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineNoCov">          0 :         normal_1[2] *= inv_distance0;</span></a>
<a name="838"><span class="lineNum">     838 </span>            : </a>
<a name="839"><span class="lineNum">     839 </span>            :         //CrossProduct(NormalDirection,Vector0,Vector1);</a>
<a name="840"><span class="lineNum">     840 </span><span class="lineNoCov">          0 :         DEM_SET_TO_CROSS_OF_FIRST_TWO_3(unitary_vector, normal_1, normal_2)</span></a>
<a name="841"><span class="lineNum">     841 </span>            : </a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :         const double radius = tan(angle_in_radians) * vector_modulus;</span></a>
<a name="843"><span class="lineNum">     843 </span><span class="lineNoCov">          0 :         const double radius_square = radius * radius;</span></a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 :         double local_added_vector_modulus_square = radius_square + 1.0; //just greater than the radius, to get at least one iteration of the while</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :         array_1d&lt;double, 3&gt; local_added_vector; local_added_vector[0] = local_added_vector[1] = local_added_vector[2] = 0.0;</span></a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :         while (local_added_vector_modulus_square &gt; radius_square) {</span></a>
<a name="848"><span class="lineNum">     848 </span>            :             //Random in a range: (max - min) * ( (double)rand() / (double)RAND_MAX ) + min</a>
<a name="849"><span class="lineNum">     849 </span><span class="lineNoCov">          0 :             local_added_vector[0] = 2*radius * (double)rand() / (double)RAND_MAX - radius;</span></a>
<a name="850"><span class="lineNum">     850 </span><span class="lineNoCov">          0 :             local_added_vector[1] = 2*radius * (double)rand() / (double)RAND_MAX - radius;</span></a>
<a name="851"><span class="lineNum">     851 </span><span class="lineNoCov">          0 :             local_added_vector_modulus_square = local_added_vector[0]*local_added_vector[0] + local_added_vector[1]*local_added_vector[1];</span></a>
<a name="852"><span class="lineNum">     852 </span>            :         }</a>
<a name="853"><span class="lineNum">     853 </span>            : </a>
<a name="854"><span class="lineNum">     854 </span><span class="lineNoCov">          0 :         noalias(vector) += local_added_vector[0] * normal_1 + local_added_vector[1] * normal_2;</span></a>
<a name="855"><span class="lineNum">     855 </span>            :         KRATOS_CATCH(&quot;&quot;)</a>
<a name="856"><span class="lineNum">     856 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="857"><span class="lineNum">     857 </span>            : </a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :     void DEM_Inlet::ThrowWarningTooSmallInlet(const ModelPart&amp; mp) {</span></a>
<a name="859"><span class="lineNum">     859 </span><span class="lineNoCov">          0 :         if(!mWarningTooSmallInlet) {</span></a>
<a name="860"><span class="lineNum">     860 </span>            : </a>
<a name="861"><span class="lineNum">     861 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="862"><span class="lineNum">     862 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;&quot;WARNING: At Inlet, the number of injected DEM particles has been reduced to match the available number of nodes for injecting, which was too small. Increase the size of inlet called '&quot;&lt;&lt;mp.Name()&lt;&lt;&quot;'.&quot;&lt;&lt;std::endl;</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl&lt;&lt;std::flush;</span></a>
<a name="866"><span class="lineNum">     866 </span>            : </a>
<a name="867"><span class="lineNum">     867 </span><span class="lineNoCov">          0 :             mWarningTooSmallInlet = true;</span></a>
<a name="868"><span class="lineNum">     868 </span>            :         }</a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="870"><span class="lineNum">     870 </span>            : </a>
<a name="871"><span class="lineNum">     871 </span><span class="lineNoCov">          0 :     void DEM_Inlet::ThrowWarningTooSmallInletForMassFlow(const ModelPart&amp; mp) {</span></a>
<a name="872"><span class="lineNum">     872 </span><span class="lineNoCov">          0 :         if(!mWarningTooSmallInletForMassFlow) {</span></a>
<a name="873"><span class="lineNum">     873 </span>            : </a>
<a name="874"><span class="lineNum">     874 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="875"><span class="lineNum">     875 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="876"><span class="lineNum">     876 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;&quot;WARNING: At Inlet, the mass flow can not be fulfilled because the number of nodes for injecting was too small. Increase the size of inlet called '&quot;&lt;&lt;mp.Name()&lt;&lt;&quot;'.&quot;&lt;&lt;std::endl;</span></a>
<a name="877"><span class="lineNum">     877 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl;</span></a>
<a name="878"><span class="lineNum">     878 </span><span class="lineNoCov">          0 :             KRATOS_WARNING(&quot;DEM&quot;) &lt;&lt;std::endl&lt;&lt;std::flush;</span></a>
<a name="879"><span class="lineNum">     879 </span>            : </a>
<a name="880"><span class="lineNum">     880 </span><span class="lineNoCov">          0 :             mWarningTooSmallInletForMassFlow = true;</span></a>
<a name="881"><span class="lineNum">     881 </span>            :         }</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="883"><span class="lineNum">     883 </span>            : </a>
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 :     ModelPart&amp; DEM_Inlet::GetInletModelPart()</span></a>
<a name="885"><span class="lineNum">     885 </span>            :     {</a>
<a name="886"><span class="lineNum">     886 </span><span class="lineNoCov">          0 :         return mInletModelPart;</span></a>
<a name="887"><span class="lineNum">     887 </span>            :     }</a>
<a name="888"><span class="lineNum">     888 </span>            : </a>
<a name="889"><span class="lineNum">     889 </span><span class="lineNoCov">          0 :     void DEM_Inlet::SetNormalizedMaxIndentationForRelease(const double value)</span></a>
<a name="890"><span class="lineNum">     890 </span>            :     {</a>
<a name="891"><span class="lineNum">     891 </span><span class="lineNoCov">          0 :         mNormalizedMaxIndentationForRelease = value;</span></a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<a name="894"><span class="lineNum">     894 </span><span class="lineNoCov">          0 :     void DEM_Inlet::SetNormalizedMaxIndentationForNewParticleCreation(const double value)</span></a>
<a name="895"><span class="lineNum">     895 </span>            :     {</a>
<a name="896"><span class="lineNum">     896 </span><span class="lineNoCov">          0 :         mNormalizedMaxIndentationForNewParticleCreation = value;</span></a>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="898"><span class="lineNum">     898 </span>            : </a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :     int DEM_Inlet::GetPartialNumberOfParticlesInjectedSoFar(const int i)</span></a>
<a name="900"><span class="lineNum">     900 </span>            :     {</a>
<a name="901"><span class="lineNum">     901 </span><span class="lineNoCov">          0 :         return mNumberOfParticlesInjected[i];</span></a>
<a name="902"><span class="lineNum">     902 </span>            :     }</a>
<a name="903"><span class="lineNum">     903 </span>            : </a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :     int DEM_Inlet::GetTotalNumberOfParticlesInjectedSoFar()</span></a>
<a name="905"><span class="lineNum">     905 </span>            :     {</a>
<a name="906"><span class="lineNum">     906 </span><span class="lineNoCov">          0 :         return mTotalNumberOfParticlesInjected;</span></a>
<a name="907"><span class="lineNum">     907 </span>            :     }</a>
<a name="908"><span class="lineNum">     908 </span>            : </a>
<a name="909"><span class="lineNum">     909 </span><span class="lineNoCov">          0 :     double DEM_Inlet::GetPartialMassInjectedSoFar(const int i)</span></a>
<a name="910"><span class="lineNum">     910 </span>            :     {</a>
<a name="911"><span class="lineNum">     911 </span><span class="lineNoCov">          0 :         return mMassInjected[i];</span></a>
<a name="912"><span class="lineNum">     912 </span>            :     }</a>
<a name="913"><span class="lineNum">     913 </span>            : </a>
<a name="914"><span class="lineNum">     914 </span><span class="lineNoCov">          0 :     double DEM_Inlet::GetTotalMassInjectedSoFar()</span></a>
<a name="915"><span class="lineNum">     915 </span>            :     {</a>
<a name="916"><span class="lineNum">     916 </span><span class="lineNoCov">          0 :         return mTotalMassInjected;</span></a>
<a name="917"><span class="lineNum">     917 </span>            :     }</a>
<a name="918"><span class="lineNum">     918 </span>            : </a>
<a name="919"><span class="lineNum">     919 </span><span class="lineNoCov">          0 :     void DEM_Inlet::UpdateTotalThroughput(SphericParticle&amp; r_spheric_particle)</span></a>
<a name="920"><span class="lineNum">     920 </span>            :     {</a>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :         ++mTotalNumberOfParticlesInjected;</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 :         mTotalMassInjected += r_spheric_particle.GetMass();</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="924"><span class="lineNum">     924 </span>            : </a>
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 :     void DEM_Inlet::UpdateTotalThroughput(Cluster3D&amp; r_cluster)</span></a>
<a name="926"><span class="lineNum">     926 </span>            :     {</a>
<a name="927"><span class="lineNum">     927 </span><span class="lineNoCov">          0 :         ++mTotalNumberOfParticlesInjected;</span></a>
<a name="928"><span class="lineNum">     928 </span><span class="lineNoCov">          0 :         mTotalMassInjected += r_cluster.GetMass();</span></a>
<a name="929"><span class="lineNum">     929 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="930"><span class="lineNum">     930 </span>            : </a>
<a name="931"><span class="lineNum">     931 </span><span class="lineNoCov">          0 :     void DEM_Inlet::UpdatePartialThroughput(SphericParticle&amp; r_spheric_particle, const int i)</span></a>
<a name="932"><span class="lineNum">     932 </span>            :     {</a>
<a name="933"><span class="lineNum">     933 </span><span class="lineNoCov">          0 :         ++mNumberOfParticlesInjected[i];</span></a>
<a name="934"><span class="lineNum">     934 </span>            : </a>
<a name="935"><span class="lineNum">     935 </span><span class="lineNoCov">          0 :         mMassInjected[i] += r_spheric_particle.GetMass();</span></a>
<a name="936"><span class="lineNum">     936 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="937"><span class="lineNum">     937 </span>            : </a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 :     void DEM_Inlet::UpdatePartialThroughput(Cluster3D&amp; r_cluster, const int i)</span></a>
<a name="939"><span class="lineNum">     939 </span>            :     {</a>
<a name="940"><span class="lineNum">     940 </span><span class="lineNoCov">          0 :         ++mNumberOfParticlesInjected[i];</span></a>
<a name="941"><span class="lineNum">     941 </span>            : </a>
<a name="942"><span class="lineNum">     942 </span><span class="lineNoCov">          0 :         mMassInjected[i] += r_cluster.GetMass();</span></a>
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="944"><span class="lineNum">     944 </span>            : </a>
<a name="945"><span class="lineNum">     945 </span><span class="lineNoCov">          0 :     double DEM_Inlet::GetInputNumberOfParticles(const ModelPart&amp; mp)</span></a>
<a name="946"><span class="lineNum">     946 </span>            :     {</a>
<a name="947"><span class="lineNum">     947 </span><span class="lineNoCov">          0 :         double num_part_surface_time = mp[INLET_NUMBER_OF_PARTICLES];</span></a>
<a name="948"><span class="lineNum">     948 </span>            : </a>
<a name="949"><span class="lineNum">     949 </span><span class="lineNoCov">          0 :         if (num_part_surface_time &gt;= 0){</span></a>
<a name="950"><span class="lineNum">     950 </span><span class="lineNoCov">          0 :            return num_part_surface_time;</span></a>
<a name="951"><span class="lineNum">     951 </span>            :         }</a>
<a name="952"><span class="lineNum">     952 </span>            : </a>
<a name="953"><span class="lineNum">     953 </span>            :         else {</a>
<a name="954"><span class="lineNum">     954 </span><span class="lineNoCov">          0 :             KRATOS_ERROR &lt;&lt; &quot;The value of the Model Part variable INLET_NUMBER_OF_PARTICLES is not a positive int: &quot; &lt;&lt; num_part_surface_time;</span></a>
<a name="955"><span class="lineNum">     955 </span>            :         }</a>
<a name="956"><span class="lineNum">     956 </span>            :     }</a>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            : } // namespace Kratos</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
