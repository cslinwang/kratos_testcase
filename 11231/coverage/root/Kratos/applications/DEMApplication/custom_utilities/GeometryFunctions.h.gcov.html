<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /root/Kratos/applications/DEMApplication/custom_utilities/GeometryFunctions.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">root/Kratos/applications/DEMApplication/custom_utilities</a> - GeometryFunctions.h<span style="font-size: 80%;"> (source / <a href="GeometryFunctions.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">175</td>
            <td class="headerCovTableEntry">418</td>
            <td class="headerCovTableEntryLo">41.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-08-17 13:51:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryLo">43.3 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<a name="2"><span class="lineNum">       2 </span>            :  * File:   GeometryFunctions.h</a>
<a name="3"><span class="lineNum">       3 </span>            :  * Author: msantasusana, Chun Feng</a>
<a name="4"><span class="lineNum">       4 </span>            :  *</a>
<a name="5"><span class="lineNum">       5 </span>            :  * Created on 21 de mayo de 2012, 19:40</a>
<a name="6"><span class="lineNum">       6 </span>            :  */</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : #ifndef _GEOMETRYFUNCTIONS_H</a>
<a name="9"><span class="lineNum">       9 </span>            : #define _GEOMETRYFUNCTIONS_H</a>
<a name="10"><span class="lineNum">      10 </span>            : </a>
<a name="11"><span class="lineNum">      11 </span>            : #include &lt;cmath&gt;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &quot;utilities/openmp_utils.h&quot;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &quot;utilities/quaternion.h&quot;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &quot;includes/model_part.h&quot;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &quot;DEM_application_variables.h&quot;</a>
<a name="16"><span class="lineNum">      16 </span>            : </a>
<a name="17"><span class="lineNum">      17 </span>            : namespace Kratos {</a>
<a name="18"><span class="lineNum">      18 </span>            : </a>
<a name="19"><span class="lineNum">      19 </span>            :     namespace GeometryFunctions {</a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            :     typedef Geometry&lt;Node &gt; GeometryType;</a>
<a name="22"><span class="lineNum">      22 </span>            : </a>
<a name="23"><span class="lineNum">      23 </span><span class="lineCov">       1996 :     static inline void RotateAVectorAGivenAngleAroundAUnitaryVector(const array_1d&lt;double, 3&gt;&amp; old_vec, const array_1d&lt;double, 3&gt;&amp; axis,</span></a>
<a name="24"><span class="lineNum">      24 </span>            :                                                                     const double ang, array_1d&lt;double, 3&gt;&amp; new_vec) {</a>
<a name="25"><span class="lineNum">      25 </span><span class="lineCov">       1996 :         double cang = std::cos(ang);</span></a>
<a name="26"><span class="lineNum">      26 </span><span class="lineCov">       1996 :         double sang = std::sin(ang);</span></a>
<a name="27"><span class="lineNum">      27 </span>            : </a>
<a name="28"><span class="lineNum">      28 </span><span class="lineCov">       1996 :         new_vec[0] = axis[0] * (axis[0] * old_vec[0] + axis[1] * old_vec[1] + axis[2] * old_vec[2]) * (1 - cang) + old_vec[0] * cang + (-axis[2] * old_vec[1] + axis[1] * old_vec[2]) * sang;</span></a>
<a name="29"><span class="lineNum">      29 </span><span class="lineCov">       1996 :         new_vec[1] = axis[1] * (axis[0] * old_vec[0] + axis[1] * old_vec[1] + axis[2] * old_vec[2]) * (1 - cang) + old_vec[1] * cang + ( axis[2] * old_vec[0] - axis[0] * old_vec[2]) * sang;</span></a>
<a name="30"><span class="lineNum">      30 </span><span class="lineCov">       1996 :         new_vec[2] = axis[2] * (axis[0] * old_vec[0] + axis[1] * old_vec[1] + axis[2] * old_vec[2]) * (1 - cang) + old_vec[2] * cang + (-axis[1] * old_vec[0] + axis[0] * old_vec[1]) * sang;</span></a>
<a name="31"><span class="lineNum">      31 </span><span class="lineCov">       1996 :     }</span></a>
<a name="32"><span class="lineNum">      32 </span>            : </a>
<a name="33"><span class="lineNum">      33 </span><span class="lineNoCov">          0 :     static inline void TranslateGridOfNodes(const double time, const double velocity_start_time, const double velocity_stop_time, array_1d&lt;double, 3&gt;&amp; center_position,</span></a>
<a name="34"><span class="lineNum">      34 </span>            :                                             const array_1d&lt;double, 3&gt;&amp; initial_center, array_1d&lt;double, 3&gt;&amp; previous_displ, array_1d&lt;double, 3&gt;&amp; linear_velocity_changed,</a>
<a name="35"><span class="lineNum">      35 </span>            :                                             const double linear_period, const double dt, const array_1d&lt;double, 3&gt;&amp; linear_velocity) {</a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span><span class="lineNoCov">          0 :         if (time &lt; velocity_start_time || time &gt; velocity_stop_time) {</span></a>
<a name="38"><span class="lineNum">      38 </span><span class="lineNoCov">          0 :             center_position[0] = initial_center[0] + previous_displ[0];</span></a>
<a name="39"><span class="lineNum">      39 </span><span class="lineNoCov">          0 :             center_position[1] = initial_center[1] + previous_displ[1];</span></a>
<a name="40"><span class="lineNum">      40 </span><span class="lineNoCov">          0 :             center_position[2] = initial_center[2] + previous_displ[2];</span></a>
<a name="41"><span class="lineNum">      41 </span><span class="lineNoCov">          0 :             linear_velocity_changed = ZeroVector(3);</span></a>
<a name="42"><span class="lineNum">      42 </span>            :         } else {</a>
<a name="43"><span class="lineNum">      43 </span><span class="lineNoCov">          0 :             if (linear_period &gt; 0.0) {</span></a>
<a name="44"><span class="lineNum">      44 </span><span class="lineNoCov">          0 :                 double linear_omega = 2.0 * Globals::Pi / linear_period;</span></a>
<a name="45"><span class="lineNum">      45 </span><span class="lineNoCov">          0 :                 double inv_linear_omega = 1.0 / linear_omega;</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineNoCov">          0 :                 noalias(center_position) = initial_center + linear_velocity * std::sin(linear_omega * (time - velocity_start_time)) * inv_linear_omega;</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineNoCov">          0 :                 noalias(linear_velocity_changed) = linear_velocity * std::cos(linear_omega * (time - velocity_start_time));</span></a>
<a name="48"><span class="lineNum">      48 </span>            :                 noalias(previous_displ) = center_position - initial_center;</a>
<a name="49"><span class="lineNum">      49 </span>            :             } else {</a>
<a name="50"><span class="lineNum">      50 </span><span class="lineNoCov">          0 :                 center_position[0] = initial_center[0] + previous_displ[0] + dt * linear_velocity[0];</span></a>
<a name="51"><span class="lineNum">      51 </span><span class="lineNoCov">          0 :                 center_position[1] = initial_center[1] + previous_displ[1] + dt * linear_velocity[1];</span></a>
<a name="52"><span class="lineNum">      52 </span><span class="lineNoCov">          0 :                 center_position[2] = initial_center[2] + previous_displ[2] + dt * linear_velocity[2];</span></a>
<a name="53"><span class="lineNum">      53 </span><span class="lineNoCov">          0 :                 previous_displ[0] += dt * linear_velocity[0];</span></a>
<a name="54"><span class="lineNum">      54 </span><span class="lineNoCov">          0 :                 previous_displ[1] += dt * linear_velocity[1];</span></a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :                 previous_displ[2] += dt * linear_velocity[2];</span></a>
<a name="56"><span class="lineNum">      56 </span>            :                 linear_velocity_changed = linear_velocity;</a>
<a name="57"><span class="lineNum">      57 </span>            :             }</a>
<a name="58"><span class="lineNum">      58 </span>            :         }</a>
<a name="59"><span class="lineNum">      59 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="60"><span class="lineNum">      60 </span>            : </a>
<a name="61"><span class="lineNum">      61 </span>            :     static inline int sign(const double a)</a>
<a name="62"><span class="lineNum">      62 </span>            :     {</a>
<a name="63"><span class="lineNum">      63 </span><span class="lineNoCov">          0 :         return (0.0 &lt; a) - (a &lt; 0.0);</span></a>
<a name="64"><span class="lineNum">      64 </span>            :         /*int output;</a>
<a name="65"><span class="lineNum">      65 </span>            :         if (a &lt; 0.0) output = -1;</a>
<a name="66"><span class="lineNum">      66 </span>            :         else if (a &gt; 0.0) output = 1;</a>
<a name="67"><span class="lineNum">      67 </span>            :         else output = 0;</a>
<a name="68"><span class="lineNum">      68 </span>            :         return output;*/</a>
<a name="69"><span class="lineNum">      69 </span>            :     }</a>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<a name="71"><span class="lineNum">      71 </span>            :     static inline double min(double a, double b)</a>
<a name="72"><span class="lineNum">      72 </span>            :     {</a>
<a name="73"><span class="lineNum">      73 </span>            :         double output;</a>
<a name="74"><span class="lineNum">      74 </span>            :         if (a&lt;=b) output = a;</a>
<a name="75"><span class="lineNum">      75 </span>            :         else output = b;</a>
<a name="76"><span class="lineNum">      76 </span>            :         return output;</a>
<a name="77"><span class="lineNum">      77 </span>            :     }</a>
<a name="78"><span class="lineNum">      78 </span>            : </a>
<a name="79"><span class="lineNum">      79 </span>            :     static inline double max(double a, double b)</a>
<a name="80"><span class="lineNum">      80 </span>            :     {</a>
<a name="81"><span class="lineNum">      81 </span>            :         double output;</a>
<a name="82"><span class="lineNum">      82 </span><span class="lineNoCov">          0 :         if (a&gt;=b) output = a;</span></a>
<a name="83"><span class="lineNum">      83 </span>            :         else output = b;</a>
<a name="84"><span class="lineNum">      84 </span>            :         return output;</a>
<a name="85"><span class="lineNum">      85 </span>            :     }</a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span><span class="lineCov">       1830 :     static inline void normalize(double Vector[3])</span></a>
<a name="88"><span class="lineNum">      88 </span>            :     {</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">       1830 :             double distance = DEM_INNER_PRODUCT_3(Vector, Vector);</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineCov">       1830 :             double inv_distance = (distance &gt; 0.0) ?  1.0 / sqrt(distance) : 0.00;</span></a>
<a name="91"><span class="lineNum">      91 </span>            : </a>
<a name="92"><span class="lineNum">      92 </span><span class="lineCov">       1830 :             Vector[0] = Vector[0] * inv_distance;</span></a>
<a name="93"><span class="lineNum">      93 </span><span class="lineCov">       1830 :             Vector[1] = Vector[1] * inv_distance;</span></a>
<a name="94"><span class="lineNum">      94 </span><span class="lineCov">       1830 :             Vector[2] = Vector[2] * inv_distance;</span></a>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">       1830 :     }</span></a>
<a name="96"><span class="lineNum">      96 </span>            : </a>
<a name="97"><span class="lineNum">      97 </span>            :     static inline void normalize(array_1d&lt;double,3&gt;&amp; Vector, double&amp; distance)</a>
<a name="98"><span class="lineNum">      98 </span>            :     {</a>
<a name="99"><span class="lineNum">      99 </span>            :             distance = DEM_MODULUS_3(Vector);</a>
<a name="100"><span class="lineNum">     100 </span>            :             double inv_distance = (distance != 0.0) ?  1.0 / distance : 0.00;</a>
<a name="101"><span class="lineNum">     101 </span>            : </a>
<a name="102"><span class="lineNum">     102 </span>            :             Vector[0] = Vector[0] * inv_distance;</a>
<a name="103"><span class="lineNum">     103 </span>            :             Vector[1] = Vector[1] * inv_distance;</a>
<a name="104"><span class="lineNum">     104 </span>            :             Vector[2] = Vector[2] * inv_distance;</a>
<a name="105"><span class="lineNum">     105 </span>            :     }</a>
<a name="106"><span class="lineNum">     106 </span>            : </a>
<a name="107"><span class="lineNum">     107 </span><span class="lineNoCov">          0 :     static inline void normalize(double Vector[3], double&amp; distance)</span></a>
<a name="108"><span class="lineNum">     108 </span>            :     {</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineNoCov">          0 :             distance = DEM_MODULUS_3(Vector);</span></a>
<a name="110"><span class="lineNum">     110 </span><span class="lineNoCov">          0 :             double inv_distance = (distance != 0.0) ?  1.0 / distance : 0.00;</span></a>
<a name="111"><span class="lineNum">     111 </span>            : </a>
<a name="112"><span class="lineNum">     112 </span><span class="lineNoCov">          0 :             Vector[0] = Vector[0] * inv_distance;</span></a>
<a name="113"><span class="lineNum">     113 </span><span class="lineNoCov">          0 :             Vector[1] = Vector[1] * inv_distance;</span></a>
<a name="114"><span class="lineNum">     114 </span><span class="lineNoCov">          0 :             Vector[2] = Vector[2] * inv_distance;</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span><span class="lineCov">       5612 :     static inline void normalize(array_1d&lt;double,3&gt;&amp; Vector)</span></a>
<a name="118"><span class="lineNum">     118 </span>            :     {</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">       5612 :             double distance = DEM_MODULUS_3(Vector);</span></a>
<a name="120"><span class="lineNum">     120 </span><span class="lineCov">       5612 :             double inv_distance = (distance != 0.0) ?  1.0 / distance : 0.00;</span></a>
<a name="121"><span class="lineNum">     121 </span>            : </a>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">       5612 :             Vector[0] = Vector[0] * inv_distance;</span></a>
<a name="123"><span class="lineNum">     123 </span><span class="lineCov">       5612 :             Vector[1] = Vector[1] * inv_distance;</span></a>
<a name="124"><span class="lineNum">     124 </span><span class="lineCov">       5612 :             Vector[2] = Vector[2] * inv_distance;</span></a>
<a name="125"><span class="lineNum">     125 </span><span class="lineCov">       5612 :     }</span></a>
<a name="126"><span class="lineNum">     126 </span>            : </a>
<a name="127"><span class="lineNum">     127 </span>            :     static inline void module(const array_1d&lt;double,3&gt;&amp; Vector, double&amp; distance)</a>
<a name="128"><span class="lineNum">     128 </span>            :     {</a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :             distance = DEM_MODULUS_3(Vector);</span></a>
<a name="130"><span class="lineNum">     130 </span>            :     }</a>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<a name="132"><span class="lineNum">     132 </span>            :     static inline double module(const double Vector[3])</a>
<a name="133"><span class="lineNum">     133 </span>            :     {</a>
<a name="134"><span class="lineNum">     134 </span>            :             return DEM_MODULUS_3(Vector);</a>
<a name="135"><span class="lineNum">     135 </span>            :     }</a>
<a name="136"><span class="lineNum">     136 </span>            : </a>
<a name="137"><span class="lineNum">     137 </span>            :     static inline void module(const double Vector[3], double&amp; distance)</a>
<a name="138"><span class="lineNum">     138 </span>            :     {</a>
<a name="139"><span class="lineNum">     139 </span>            :             distance = DEM_MODULUS_3(Vector);</a>
<a name="140"><span class="lineNum">     140 </span>            :     }</a>
<a name="141"><span class="lineNum">     141 </span>            : </a>
<a name="142"><span class="lineNum">     142 </span>            :     static inline double module(const array_1d&lt;double,3&gt;&amp; Vector)</a>
<a name="143"><span class="lineNum">     143 </span>            :     {</a>
<a name="144"><span class="lineNum">     144 </span><span class="lineCov">       5996 :             double distance = DEM_MODULUS_3(Vector);</span></a>
<a name="145"><span class="lineNum">     145 </span>            :             return distance;</a>
<a name="146"><span class="lineNum">     146 </span>            :     }</a>
<a name="147"><span class="lineNum">     147 </span>            : </a>
<a name="148"><span class="lineNum">     148 </span><span class="lineCov">       5800 :     static inline void VectorGlobal2Local(const double LocalCoordSystem[3][3], const double GlobalVector[3], double LocalVector[3])</span></a>
<a name="149"><span class="lineNum">     149 </span>            :     {</a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">      23200 :         for (int i=0; i&lt;3; i++) {</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">      17400 :             LocalVector[i] = 0.0;</span></a>
<a name="152"><span class="lineNum">     152 </span><span class="lineCov">      69600 :             for (int j=0; j&lt;3; j++) {</span></a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">      52200 :                 LocalVector[i]+=LocalCoordSystem[i][j]*GlobalVector[j];</span></a>
<a name="154"><span class="lineNum">     154 </span>            :             }</a>
<a name="155"><span class="lineNum">     155 </span>            :         }</a>
<a name="156"><span class="lineNum">     156 </span><span class="lineCov">       5800 :     }</span></a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span>            :     static inline void VectorGlobal2Local(const double LocalCoordSystem[3][3], const array_1d&lt;double, 3&gt;&amp; GlobalVector, array_1d&lt;double, 3&gt;&amp; LocalVector)</a>
<a name="159"><span class="lineNum">     159 </span>            :     {</a>
<a name="160"><span class="lineNum">     160 </span>            :         for (int i=0; i&lt;3; i++) {</a>
<a name="161"><span class="lineNum">     161 </span>            :             LocalVector[i] = 0.0;</a>
<a name="162"><span class="lineNum">     162 </span>            :             for (int j=0; j&lt;3; j++) {</a>
<a name="163"><span class="lineNum">     163 </span>            :                 LocalVector[i]+=LocalCoordSystem[i][j]*GlobalVector[j];</a>
<a name="164"><span class="lineNum">     164 </span>            :             }</a>
<a name="165"><span class="lineNum">     165 </span>            :         }</a>
<a name="166"><span class="lineNum">     166 </span>            :     }</a>
<a name="167"><span class="lineNum">     167 </span>            : </a>
<a name="168"><span class="lineNum">     168 </span><span class="lineCov">       2900 :     static inline void VectorGlobal2Local(const double LocalCoordSystem[3][3], const array_1d&lt;double, 3&gt;&amp; GlobalVector, double LocalVector[3])</span></a>
<a name="169"><span class="lineNum">     169 </span>            :     {</a>
<a name="170"><span class="lineNum">     170 </span><span class="lineCov">      11600 :         for (int i=0; i&lt;3; i++) {</span></a>
<a name="171"><span class="lineNum">     171 </span><span class="lineCov">       8700 :             LocalVector[i] = 0.0;</span></a>
<a name="172"><span class="lineNum">     172 </span><span class="lineCov">      34800 :             for (int j=0; j&lt;3; j++) {</span></a>
<a name="173"><span class="lineNum">     173 </span><span class="lineCov">      26100 :                 LocalVector[i]+=LocalCoordSystem[i][j]*GlobalVector[j];</span></a>
<a name="174"><span class="lineNum">     174 </span>            :             }</a>
<a name="175"><span class="lineNum">     175 </span>            :         }</a>
<a name="176"><span class="lineNum">     176 </span><span class="lineCov">       2900 :     }</span></a>
<a name="177"><span class="lineNum">     177 </span>            : </a>
<a name="178"><span class="lineNum">     178 </span><span class="lineCov">       7796 :     static inline void VectorLocal2Global(const double LocalCoordSystem[3][3], const double LocalVector[3], double GlobalVector[3])</span></a>
<a name="179"><span class="lineNum">     179 </span>            :     {</a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">      31184 :         for (int i=0; i&lt;3; i++) {</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">      23388 :             GlobalVector[i] = 0.0;</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineCov">      93552 :             for (int j=0; j&lt;3; j++) {</span></a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">      70164 :                 GlobalVector[i]+=LocalCoordSystem[j][i]*LocalVector[j];</span></a>
<a name="184"><span class="lineNum">     184 </span>            :             }</a>
<a name="185"><span class="lineNum">     185 </span>            :         }</a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">       7796 :     }</span></a>
<a name="187"><span class="lineNum">     187 </span>            : </a>
<a name="188"><span class="lineNum">     188 </span>            :     static inline void VectorLocal2Global(const double LocalCoordSystem[3][3], const array_1d&lt;double, 3&gt;&amp; LocalVector, array_1d&lt;double, 3&gt;&amp; GlobalVector)</a>
<a name="189"><span class="lineNum">     189 </span>            :     {</a>
<a name="190"><span class="lineNum">     190 </span>            :         for (int i=0; i&lt;3; i++) {</a>
<a name="191"><span class="lineNum">     191 </span>            :             GlobalVector[i] = 0.0;</a>
<a name="192"><span class="lineNum">     192 </span>            :             for (int j=0; j&lt;3; j++) {</a>
<a name="193"><span class="lineNum">     193 </span>            :                 GlobalVector[i]+=LocalCoordSystem[j][i]*LocalVector[j];</a>
<a name="194"><span class="lineNum">     194 </span>            :             }</a>
<a name="195"><span class="lineNum">     195 </span>            :         }</a>
<a name="196"><span class="lineNum">     196 </span>            :     }</a>
<a name="197"><span class="lineNum">     197 </span>            : </a>
<a name="198"><span class="lineNum">     198 </span>            :     static inline void VectorLocal2Global(const double LocalCoordSystem[3][3], const array_1d&lt;double, 3&gt;&amp; LocalVector, double GlobalVector[3])</a>
<a name="199"><span class="lineNum">     199 </span>            :     {</a>
<a name="200"><span class="lineNum">     200 </span>            :         for (int i=0; i&lt;3; i++) {</a>
<a name="201"><span class="lineNum">     201 </span>            :             GlobalVector[i] = 0.0;</a>
<a name="202"><span class="lineNum">     202 </span>            :             for (int j=0; j&lt;3; j++) {</a>
<a name="203"><span class="lineNum">     203 </span>            :                 GlobalVector[i]+=LocalCoordSystem[j][i]*LocalVector[j];</a>
<a name="204"><span class="lineNum">     204 </span>            :             }</a>
<a name="205"><span class="lineNum">     205 </span>            :         }</a>
<a name="206"><span class="lineNum">     206 </span>            :     }</a>
<a name="207"><span class="lineNum">     207 </span>            : </a>
<a name="208"><span class="lineNum">     208 </span>            :     static inline void VectorLocal2Global(const double LocalCoordSystem[3][3], const double LocalVector[3], array_1d&lt;double, 3&gt;&amp; GlobalVector)</a>
<a name="209"><span class="lineNum">     209 </span>            :     {</a>
<a name="210"><span class="lineNum">     210 </span>            :         for (int i=0; i&lt;3; i++) {</a>
<a name="211"><span class="lineNum">     211 </span>            :             GlobalVector[i] = 0.0;</a>
<a name="212"><span class="lineNum">     212 </span>            :             for (int j=0; j&lt;3; j++) {</a>
<a name="213"><span class="lineNum">     213 </span>            :                 GlobalVector[i]+=LocalCoordSystem[j][i]*LocalVector[j];</a>
<a name="214"><span class="lineNum">     214 </span>            :             }</a>
<a name="215"><span class="lineNum">     215 </span>            :         }</a>
<a name="216"><span class="lineNum">     216 </span>            :     }</a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span><span class="lineNoCov">          0 :     static inline void ProductMatrices3X3(const double Matrix1[3][3], const double Matrix2[3][3], double Matrix3[3][3])</span></a>
<a name="219"><span class="lineNum">     219 </span>            :     {</a>
<a name="220"><span class="lineNum">     220 </span><span class="lineNoCov">          0 :         for (int i = 0; i &lt; 3; i++) {</span></a>
<a name="221"><span class="lineNum">     221 </span><span class="lineNoCov">          0 :             for (int j = 0; j &lt; 3; j++) {</span></a>
<a name="222"><span class="lineNum">     222 </span><span class="lineNoCov">          0 :                 Matrix3[i][j] = 0.0;</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineNoCov">          0 :                 for (int k = 0; k &lt; 3; k++) {</span></a>
<a name="224"><span class="lineNum">     224 </span><span class="lineNoCov">          0 :                     Matrix3[i][j] += Matrix1[i][k] * Matrix2[k][j];</span></a>
<a name="225"><span class="lineNum">     225 </span>            :                 }</a>
<a name="226"><span class="lineNum">     226 </span>            :             }</a>
<a name="227"><span class="lineNum">     227 </span>            :         }</a>
<a name="228"><span class="lineNum">     228 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<a name="230"><span class="lineNum">     230 </span>            :     static inline void ProductMatrix3X3Vector3X1(const double Matrix[3][3], const array_1d&lt;double,3&gt;&amp; Vector1, array_1d&lt;double,3&gt;&amp; Vector2)</a>
<a name="231"><span class="lineNum">     231 </span>            :     {</a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">          8 :         for (int i=0; i&lt;3; i++) {</span></a>
<a name="233"><span class="lineNum">     233 </span><span class="lineCov">          6 :             Vector2[i] = 0.0;</span></a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">         24 :             for (int j=0; j&lt;3; j++) {</span></a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">         18 :                 Vector2[i]+=Matrix[j][i]*Vector1[j];</span></a>
<a name="236"><span class="lineNum">     236 </span>            :             }</a>
<a name="237"><span class="lineNum">     237 </span>            :         }</a>
<a name="238"><span class="lineNum">     238 </span>            :     }</a>
<a name="239"><span class="lineNum">     239 </span>            : </a>
<a name="240"><span class="lineNum">     240 </span><span class="lineNoCov">          0 :     static inline void TensorGlobal2Local(const double LocalCoordSystem[3][3], const double GlobalTensor[3][3], double LocalTensor[3][3])</span></a>
<a name="241"><span class="lineNum">     241 </span>            :     {</a>
<a name="242"><span class="lineNum">     242 </span>            :         // We will compute LocalTensor = LocalCoordSystem * GlobalTensor * transposed(LocalCoordSystem)</a>
<a name="243"><span class="lineNum">     243 </span>            :         // starting on the left, so we will first compute the product TemporalResult = LocalCoordSystem * GlobalTensor</a>
<a name="244"><span class="lineNum">     244 </span>            :         // and afterwards TemporalResult * transposed(LocalCoordSystem), which will give the value of the tensor LocalTensor</a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            :         double TransposedLocalCoordSystem[3][3];</a>
<a name="247"><span class="lineNum">     247 </span>            :         double TemporalResult[3][3];</a>
<a name="248"><span class="lineNum">     248 </span>            : </a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :         TransposedLocalCoordSystem[0][0] = LocalCoordSystem[0][0]; TransposedLocalCoordSystem[0][1] = LocalCoordSystem[1][0]; TransposedLocalCoordSystem[0][2] = LocalCoordSystem[2][0];</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :         TransposedLocalCoordSystem[1][0] = LocalCoordSystem[0][1]; TransposedLocalCoordSystem[1][1] = LocalCoordSystem[1][1]; TransposedLocalCoordSystem[1][2] = LocalCoordSystem[2][1];</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineNoCov">          0 :         TransposedLocalCoordSystem[2][0] = LocalCoordSystem[0][2]; TransposedLocalCoordSystem[2][1] = LocalCoordSystem[1][2]; TransposedLocalCoordSystem[2][2] = LocalCoordSystem[2][2];</span></a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span><span class="lineNoCov">          0 :         ProductMatrices3X3(LocalCoordSystem, GlobalTensor, TemporalResult);</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineNoCov">          0 :         ProductMatrices3X3(TemporalResult, TransposedLocalCoordSystem, LocalTensor);</span></a>
<a name="255"><span class="lineNum">     255 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="256"><span class="lineNum">     256 </span>            : </a>
<a name="257"><span class="lineNum">     257 </span>            :     static inline void TensorLocal2Global(const double LocalCoordSystem[3][3], const double LocalTensor[3][3], double GlobalTensor[3][3])</a>
<a name="258"><span class="lineNum">     258 </span>            :     {</a>
<a name="259"><span class="lineNum">     259 </span>            :         // We will compute GlobalTensor = transposed(LocalCoordSystem) * LocalTensor * LocalCoordSystem</a>
<a name="260"><span class="lineNum">     260 </span>            :         // starting on the left, so we will first compute the product TemporalResult = transposed(LocalCoordSystem) * LocalTensor</a>
<a name="261"><span class="lineNum">     261 </span>            :         // and afterwards TemporalResult * LocalCoordSystem, which will give the value of the tensor LocalTensor</a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span>            :         double TransposedLocalCoordSystem[3][3];</a>
<a name="264"><span class="lineNum">     264 </span>            :         double TemporalResult[3][3];</a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span>            :         TransposedLocalCoordSystem[0][0] = LocalCoordSystem[0][0]; TransposedLocalCoordSystem[0][1] = LocalCoordSystem[1][0]; TransposedLocalCoordSystem[0][2] = LocalCoordSystem[2][0];</a>
<a name="267"><span class="lineNum">     267 </span>            :         TransposedLocalCoordSystem[1][0] = LocalCoordSystem[0][1]; TransposedLocalCoordSystem[1][1] = LocalCoordSystem[1][1]; TransposedLocalCoordSystem[1][2] = LocalCoordSystem[2][1];</a>
<a name="268"><span class="lineNum">     268 </span>            :         TransposedLocalCoordSystem[2][0] = LocalCoordSystem[0][2]; TransposedLocalCoordSystem[2][1] = LocalCoordSystem[1][2]; TransposedLocalCoordSystem[2][2] = LocalCoordSystem[2][2];</a>
<a name="269"><span class="lineNum">     269 </span>            : </a>
<a name="270"><span class="lineNum">     270 </span>            :         ProductMatrices3X3(TransposedLocalCoordSystem, LocalTensor, TemporalResult);</a>
<a name="271"><span class="lineNum">     271 </span>            :         ProductMatrices3X3(TemporalResult, LocalCoordSystem, GlobalTensor);</a>
<a name="272"><span class="lineNum">     272 </span>            :     }</a>
<a name="273"><span class="lineNum">     273 </span>            : </a>
<a name="274"><span class="lineNum">     274 </span>            :     static inline void RotaMatrixTensorLocal2Global(const double R[3][3], const double LocalTensor[3][3], double GlobalTensor[3][3])</a>
<a name="275"><span class="lineNum">     275 </span>            :     {</a>
<a name="276"><span class="lineNum">     276 </span>            :         double RT[3][3]; double Temp[3][3];</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            :         RT[0][0] = R[0][0]; RT[0][1] = R[1][0]; RT[0][2] = R[2][0];</a>
<a name="279"><span class="lineNum">     279 </span>            :         RT[1][0] = R[0][1]; RT[1][1] = R[1][1]; RT[1][2] = R[2][1];</a>
<a name="280"><span class="lineNum">     280 </span>            :         RT[2][0] = R[0][2]; RT[2][1] = R[1][2]; RT[2][2] = R[2][2];</a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            :         ProductMatrices3X3(R, LocalTensor, Temp);</a>
<a name="283"><span class="lineNum">     283 </span>            :         ProductMatrices3X3(Temp, RT, GlobalTensor);</a>
<a name="284"><span class="lineNum">     284 </span>            :     }</a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span>            :     static inline void ConstructLocalTensor(const double moment_of_inertia, double LocalTensor[3][3])</a>
<a name="287"><span class="lineNum">     287 </span>            :     {</a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :         LocalTensor[0][0] = moment_of_inertia; LocalTensor[0][1] = 0.0; LocalTensor[0][2] = 0.0;</span></a>
<a name="289"><span class="lineNum">     289 </span><span class="lineNoCov">          0 :         LocalTensor[1][0] = 0.0; LocalTensor[1][1] = moment_of_inertia; LocalTensor[1][2] = 0.0;</span></a>
<a name="290"><span class="lineNum">     290 </span><span class="lineNoCov">          0 :         LocalTensor[2][0] = 0.0; LocalTensor[2][1] = 0.0; LocalTensor[2][2] = moment_of_inertia;</span></a>
<a name="291"><span class="lineNum">     291 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="292"><span class="lineNum">     292 </span>            : </a>
<a name="293"><span class="lineNum">     293 </span>            :     static inline void ConstructInvLocalTensor(const double moment_of_inertia, double LocalTensorInv[3][3])</a>
<a name="294"><span class="lineNum">     294 </span>            :     {</a>
<a name="295"><span class="lineNum">     295 </span><span class="lineNoCov">          0 :         double moment_of_inertia_inv = 1/moment_of_inertia;</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineNoCov">          0 :         LocalTensorInv[0][0] = moment_of_inertia_inv; LocalTensorInv[0][1] = 0.0; LocalTensorInv[0][2] = 0.0;</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineNoCov">          0 :         LocalTensorInv[1][0] = 0.0; LocalTensorInv[1][1] = moment_of_inertia_inv; LocalTensorInv[1][2] = 0.0;</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :         LocalTensorInv[2][0] = 0.0; LocalTensorInv[2][1] = 0.0; LocalTensorInv[2][2] = moment_of_inertia_inv;</span></a>
<a name="299"><span class="lineNum">     299 </span>            :     }</a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span>            :     static inline void ConstructLocalTensor(const array_1d&lt;double, 3 &gt;&amp; moments_of_inertia, double LocalTensor[3][3])</a>
<a name="302"><span class="lineNum">     302 </span>            :     {</a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">          2 :         LocalTensor[0][0] = moments_of_inertia[0]; LocalTensor[0][1] = 0.0; LocalTensor[0][2] = 0.0;</span></a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          2 :         LocalTensor[1][0] = 0.0; LocalTensor[1][1] = moments_of_inertia[1]; LocalTensor[1][2] = 0.0;</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">          2 :         LocalTensor[2][0] = 0.0; LocalTensor[2][1] = 0.0; LocalTensor[2][2] = moments_of_inertia[2];</span></a>
<a name="306"><span class="lineNum">     306 </span>            :     }</a>
<a name="307"><span class="lineNum">     307 </span>            : </a>
<a name="308"><span class="lineNum">     308 </span>            :     static inline void ConstructInvLocalTensor(const array_1d&lt;double, 3 &gt;&amp; moments_of_inertia, double LocalTensorInv[3][3])</a>
<a name="309"><span class="lineNum">     309 </span>            :     {</a>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :         LocalTensorInv[0][0] = 1/moments_of_inertia[0]; LocalTensorInv[0][1] = 0.0; LocalTensorInv[0][2] = 0.0;</span></a>
<a name="311"><span class="lineNum">     311 </span><span class="lineNoCov">          0 :         LocalTensorInv[1][0] = 0.0; LocalTensorInv[1][1] = 1/moments_of_inertia[1]; LocalTensorInv[1][2] = 0.0;</span></a>
<a name="312"><span class="lineNum">     312 </span><span class="lineNoCov">          0 :         LocalTensorInv[2][0] = 0.0; LocalTensorInv[2][1] = 0.0; LocalTensorInv[2][2] = 1/moments_of_inertia[2];</span></a>
<a name="313"><span class="lineNum">     313 </span>            :     }</a>
<a name="314"><span class="lineNum">     314 </span>            : </a>
<a name="315"><span class="lineNum">     315 </span>            :     static inline double DotProduct(double Vector1[3], double Vector2[3])</a>
<a name="316"><span class="lineNum">     316 </span>            :     {</a>
<a name="317"><span class="lineNum">     317 </span><span class="lineNoCov">          0 :         return Vector1[0] * Vector2[0] + Vector1[1] * Vector2[1] + Vector1[2] * Vector2[2];</span></a>
<a name="318"><span class="lineNum">     318 </span>            :     }</a>
<a name="319"><span class="lineNum">     319 </span>            : </a>
<a name="320"><span class="lineNum">     320 </span>            :     static inline double DotProduct(const array_1d&lt;double,3&gt;&amp; Vector1, const array_1d&lt;double,3&gt;&amp; Vector2)</a>
<a name="321"><span class="lineNum">     321 </span>            :     {</a>
<a name="322"><span class="lineNum">     322 </span><span class="lineCov">       4904 :         return Vector1[0] * Vector2[0] + Vector1[1] * Vector2[1] + Vector1[2] * Vector2[2];</span></a>
<a name="323"><span class="lineNum">     323 </span>            :     }</a>
<a name="324"><span class="lineNum">     324 </span>            : </a>
<a name="325"><span class="lineNum">     325 </span>            :     static inline void CrossProduct(const double u[3], const double v[3], double ReturnVector[3])</a>
<a name="326"><span class="lineNum">     326 </span>            :     {</a>
<a name="327"><span class="lineNum">     327 </span><span class="lineNoCov">          0 :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</span></a>
<a name="328"><span class="lineNum">     328 </span><span class="lineNoCov">          0 :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</span></a>
<a name="329"><span class="lineNum">     329 </span><span class="lineNoCov">          0 :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</span></a>
<a name="330"><span class="lineNum">     330 </span>            :     }</a>
<a name="331"><span class="lineNum">     331 </span>            : </a>
<a name="332"><span class="lineNum">     332 </span>            :     static inline void CrossProduct(const array_1d&lt;double,3&gt;&amp; u, const array_1d&lt;double,3&gt;&amp; v, array_1d&lt;double,3&gt;&amp; ReturnVector)</a>
<a name="333"><span class="lineNum">     333 </span>            :     {</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">       1996 :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</span></a>
<a name="335"><span class="lineNum">     335 </span><span class="lineCov">       1996 :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</span></a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">       1996 :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</span></a>
<a name="337"><span class="lineNum">     337 </span>            :     }</a>
<a name="338"><span class="lineNum">     338 </span>            : </a>
<a name="339"><span class="lineNum">     339 </span>            :     static inline void CrossProduct(const double u[3], const array_1d&lt;double,3&gt;&amp; v, double ReturnVector[3])</a>
<a name="340"><span class="lineNum">     340 </span>            :     {</a>
<a name="341"><span class="lineNum">     341 </span>            :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</a>
<a name="342"><span class="lineNum">     342 </span>            :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</a>
<a name="343"><span class="lineNum">     343 </span>            :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</a>
<a name="344"><span class="lineNum">     344 </span>            :     }</a>
<a name="345"><span class="lineNum">     345 </span>            : </a>
<a name="346"><span class="lineNum">     346 </span>            :     static inline void CrossProduct(const array_1d&lt;double,3&gt;&amp; u, const double v[3], double ReturnVector[3])</a>
<a name="347"><span class="lineNum">     347 </span>            :     {</a>
<a name="348"><span class="lineNum">     348 </span>            :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</a>
<a name="349"><span class="lineNum">     349 </span>            :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</a>
<a name="350"><span class="lineNum">     350 </span>            :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</a>
<a name="351"><span class="lineNum">     351 </span>            :     }</a>
<a name="352"><span class="lineNum">     352 </span>            : </a>
<a name="353"><span class="lineNum">     353 </span>            :     static inline void CrossProduct(const array_1d&lt;double,3&gt;&amp; u, const double v[3], array_1d&lt;double,3&gt;&amp; ReturnVector)</a>
<a name="354"><span class="lineNum">     354 </span>            :     {</a>
<a name="355"><span class="lineNum">     355 </span><span class="lineNoCov">          0 :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</span></a>
<a name="356"><span class="lineNum">     356 </span><span class="lineNoCov">          0 :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</span></a>
<a name="357"><span class="lineNum">     357 </span><span class="lineNoCov">          0 :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</span></a>
<a name="358"><span class="lineNum">     358 </span>            :     }</a>
<a name="359"><span class="lineNum">     359 </span>            : </a>
<a name="360"><span class="lineNum">     360 </span>            :     static inline void CrossProduct(const array_1d&lt;double,3&gt;&amp; u, const array_1d&lt;double,3&gt;&amp; v, double ReturnVector[3])</a>
<a name="361"><span class="lineNum">     361 </span>            :     {</a>
<a name="362"><span class="lineNum">     362 </span><span class="lineCov">       1808 :         ReturnVector[0] = u[1]*v[2] - u[2]*v[1];</span></a>
<a name="363"><span class="lineNum">     363 </span><span class="lineCov">       1808 :         ReturnVector[1] = v[0]*u[2] - u[0]*v[2];</span></a>
<a name="364"><span class="lineNum">     364 </span><span class="lineCov">       1808 :         ReturnVector[2] = u[0]*v[1] - u[1]*v[0];</span></a>
<a name="365"><span class="lineNum">     365 </span>            :     }</a>
<a name="366"><span class="lineNum">     366 </span>            : </a>
<a name="367"><span class="lineNum">     367 </span><span class="lineNoCov">          0 :     static inline void RotateRightHandedBasisAroundAxis(const array_1d&lt;double, 3&gt;&amp; e1,  const array_1d&lt;double, 3&gt;&amp; e2,  const array_1d&lt;double, 3&gt;&amp; axis,</span></a>
<a name="368"><span class="lineNum">     368 </span>            :                                                         const double ang, array_1d&lt;double, 3&gt;&amp; new_axes1, array_1d&lt;double, 3&gt;&amp; new_axes2,</a>
<a name="369"><span class="lineNum">     369 </span>            :                                                         array_1d&lt;double, 3&gt;&amp; new_axes3) {</a>
<a name="370"><span class="lineNum">     370 </span>            : </a>
<a name="371"><span class="lineNum">     371 </span><span class="lineNoCov">          0 :         RotateAVectorAGivenAngleAroundAUnitaryVector(e1, axis, ang, new_axes1);</span></a>
<a name="372"><span class="lineNum">     372 </span>            : </a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :         RotateAVectorAGivenAngleAroundAUnitaryVector(e2, axis, ang, new_axes2);</span></a>
<a name="374"><span class="lineNum">     374 </span>            : </a>
<a name="375"><span class="lineNum">     375 </span>            :         CrossProduct(new_axes1, new_axes2, new_axes3);</a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="377"><span class="lineNum">     377 </span>            : </a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :     static inline void RotateGridOfNodes(const double time, const double angular_velocity_start_time, const double angular_velocity_stop_time,</span></a>
<a name="379"><span class="lineNum">     379 </span>            :                                          array_1d&lt;double, 3&gt;&amp; angular_velocity_changed, const double angular_period, const double mod_angular_velocity,</a>
<a name="380"><span class="lineNum">     380 </span>            :                                          const array_1d&lt;double, 3&gt;&amp; angular_velocity, array_1d&lt;double, 3&gt;&amp; new_axes1, array_1d&lt;double, 3&gt;&amp; new_axes2,</a>
<a name="381"><span class="lineNum">     381 </span>            :                                          array_1d&lt;double, 3&gt;&amp; new_axes3) {</a>
<a name="382"><span class="lineNum">     382 </span>            : </a>
<a name="383"><span class="lineNum">     383 </span>            :         array_1d&lt;double, 3&gt; angle;</a>
<a name="384"><span class="lineNum">     384 </span>            :         noalias(angle) = ZeroVector(3);</a>
<a name="385"><span class="lineNum">     385 </span>            :         double sign_angle = 1.0;</a>
<a name="386"><span class="lineNum">     386 </span>            :         array_1d&lt;double, 3&gt; final_angle = ZeroVector(3);</a>
<a name="387"><span class="lineNum">     387 </span>            : </a>
<a name="388"><span class="lineNum">     388 </span><span class="lineNoCov">          0 :         if (time &lt; angular_velocity_start_time) angular_velocity_changed = ZeroVector(3);</span></a>
<a name="389"><span class="lineNum">     389 </span>            : </a>
<a name="390"><span class="lineNum">     390 </span><span class="lineNoCov">          0 :         else if (((time - angular_velocity_start_time) &gt; 0.0) &amp;&amp; ((time - angular_velocity_stop_time) &lt; 0.0)) {</span></a>
<a name="391"><span class="lineNum">     391 </span>            : </a>
<a name="392"><span class="lineNum">     392 </span><span class="lineNoCov">          0 :             if (angular_period &gt; 0.0) {</span></a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :                 double angular_omega = 2.0 * Globals::Pi / angular_period;</span></a>
<a name="394"><span class="lineNum">     394 </span><span class="lineNoCov">          0 :                 double inv_angular_omega = 1.0 / angular_omega;</span></a>
<a name="395"><span class="lineNum">     395 </span><span class="lineNoCov">          0 :                 noalias(angle) = angular_velocity * std::sin(angular_omega * (time - angular_velocity_start_time)) * inv_angular_omega;</span></a>
<a name="396"><span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 sign_angle = std::sin(angular_omega * (time - angular_velocity_start_time)) / fabs(sin(angular_omega * (time - angular_velocity_start_time)));</span></a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :                 noalias(angular_velocity_changed) = angular_velocity * std::cos(angular_omega * (time - angular_velocity_start_time));</span></a>
<a name="398"><span class="lineNum">     398 </span>            :                 noalias(final_angle) = angle;</a>
<a name="399"><span class="lineNum">     399 </span>            :             } else {</a>
<a name="400"><span class="lineNum">     400 </span>            :                 noalias(angle) = angular_velocity * (time - angular_velocity_start_time);</a>
<a name="401"><span class="lineNum">     401 </span>            :                 noalias(angular_velocity_changed) = angular_velocity;</a>
<a name="402"><span class="lineNum">     402 </span>            :             }</a>
<a name="403"><span class="lineNum">     403 </span>            :         } else { //if ((time - angular_velocity_stop_time) &gt; 0.0) {</a>
<a name="404"><span class="lineNum">     404 </span>            :             noalias(angular_velocity_changed) = ZeroVector(3);</a>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<a name="406"><span class="lineNum">     406 </span><span class="lineNoCov">          0 :             if (angular_period &gt; 0.0) {</span></a>
<a name="407"><span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 double angular_omega = 2.0 * Globals::Pi / angular_period;</span></a>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 double inv_angular_omega = 1.0 / angular_omega;</span></a>
<a name="409"><span class="lineNum">     409 </span><span class="lineNoCov">          0 :                 noalias(angle) = angular_velocity * std::sin(angular_omega * (angular_velocity_stop_time - angular_velocity_start_time)) * inv_angular_omega;</span></a>
<a name="410"><span class="lineNum">     410 </span>            :             } else {</a>
<a name="411"><span class="lineNum">     411 </span><span class="lineNoCov">          0 :                 noalias(angle) = angular_velocity * (angular_velocity_stop_time - angular_velocity_start_time);</span></a>
<a name="412"><span class="lineNum">     412 </span>            :             }</a>
<a name="413"><span class="lineNum">     413 </span>            :         }</a>
<a name="414"><span class="lineNum">     414 </span>            : </a>
<a name="415"><span class="lineNum">     415 </span>            :         //mod_angular_velocity = MathUtils&lt;double&gt;::Norm3(angular_velocity);</a>
<a name="416"><span class="lineNum">     416 </span>            : </a>
<a name="417"><span class="lineNum">     417 </span><span class="lineNoCov">          0 :         new_axes1[0] = 1.0;</span></a>
<a name="418"><span class="lineNum">     418 </span><span class="lineNoCov">          0 :         new_axes1[1] = 0.0;</span></a>
<a name="419"><span class="lineNum">     419 </span><span class="lineNoCov">          0 :         new_axes1[2] = 0.0;</span></a>
<a name="420"><span class="lineNum">     420 </span>            : </a>
<a name="421"><span class="lineNum">     421 </span><span class="lineNoCov">          0 :         new_axes2[0] = 0.0;</span></a>
<a name="422"><span class="lineNum">     422 </span><span class="lineNoCov">          0 :         new_axes2[1] = 1.0;</span></a>
<a name="423"><span class="lineNum">     423 </span><span class="lineNoCov">          0 :         new_axes2[2] = 0.0;</span></a>
<a name="424"><span class="lineNum">     424 </span>            : </a>
<a name="425"><span class="lineNum">     425 </span><span class="lineNoCov">          0 :         new_axes3[0] = 0.0;</span></a>
<a name="426"><span class="lineNum">     426 </span><span class="lineNoCov">          0 :         new_axes3[1] = 0.0;</span></a>
<a name="427"><span class="lineNum">     427 </span><span class="lineNoCov">          0 :         new_axes3[2] = 1.0;</span></a>
<a name="428"><span class="lineNum">     428 </span>            : </a>
<a name="429"><span class="lineNum">     429 </span><span class="lineNoCov">          0 :         if (mod_angular_velocity &gt; 0.0) {</span></a>
<a name="430"><span class="lineNum">     430 </span>            : </a>
<a name="431"><span class="lineNum">     431 </span><span class="lineNoCov">          0 :             double ang = sign_angle * MathUtils&lt;double&gt;::Norm3(angle);</span></a>
<a name="432"><span class="lineNum">     432 </span>            :             array_1d&lt;double, 3&gt; rotation_axis;</a>
<a name="433"><span class="lineNum">     433 </span>            :             noalias(rotation_axis) = angular_velocity / mod_angular_velocity;</a>
<a name="434"><span class="lineNum">     434 </span>            :             array_1d&lt;double, 3&gt; e1;</a>
<a name="435"><span class="lineNum">     435 </span><span class="lineNoCov">          0 :             e1[0] = 1.0;</span></a>
<a name="436"><span class="lineNum">     436 </span><span class="lineNoCov">          0 :             e1[1] = 0.0;</span></a>
<a name="437"><span class="lineNum">     437 </span><span class="lineNoCov">          0 :             e1[2] = 0.0;</span></a>
<a name="438"><span class="lineNum">     438 </span>            : </a>
<a name="439"><span class="lineNum">     439 </span>            :             array_1d&lt;double, 3&gt; e2;</a>
<a name="440"><span class="lineNum">     440 </span><span class="lineNoCov">          0 :             e2[0] = 0.0;</span></a>
<a name="441"><span class="lineNum">     441 </span><span class="lineNoCov">          0 :             e2[1] = 1.0;</span></a>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 :             e2[2] = 0.0;</span></a>
<a name="443"><span class="lineNum">     443 </span>            : </a>
<a name="444"><span class="lineNum">     444 </span><span class="lineNoCov">          0 :             RotateRightHandedBasisAroundAxis(e1, e2, rotation_axis, ang, new_axes1, new_axes2, new_axes3);</span></a>
<a name="445"><span class="lineNum">     445 </span>            :         }</a>
<a name="446"><span class="lineNum">     446 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span><span class="lineNoCov">          0 :     static inline void UpdateKinematicVariablesOfAGridOfNodes(double mod_angular_velocity, const array_1d&lt;double, 3&gt;&amp; linear_velocity,</span></a>
<a name="449"><span class="lineNum">     449 </span>            :                                                               const array_1d&lt;double, 3&gt;&amp; initial_center, array_1d&lt;double, 3&gt;&amp; new_axes1, array_1d&lt;double, 3&gt;&amp; new_axes2,</a>
<a name="450"><span class="lineNum">     450 </span>            :                                                               array_1d&lt;double, 3&gt;&amp; new_axes3, array_1d&lt;double, 3&gt;&amp; angular_velocity_changed,</a>
<a name="451"><span class="lineNum">     451 </span>            :                                                               array_1d&lt;double, 3&gt;&amp; linear_velocity_changed, array_1d&lt;double, 3&gt;&amp; center_position,</a>
<a name="452"><span class="lineNum">     452 </span>            :                                                               const bool fixed_mesh, const double dt, ModelPart::NodesContainerType&amp; pNodes)</a>
<a name="453"><span class="lineNum">     453 </span>            :     {</a>
<a name="454"><span class="lineNum">     454 </span><span class="lineNoCov">          0 :         if (mod_angular_velocity &gt; std::numeric_limits&lt;double&gt;::epsilon() || MathUtils&lt;double&gt;::Norm3(linear_velocity) &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</span></a>
<a name="455"><span class="lineNum">     455 </span>            : </a>
<a name="456"><span class="lineNum">     456 </span><span class="lineNoCov">          0 :             #pragma omp parallel for</span></a>
<a name="457"><span class="lineNum">     457 </span>            :             for (int k = 0; k &lt; (int)pNodes.size(); k++) {</a>
<a name="458"><span class="lineNum">     458 </span>            : </a>
<a name="459"><span class="lineNum">     459 </span>            :                 array_1d&lt;double, 3&gt; local_coordinates = ZeroVector(3);</a>
<a name="460"><span class="lineNum">     460 </span>            :                 array_1d&lt;double, 3&gt; relative_position = ZeroVector(3);</a>
<a name="461"><span class="lineNum">     461 </span>            : </a>
<a name="462"><span class="lineNum">     462 </span>            :                 ModelPart::NodeIterator node = pNodes.begin() + k;</a>
<a name="463"><span class="lineNum">     463 </span>            : </a>
<a name="464"><span class="lineNum">     464 </span>            :                 noalias(local_coordinates) = node-&gt;GetInitialPosition().Coordinates() - initial_center;</a>
<a name="465"><span class="lineNum">     465 </span>            :                 noalias(relative_position) = new_axes1 * local_coordinates[0] + new_axes2 * local_coordinates[1] + new_axes3 * local_coordinates[2];</a>
<a name="466"><span class="lineNum">     466 </span>            :                 array_1d&lt;double, 3&gt; old_coordinates;</a>
<a name="467"><span class="lineNum">     467 </span>            :                 noalias(old_coordinates) = node-&gt;Coordinates();</a>
<a name="468"><span class="lineNum">     468 </span>            :                 array_1d&lt;double, 3&gt; velocity_due_to_rotation;</a>
<a name="469"><span class="lineNum">     469 </span>            :                 array_1d&lt;double, 3&gt;&amp; velocity = node-&gt;FastGetSolutionStepValue(VELOCITY);</a>
<a name="470"><span class="lineNum">     470 </span>            : </a>
<a name="471"><span class="lineNum">     471 </span>            :                 CrossProduct(angular_velocity_changed, relative_position, velocity_due_to_rotation);</a>
<a name="472"><span class="lineNum">     472 </span>            :                 noalias(velocity) = linear_velocity_changed + velocity_due_to_rotation;</a>
<a name="473"><span class="lineNum">     473 </span>            : </a>
<a name="474"><span class="lineNum">     474 </span>            :                 if (!fixed_mesh) {</a>
<a name="475"><span class="lineNum">     475 </span>            :                     // NEW POSITION</a>
<a name="476"><span class="lineNum">     476 </span>            :                     noalias(node-&gt;Coordinates()) = center_position + relative_position;</a>
<a name="477"><span class="lineNum">     477 </span>            :                     // DISPLACEMENT</a>
<a name="478"><span class="lineNum">     478 </span>            :                     noalias(node-&gt;FastGetSolutionStepValue(DISPLACEMENT)) = node-&gt;Coordinates() - node-&gt;GetInitialPosition().Coordinates();</a>
<a name="479"><span class="lineNum">     479 </span>            :                     noalias(node-&gt;FastGetSolutionStepValue(DELTA_DISPLACEMENT)) = node-&gt;Coordinates() - old_coordinates;</a>
<a name="480"><span class="lineNum">     480 </span>            :                 } else {</a>
<a name="481"><span class="lineNum">     481 </span>            :                     (node-&gt;FastGetSolutionStepValue(DISPLACEMENT)).clear(); //Set values to zero</a>
<a name="482"><span class="lineNum">     482 </span>            :                     noalias(node-&gt;FastGetSolutionStepValue(DELTA_DISPLACEMENT)) = velocity * dt; //But still there must be some delta_displacement (or motion won't be detected by the spheres!)</a>
<a name="483"><span class="lineNum">     483 </span>            :                 }</a>
<a name="484"><span class="lineNum">     484 </span>            :             }</a>
<a name="485"><span class="lineNum">     485 </span>            :         }</a>
<a name="486"><span class="lineNum">     486 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span>            :     //NOTE:: Modified by M. Santasusana Feb 2013 - simplification (the one proposed by F. Chun was for a more generalized case)</a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">       3992 :     static inline void ComputeContactLocalCoordSystem(array_1d&lt;double, 3&gt; NormalDirection, const double&amp; distance, double LocalCoordSystem[3][3])  //inline: modifies the LocalCoordSystem as it were a reference</span></a>
<a name="491"><span class="lineNum">     491 </span>            :     {</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">       3992 :         double inv_distance = (distance != 0.0) ? 1.0 / distance : 0.0;</span></a>
<a name="493"><span class="lineNum">     493 </span><span class="lineCov">       3992 :         NormalDirection[0] *= inv_distance;</span></a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">       3992 :         NormalDirection[1] *= inv_distance;</span></a>
<a name="495"><span class="lineNum">     495 </span><span class="lineCov">       3992 :         NormalDirection[2] *= inv_distance;</span></a>
<a name="496"><span class="lineNum">     496 </span>            :         double N_fast[3];</a>
<a name="497"><span class="lineNum">     497 </span>            :         N_fast[0] = NormalDirection[0];</a>
<a name="498"><span class="lineNum">     498 </span>            :         N_fast[1] = NormalDirection[1];</a>
<a name="499"><span class="lineNum">     499 </span>            :         N_fast[2] = NormalDirection[2];</a>
<a name="500"><span class="lineNum">     500 </span>            : </a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">       3992 :         if (fabs(N_fast[0]) &gt;= 0.577) //0.57735026919</span></a>
<a name="502"><span class="lineNum">     502 </span>            :         {</a>
<a name="503"><span class="lineNum">     503 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][0] = - N_fast[1];</span></a>
<a name="504"><span class="lineNum">     504 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][1] = N_fast[0];</span></a>
<a name="505"><span class="lineNum">     505 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][2] = 0.0;</span></a>
<a name="506"><span class="lineNum">     506 </span>            :         }</a>
<a name="507"><span class="lineNum">     507 </span><span class="lineCov">       3992 :         else if (fabs(N_fast[1]) &gt;= 0.577)</span></a>
<a name="508"><span class="lineNum">     508 </span>            :         {</a>
<a name="509"><span class="lineNum">     509 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][0] = 0.0;</span></a>
<a name="510"><span class="lineNum">     510 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][1] = - N_fast[2];</span></a>
<a name="511"><span class="lineNum">     511 </span><span class="lineNoCov">          0 :             LocalCoordSystem[0][2] = N_fast[1];</span></a>
<a name="512"><span class="lineNum">     512 </span>            :         }</a>
<a name="513"><span class="lineNum">     513 </span>            :         else</a>
<a name="514"><span class="lineNum">     514 </span>            :         {</a>
<a name="515"><span class="lineNum">     515 </span><span class="lineCov">       3992 :             LocalCoordSystem[0][0] = N_fast[2];</span></a>
<a name="516"><span class="lineNum">     516 </span><span class="lineCov">       3992 :             LocalCoordSystem[0][1] = 0.0;</span></a>
<a name="517"><span class="lineNum">     517 </span><span class="lineCov">       3992 :             LocalCoordSystem[0][2] = - N_fast[0];</span></a>
<a name="518"><span class="lineNum">     518 </span>            :         }</a>
<a name="519"><span class="lineNum">     519 </span>            : </a>
<a name="520"><span class="lineNum">     520 </span>            :         //normalize(Vector0);</a>
<a name="521"><span class="lineNum">     521 </span><span class="lineCov">       3992 :         double distance0 = DEM_MODULUS_3(LocalCoordSystem[0]);</span></a>
<a name="522"><span class="lineNum">     522 </span><span class="lineCov">       3992 :         double inv_distance0 = (distance0 != 0.0) ? 1.0 / distance0 : 0.0;</span></a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">       3992 :         LocalCoordSystem[0][0] = LocalCoordSystem[0][0] * inv_distance0;</span></a>
<a name="524"><span class="lineNum">     524 </span><span class="lineCov">       3992 :         LocalCoordSystem[0][1] = LocalCoordSystem[0][1] * inv_distance0;</span></a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">       3992 :         LocalCoordSystem[0][2] = LocalCoordSystem[0][2] * inv_distance0;</span></a>
<a name="526"><span class="lineNum">     526 </span>            : </a>
<a name="527"><span class="lineNum">     527 </span>            :         //CrossProduct(NormalDirection, Vector0, Vector1);</a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">       3992 :         LocalCoordSystem[1][0] = N_fast[1] * LocalCoordSystem[0][2] - N_fast[2] * LocalCoordSystem[0][1];</span></a>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">       3992 :         LocalCoordSystem[1][1] = N_fast[2] * LocalCoordSystem[0][0] - N_fast[0] * LocalCoordSystem[0][2];</span></a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">       3992 :         LocalCoordSystem[1][2] = N_fast[0] * LocalCoordSystem[0][1] - N_fast[1] * LocalCoordSystem[0][0];</span></a>
<a name="531"><span class="lineNum">     531 </span>            : </a>
<a name="532"><span class="lineNum">     532 </span>            :         //normalize(Vector1);</a>
<a name="533"><span class="lineNum">     533 </span>            : </a>
<a name="534"><span class="lineNum">     534 </span><span class="lineCov">       3992 :         LocalCoordSystem[2][0] = N_fast[0];</span></a>
<a name="535"><span class="lineNum">     535 </span><span class="lineCov">       3992 :         LocalCoordSystem[2][1] = N_fast[1];</span></a>
<a name="536"><span class="lineNum">     536 </span><span class="lineCov">       3992 :         LocalCoordSystem[2][2] = N_fast[2];</span></a>
<a name="537"><span class="lineNum">     537 </span><span class="lineCov">       3992 :     }</span></a>
<a name="538"><span class="lineNum">     538 </span>            : </a>
<a name="539"><span class="lineNum">     539 </span>            :     static inline double DistanceOfTwoPoint(const double coord1[3], const double coord2[3])</a>
<a name="540"><span class="lineNum">     540 </span>            :     {</a>
<a name="541"><span class="lineNum">     541 </span>            :         double dx = coord1[0] - coord2[0];</a>
<a name="542"><span class="lineNum">     542 </span>            :         double dy = coord1[1] - coord2[1];</a>
<a name="543"><span class="lineNum">     543 </span>            :         double dz = coord1[2] - coord2[2];</a>
<a name="544"><span class="lineNum">     544 </span>            : </a>
<a name="545"><span class="lineNum">     545 </span>            :         return sqrt(dx * dx + dy * dy + dz * dz);</a>
<a name="546"><span class="lineNum">     546 </span>            :     }</a>
<a name="547"><span class="lineNum">     547 </span>            : </a>
<a name="548"><span class="lineNum">     548 </span><span class="lineNoCov">          0 :     static inline double DistanceOfTwoPoint(const array_1d&lt;double,3&gt;&amp; coord1, const double coord2[3])</span></a>
<a name="549"><span class="lineNum">     549 </span>            :     {</a>
<a name="550"><span class="lineNum">     550 </span><span class="lineNoCov">          0 :         double dx = coord1[0] - coord2[0];</span></a>
<a name="551"><span class="lineNum">     551 </span><span class="lineNoCov">          0 :         double dy = coord1[1] - coord2[1];</span></a>
<a name="552"><span class="lineNum">     552 </span><span class="lineNoCov">          0 :         double dz = coord1[2] - coord2[2];</span></a>
<a name="553"><span class="lineNum">     553 </span>            : </a>
<a name="554"><span class="lineNum">     554 </span><span class="lineNoCov">          0 :         return sqrt(dx * dx + dy * dy + dz * dz);</span></a>
<a name="555"><span class="lineNum">     555 </span>            :     }</a>
<a name="556"><span class="lineNum">     556 </span>            : </a>
<a name="557"><span class="lineNum">     557 </span>            :     static inline double DistanceOfTwoPointSquared(const array_1d&lt;double,3&gt;&amp; coord1, const array_1d&lt;double,3&gt;&amp; coord2)</a>
<a name="558"><span class="lineNum">     558 </span>            :     {</a>
<a name="559"><span class="lineNum">     559 </span>            :         double dx = coord1[0] - coord2[0];</a>
<a name="560"><span class="lineNum">     560 </span>            :         double dy = coord1[1] - coord2[1];</a>
<a name="561"><span class="lineNum">     561 </span>            :         double dz = coord1[2] - coord2[2];</a>
<a name="562"><span class="lineNum">     562 </span>            : </a>
<a name="563"><span class="lineNum">     563 </span>            :         return (dx * dx + dy * dy + dz * dz);</a>
<a name="564"><span class="lineNum">     564 </span>            :     }</a>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<a name="566"><span class="lineNum">     566 </span>            :     static inline double DistanceOfTwoPointSquared(double coord1[3], double coord2[3])</a>
<a name="567"><span class="lineNum">     567 </span>            :     {</a>
<a name="568"><span class="lineNum">     568 </span>            :         double dx = coord1[0] - coord2[0];</a>
<a name="569"><span class="lineNum">     569 </span>            :         double dy = coord1[1] - coord2[1];</a>
<a name="570"><span class="lineNum">     570 </span>            :         double dz = coord1[2] - coord2[2];</a>
<a name="571"><span class="lineNum">     571 </span>            : </a>
<a name="572"><span class="lineNum">     572 </span>            :         return (dx * dx + dy * dy + dz * dz);</a>
<a name="573"><span class="lineNum">     573 </span>            :     }</a>
<a name="574"><span class="lineNum">     574 </span>            :     static inline double DistancePointToPlane(const array_1d&lt;double,3&gt;&amp; CoordInPlane, double PlaneUnitNormalVector[3], double TestCoord[3])</a>
<a name="575"><span class="lineNum">     575 </span>            :     {</a>
<a name="576"><span class="lineNum">     576 </span>            :         double Vector1[3] = {0.0};</a>
<a name="577"><span class="lineNum">     577 </span>            : </a>
<a name="578"><span class="lineNum">     578 </span>            :         for (unsigned int i = 0; i&lt;3; i++)</a>
<a name="579"><span class="lineNum">     579 </span>            :         {</a>
<a name="580"><span class="lineNum">     580 </span>            :             Vector1[i] = TestCoord[i]- CoordInPlane[i];</a>
<a name="581"><span class="lineNum">     581 </span>            :         }</a>
<a name="582"><span class="lineNum">     582 </span>            : </a>
<a name="583"><span class="lineNum">     583 </span>            :         double dist = fabs (DotProduct(Vector1, PlaneUnitNormalVector));</a>
<a name="584"><span class="lineNum">     584 </span>            : </a>
<a name="585"><span class="lineNum">     585 </span>            :         return dist;</a>
<a name="586"><span class="lineNum">     586 </span>            :     }</a>
<a name="587"><span class="lineNum">     587 </span>            : </a>
<a name="588"><span class="lineNum">     588 </span>            :     static inline void CoordProjectionOnPlane(double CoordOut[3], double CoordIn[3], double LocalCoordSystem[3][3], double IntersectionCoord[3])</a>
<a name="589"><span class="lineNum">     589 </span>            :     {</a>
<a name="590"><span class="lineNum">     590 </span>            :         double out_coord_local[3] = {0.0};</a>
<a name="591"><span class="lineNum">     591 </span>            :         double in_coord_local[3]  = {0.0};</a>
<a name="592"><span class="lineNum">     592 </span>            : </a>
<a name="593"><span class="lineNum">     593 </span>            :         VectorGlobal2Local(LocalCoordSystem, CoordOut, out_coord_local);</a>
<a name="594"><span class="lineNum">     594 </span>            :         VectorGlobal2Local(LocalCoordSystem, CoordIn,  in_coord_local);</a>
<a name="595"><span class="lineNum">     595 </span>            : </a>
<a name="596"><span class="lineNum">     596 </span>            :         double vector1[3] = {0.0};</a>
<a name="597"><span class="lineNum">     597 </span>            :         vector1[0] = out_coord_local[0];</a>
<a name="598"><span class="lineNum">     598 </span>            :         vector1[1] = out_coord_local[1];</a>
<a name="599"><span class="lineNum">     599 </span>            :         vector1[2] = in_coord_local [2];</a>
<a name="600"><span class="lineNum">     600 </span>            : </a>
<a name="601"><span class="lineNum">     601 </span>            :         VectorLocal2Global(LocalCoordSystem, vector1, IntersectionCoord);</a>
<a name="602"><span class="lineNum">     602 </span>            : </a>
<a name="603"><span class="lineNum">     603 </span>            :     }</a>
<a name="604"><span class="lineNum">     604 </span>            : </a>
<a name="605"><span class="lineNum">     605 </span>            :     static inline void CoordProjectionOnPlaneNew(double CoordOut[3], const array_1d&lt;double, 3&gt;&amp; CoordIn, double LocalCoordSystem[3][3], double IntersectionCoord[3])</a>
<a name="606"><span class="lineNum">     606 </span>            :     {</a>
<a name="607"><span class="lineNum">     607 </span>            :         double out_coord_local[3] = {0.0};</a>
<a name="608"><span class="lineNum">     608 </span>            :         double in_coord_local[3]  = {0.0};</a>
<a name="609"><span class="lineNum">     609 </span>            : </a>
<a name="610"><span class="lineNum">     610 </span>            :         VectorGlobal2Local(LocalCoordSystem, CoordOut, out_coord_local);</a>
<a name="611"><span class="lineNum">     611 </span>            :         VectorGlobal2Local(LocalCoordSystem, CoordIn,  in_coord_local);</a>
<a name="612"><span class="lineNum">     612 </span>            : </a>
<a name="613"><span class="lineNum">     613 </span>            :         double vector1[3] = {0.0};</a>
<a name="614"><span class="lineNum">     614 </span>            :         vector1[0] = out_coord_local[0];</a>
<a name="615"><span class="lineNum">     615 </span>            :         vector1[1] = out_coord_local[1];</a>
<a name="616"><span class="lineNum">     616 </span>            :         vector1[2] = in_coord_local [2];</a>
<a name="617"><span class="lineNum">     617 </span>            : </a>
<a name="618"><span class="lineNum">     618 </span>            :         VectorLocal2Global(LocalCoordSystem, vector1, IntersectionCoord);</a>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<a name="620"><span class="lineNum">     620 </span>            :     }</a>
<a name="621"><span class="lineNum">     621 </span>            : </a>
<a name="622"><span class="lineNum">     622 </span>            :     static inline void Compute3DimElementFaceLocalSystem(const array_1d &lt;double,3&gt;&amp; FaceCoord1, const array_1d &lt;double,3&gt;&amp; FaceCoord2, const array_1d &lt;double,3&gt;&amp; FaceCoord3, double ParticleCoord[3],</a>
<a name="623"><span class="lineNum">     623 </span>            :                                                           double LocalCoordSystem[3][3], double&amp; normal_flag)</a>
<a name="624"><span class="lineNum">     624 </span>            :     {</a>
<a name="625"><span class="lineNum">     625 </span>            :         //NOTE: this function is designed in a way that the normal always points the side where the center of particle is found. Therefore should only be used in this way if the indentation is less than the radius value.</a>
<a name="626"><span class="lineNum">     626 </span>            :         //the function returns a flag with the same value as the dot product of the normal of the triangle and the normal pointing to the particle.</a>
<a name="627"><span class="lineNum">     627 </span>            : </a>
<a name="628"><span class="lineNum">     628 </span>            :         double Vector1[3] = {0.0};</a>
<a name="629"><span class="lineNum">     629 </span>            :         double Vector2[3] = {0.0};</a>
<a name="630"><span class="lineNum">     630 </span>            :         double Vector3[3] = {0.0};</a>
<a name="631"><span class="lineNum">     631 </span>            :         double Normal[3]  = {0.0};</a>
<a name="632"><span class="lineNum">     632 </span>            : </a>
<a name="633"><span class="lineNum">     633 </span>            :         Vector1[0] = FaceCoord2[0] - FaceCoord1[0];</a>
<a name="634"><span class="lineNum">     634 </span>            :         Vector1[1] = FaceCoord2[1] - FaceCoord1[1];</a>
<a name="635"><span class="lineNum">     635 </span>            :         Vector1[2] = FaceCoord2[2] - FaceCoord1[2];</a>
<a name="636"><span class="lineNum">     636 </span>            : </a>
<a name="637"><span class="lineNum">     637 </span>            :         Vector2[0] = FaceCoord3[0] - FaceCoord2[0];</a>
<a name="638"><span class="lineNum">     638 </span>            :         Vector2[1] = FaceCoord3[1] - FaceCoord2[1];</a>
<a name="639"><span class="lineNum">     639 </span>            :         Vector2[2] = FaceCoord3[2] - FaceCoord2[2];</a>
<a name="640"><span class="lineNum">     640 </span>            : </a>
<a name="641"><span class="lineNum">     641 </span>            :         normalize(Vector1);</a>
<a name="642"><span class="lineNum">     642 </span>            :         CrossProduct(Vector1, Vector2, Normal);</a>
<a name="643"><span class="lineNum">     643 </span>            :         normalize(Normal);</a>
<a name="644"><span class="lineNum">     644 </span>            : </a>
<a name="645"><span class="lineNum">     645 </span>            :         CrossProduct(Normal, Vector1, Vector2);</a>
<a name="646"><span class="lineNum">     646 </span>            :         normalize(Vector2);</a>
<a name="647"><span class="lineNum">     647 </span>            : </a>
<a name="648"><span class="lineNum">     648 </span>            :         Vector3[0] = ParticleCoord[0] - FaceCoord1[0];</a>
<a name="649"><span class="lineNum">     649 </span>            :         Vector3[1] = ParticleCoord[1] - FaceCoord1[1];</a>
<a name="650"><span class="lineNum">     650 </span>            :         Vector3[2] = ParticleCoord[2] - FaceCoord1[2];</a>
<a name="651"><span class="lineNum">     651 </span>            : </a>
<a name="652"><span class="lineNum">     652 </span>            :         normalize(Vector3);</a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span>            :         if (DotProduct(Vector3, Normal) &gt; 0.0)</a>
<a name="655"><span class="lineNum">     655 </span>            :         {</a>
<a name="656"><span class="lineNum">     656 </span>            :             for (int ia = 0; ia &lt; 3; ia++)</a>
<a name="657"><span class="lineNum">     657 </span>            :             {</a>
<a name="658"><span class="lineNum">     658 </span>            :                 normal_flag             = 1.0;</a>
<a name="659"><span class="lineNum">     659 </span>            :                 LocalCoordSystem[0][ia] = Vector1[ia];</a>
<a name="660"><span class="lineNum">     660 </span>            :                 LocalCoordSystem[1][ia] = Vector2[ia];</a>
<a name="661"><span class="lineNum">     661 </span>            :                 LocalCoordSystem[2][ia] = Normal [ia];</a>
<a name="662"><span class="lineNum">     662 </span>            :            }</a>
<a name="663"><span class="lineNum">     663 </span>            :         }</a>
<a name="664"><span class="lineNum">     664 </span>            :         else</a>
<a name="665"><span class="lineNum">     665 </span>            :         {</a>
<a name="666"><span class="lineNum">     666 </span>            :             for (int ia = 0; ia &lt; 3; ia++)</a>
<a name="667"><span class="lineNum">     667 </span>            :             {</a>
<a name="668"><span class="lineNum">     668 </span>            :                 normal_flag             = -1.0;</a>
<a name="669"><span class="lineNum">     669 </span>            :                 LocalCoordSystem[0][ia] = -Vector1[ia];</a>
<a name="670"><span class="lineNum">     670 </span>            :                 LocalCoordSystem[1][ia] = -Vector2[ia];</a>
<a name="671"><span class="lineNum">     671 </span>            :                 LocalCoordSystem[2][ia] = -Normal [ia];</a>
<a name="672"><span class="lineNum">     672 </span>            :             }</a>
<a name="673"><span class="lineNum">     673 </span>            :         }</a>
<a name="674"><span class="lineNum">     674 </span>            :     }</a>
<a name="675"><span class="lineNum">     675 </span>            : </a>
<a name="676"><span class="lineNum">     676 </span>            :     //MSIMSI this one is being used only for distributed... adapt it</a>
<a name="677"><span class="lineNum">     677 </span>            :     static inline void Compute3DimElementFaceLocalSystem(double FaceCoord1[3], double FaceCoord2[3], double FaceCoord3[3], double ParticleCoord[3],</a>
<a name="678"><span class="lineNum">     678 </span>            :                                                          double LocalCoordSystem[3][3], double&amp; normal_flag){</a>
<a name="679"><span class="lineNum">     679 </span>            : </a>
<a name="680"><span class="lineNum">     680 </span>            :         //NOTE: this function is designed in a way that the normal always points the side where the center of particle is found. Therefore should only be used in this way if the indentation is less than the radius value.</a>
<a name="681"><span class="lineNum">     681 </span>            :         //the function returns a flag with the same value as the dot product of the normal of the triangle and the normal pointing to the particle.</a>
<a name="682"><span class="lineNum">     682 </span>            : </a>
<a name="683"><span class="lineNum">     683 </span>            :         double Vector1[3] = {0.0};</a>
<a name="684"><span class="lineNum">     684 </span>            :         double Vector2[3] = {0.0};</a>
<a name="685"><span class="lineNum">     685 </span>            :         double Vector3[3] = {0.0};</a>
<a name="686"><span class="lineNum">     686 </span>            :         double Normal[3]  = {0.0};</a>
<a name="687"><span class="lineNum">     687 </span>            : </a>
<a name="688"><span class="lineNum">     688 </span>            :         Vector1[0] = FaceCoord2[0] - FaceCoord1[0];</a>
<a name="689"><span class="lineNum">     689 </span>            :         Vector1[1] = FaceCoord2[1] - FaceCoord1[1];</a>
<a name="690"><span class="lineNum">     690 </span>            :         Vector1[2] = FaceCoord2[2] - FaceCoord1[2];</a>
<a name="691"><span class="lineNum">     691 </span>            : </a>
<a name="692"><span class="lineNum">     692 </span>            :         Vector2[0] = FaceCoord3[0] - FaceCoord2[0];</a>
<a name="693"><span class="lineNum">     693 </span>            :         Vector2[1] = FaceCoord3[1] - FaceCoord2[1];</a>
<a name="694"><span class="lineNum">     694 </span>            :         Vector2[2] = FaceCoord3[2] - FaceCoord2[2];</a>
<a name="695"><span class="lineNum">     695 </span>            : </a>
<a name="696"><span class="lineNum">     696 </span>            :         normalize(Vector1);</a>
<a name="697"><span class="lineNum">     697 </span>            :         CrossProduct(Vector1, Vector2, Normal);</a>
<a name="698"><span class="lineNum">     698 </span>            :         normalize(Normal);</a>
<a name="699"><span class="lineNum">     699 </span>            : </a>
<a name="700"><span class="lineNum">     700 </span>            :         CrossProduct(Normal, Vector1, Vector2);</a>
<a name="701"><span class="lineNum">     701 </span>            :         normalize(Vector2);</a>
<a name="702"><span class="lineNum">     702 </span>            : </a>
<a name="703"><span class="lineNum">     703 </span>            :         Vector3[0] = ParticleCoord[0] - FaceCoord1[0];</a>
<a name="704"><span class="lineNum">     704 </span>            :         Vector3[1] = ParticleCoord[1] - FaceCoord1[1];</a>
<a name="705"><span class="lineNum">     705 </span>            :         Vector3[2] = ParticleCoord[2] - FaceCoord1[2];</a>
<a name="706"><span class="lineNum">     706 </span>            :         normalize(Vector3);</a>
<a name="707"><span class="lineNum">     707 </span>            : </a>
<a name="708"><span class="lineNum">     708 </span>            :         if (DotProduct(Vector3, Normal) &gt; 0.0)</a>
<a name="709"><span class="lineNum">     709 </span>            :         {</a>
<a name="710"><span class="lineNum">     710 </span>            :             for (int ia = 0; ia &lt; 3; ia++)</a>
<a name="711"><span class="lineNum">     711 </span>            :             {</a>
<a name="712"><span class="lineNum">     712 </span>            :                 normal_flag             = 1.0;</a>
<a name="713"><span class="lineNum">     713 </span>            :                 LocalCoordSystem[0][ia] = Vector1[ia];</a>
<a name="714"><span class="lineNum">     714 </span>            :                 LocalCoordSystem[1][ia] = Vector2[ia];</a>
<a name="715"><span class="lineNum">     715 </span>            :                 LocalCoordSystem[2][ia] = Normal [ia];</a>
<a name="716"><span class="lineNum">     716 </span>            :             }</a>
<a name="717"><span class="lineNum">     717 </span>            :         }</a>
<a name="718"><span class="lineNum">     718 </span>            :         else</a>
<a name="719"><span class="lineNum">     719 </span>            :         {</a>
<a name="720"><span class="lineNum">     720 </span>            :             for (int ia = 0; ia &lt; 3; ia++)</a>
<a name="721"><span class="lineNum">     721 </span>            :             {</a>
<a name="722"><span class="lineNum">     722 </span>            :                 normal_flag             = -1.0;</a>
<a name="723"><span class="lineNum">     723 </span>            :                 LocalCoordSystem[0][ia] = -Vector1[ia];</a>
<a name="724"><span class="lineNum">     724 </span>            :                 LocalCoordSystem[1][ia] = -Vector2[ia];</a>
<a name="725"><span class="lineNum">     725 </span>            :                 LocalCoordSystem[2][ia] = -Normal [ia];</a>
<a name="726"><span class="lineNum">     726 </span>            :             }</a>
<a name="727"><span class="lineNum">     727 </span>            :         }</a>
<a name="728"><span class="lineNum">     728 </span>            :     }//Compute3DimElementFaceLocalSystem</a>
<a name="729"><span class="lineNum">     729 </span>            : </a>
<a name="730"><span class="lineNum">     730 </span>            : </a>
<a name="731"><span class="lineNum">     731 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="732"><span class="lineNum">     732 </span>            :     ///////////////******Rotate a point over an arbitrary line though an arbitrary point******/////////////////////////////////////</a>
<a name="733"><span class="lineNum">     733 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="734"><span class="lineNum">     734 </span>            : </a>
<a name="735"><span class="lineNum">     735 </span>            :     static inline void RotatePointAboutArbitraryLine(array_1d&lt;double,3&gt;&amp; TargetPoint, const array_1d&lt;double,3&gt;&amp; CentrePoint, const array_1d&lt;double,3&gt;&amp; LineVector, const double RotationAngle)</a>
<a name="736"><span class="lineNum">     736 </span>            :     {</a>
<a name="737"><span class="lineNum">     737 </span>            :         const double O = RotationAngle;</a>
<a name="738"><span class="lineNum">     738 </span>            :         double x = TargetPoint[0], a = CentrePoint[0], u = LineVector[0];</a>
<a name="739"><span class="lineNum">     739 </span>            :         double y = TargetPoint[1], b = CentrePoint[1], v = LineVector[1];</a>
<a name="740"><span class="lineNum">     740 </span>            :         double z = TargetPoint[2], c = CentrePoint[2], w = LineVector[2];</a>
<a name="741"><span class="lineNum">     741 </span>            :         double L = u*u+v*v+w*w;</a>
<a name="742"><span class="lineNum">     742 </span>            : </a>
<a name="743"><span class="lineNum">     743 </span>            :         if (L==0)</a>
<a name="744"><span class="lineNum">     744 </span>            :         {</a>
<a name="745"><span class="lineNum">     745 </span>            :         }</a>
<a name="746"><span class="lineNum">     746 </span>            :         else</a>
<a name="747"><span class="lineNum">     747 </span>            :         {</a>
<a name="748"><span class="lineNum">     748 </span>            :             const double inv_L = 1.0 / L;</a>
<a name="749"><span class="lineNum">     749 </span>            :         TargetPoint[0] = ((a*(v*v+w*w)-u*(b*v+c*w-u*x-v*y-w*z))*(1-cos(O))+L*x*cos(O)+sqrt(L)*(-c*w+b*w-w*y+v*z)*sin(O))* inv_L;</a>
<a name="750"><span class="lineNum">     750 </span>            :         TargetPoint[1] = ((b*(u*u+w*w)-v*(a*u+c*w-u*x-v*y-w*z))*(1-cos(O))+L*y*cos(O)+sqrt(L)*(c*u-a*w+w*x-u*z)*sin(O))* inv_L;</a>
<a name="751"><span class="lineNum">     751 </span>            :         TargetPoint[2] = ((c*(u*u+v*v)-w*(a*u+b*v-u*x-v*y-w*z))*(1-cos(O))+L*z*cos(O)+sqrt(L)*(-b*u+a*v-v*x+u*y)*sin(O))* inv_L;</a>
<a name="752"><span class="lineNum">     752 </span>            :         }</a>
<a name="753"><span class="lineNum">     753 </span>            :     }</a>
<a name="754"><span class="lineNum">     754 </span>            : </a>
<a name="755"><span class="lineNum">     755 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="756"><span class="lineNum">     756 </span>            :     ////////////////////////////////////////////////////******Quaternions******////////////////////////////////////////////////////</a>
<a name="757"><span class="lineNum">     757 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="758"><span class="lineNum">     758 </span>            : </a>
<a name="759"><span class="lineNum">     759 </span>            :     static inline void QuaternionVectorLocal2Global(const Quaternion&lt;double&gt;&amp; Q, const array_1d&lt;double, 3&gt;&amp; LocalVector, array_1d&lt;double, 3&gt;&amp; GlobalVector)</a>
<a name="760"><span class="lineNum">     760 </span>            :     {</a>
<a name="761"><span class="lineNum">     761 </span><span class="lineNoCov">          0 :         Q.RotateVector3(LocalVector, GlobalVector);</span></a>
<a name="762"><span class="lineNum">     762 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="763"><span class="lineNum">     763 </span>            : </a>
<a name="764"><span class="lineNum">     764 </span><span class="lineCov">          2 :     static inline void QuaternionVectorGlobal2Local(const Quaternion&lt;double&gt;&amp; Q, const array_1d&lt;double, 3&gt;&amp; GlobalVector, array_1d&lt;double, 3&gt;&amp; LocalVector)</span></a>
<a name="765"><span class="lineNum">     765 </span>            :     {</a>
<a name="766"><span class="lineNum">     766 </span>            :         Quaternion&lt;double&gt; Q_conj = Q.conjugate();</a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">          2 :         Q_conj.RotateVector3(GlobalVector, LocalVector);</span></a>
<a name="768"><span class="lineNum">     768 </span><span class="lineCov">          2 :     }</span></a>
<a name="769"><span class="lineNum">     769 </span>            : </a>
<a name="770"><span class="lineNum">     770 </span><span class="lineCov">          2 :     static inline void QuaternionTensorLocal2Global(const Quaternion&lt;double&gt;&amp; Q, const double LocalTensor[3][3], double GlobalTensor[3][3])</span></a>
<a name="771"><span class="lineNum">     771 </span>            :     {</a>
<a name="772"><span class="lineNum">     772 </span>            :         array_1d&lt;double, 3&gt; LocalTensorC1; array_1d&lt;double, 3&gt; LocalTensorC2; array_1d&lt;double, 3&gt; LocalTensorC3;</a>
<a name="773"><span class="lineNum">     773 </span>            : </a>
<a name="774"><span class="lineNum">     774 </span><span class="lineCov">          2 :         LocalTensorC1[0] = LocalTensor[0][0]; LocalTensorC2[0] = LocalTensor[0][1]; LocalTensorC3[0] = LocalTensor[0][2];</span></a>
<a name="775"><span class="lineNum">     775 </span><span class="lineCov">          2 :         LocalTensorC1[1] = LocalTensor[1][0]; LocalTensorC2[1] = LocalTensor[1][1]; LocalTensorC3[1] = LocalTensor[1][2];</span></a>
<a name="776"><span class="lineNum">     776 </span><span class="lineCov">          2 :         LocalTensorC1[2] = LocalTensor[2][0]; LocalTensorC2[2] = LocalTensor[2][1]; LocalTensorC3[2] = LocalTensor[2][2];</span></a>
<a name="777"><span class="lineNum">     777 </span>            : </a>
<a name="778"><span class="lineNum">     778 </span>            :         array_1d&lt;double, 3&gt; TempTensorC1; array_1d&lt;double, 3&gt; TempTensorC2; array_1d&lt;double, 3&gt; TempTensorC3;</a>
<a name="779"><span class="lineNum">     779 </span>            :         array_1d&lt;double, 3&gt; TempTensorTraspC1; array_1d&lt;double, 3&gt; TempTensorTraspC2; array_1d&lt;double, 3&gt; TempTensorTraspC3;</a>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">          2 :         Q.RotateVector3(LocalTensorC1, TempTensorC1);</span></a>
<a name="782"><span class="lineNum">     782 </span><span class="lineCov">          2 :         Q.RotateVector3(LocalTensorC2, TempTensorC2);</span></a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">          2 :         Q.RotateVector3(LocalTensorC3, TempTensorC3);</span></a>
<a name="784"><span class="lineNum">     784 </span>            : </a>
<a name="785"><span class="lineNum">     785 </span><span class="lineCov">          2 :         TempTensorTraspC1[0] = TempTensorC1[0]; TempTensorTraspC2[0] = TempTensorC1[1]; TempTensorTraspC3[0] = TempTensorC1[2];</span></a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">          2 :         TempTensorTraspC1[1] = TempTensorC2[0]; TempTensorTraspC2[1] = TempTensorC2[1]; TempTensorTraspC3[1] = TempTensorC2[2];</span></a>
<a name="787"><span class="lineNum">     787 </span><span class="lineCov">          2 :         TempTensorTraspC1[2] = TempTensorC3[0]; TempTensorTraspC2[2] = TempTensorC3[1]; TempTensorTraspC3[2] = TempTensorC3[2];</span></a>
<a name="788"><span class="lineNum">     788 </span>            : </a>
<a name="789"><span class="lineNum">     789 </span>            :         array_1d&lt;double, 3&gt; GlobalTensorTraspC1; array_1d&lt;double, 3&gt; GlobalTensorTraspC2; array_1d&lt;double, 3&gt; GlobalTensorTraspC3;</a>
<a name="790"><span class="lineNum">     790 </span>            : </a>
<a name="791"><span class="lineNum">     791 </span><span class="lineCov">          2 :         Q.RotateVector3(TempTensorTraspC1, GlobalTensorTraspC1);</span></a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">          2 :         Q.RotateVector3(TempTensorTraspC2, GlobalTensorTraspC2);</span></a>
<a name="793"><span class="lineNum">     793 </span><span class="lineCov">          2 :         Q.RotateVector3(TempTensorTraspC3, GlobalTensorTraspC3);</span></a>
<a name="794"><span class="lineNum">     794 </span>            : </a>
<a name="795"><span class="lineNum">     795 </span><span class="lineCov">          2 :         GlobalTensor[0][0] = GlobalTensorTraspC1[0]; GlobalTensor[0][1] = GlobalTensorTraspC1[1]; GlobalTensor[0][2] = GlobalTensorTraspC1[2];</span></a>
<a name="796"><span class="lineNum">     796 </span><span class="lineCov">          2 :         GlobalTensor[1][0] = GlobalTensorTraspC2[0]; GlobalTensor[1][1] = GlobalTensorTraspC2[1]; GlobalTensor[1][2] = GlobalTensorTraspC2[2];</span></a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">          2 :         GlobalTensor[2][0] = GlobalTensorTraspC3[0]; GlobalTensor[2][1] = GlobalTensorTraspC3[1]; GlobalTensor[2][2] = GlobalTensorTraspC3[2];</span></a>
<a name="798"><span class="lineNum">     798 </span><span class="lineCov">          2 :     }</span></a>
<a name="799"><span class="lineNum">     799 </span>            : </a>
<a name="800"><span class="lineNum">     800 </span>            :     static inline void UpdateOrientation(array_1d&lt;double, 3&gt;&amp; EulerAngles, Quaternion&lt;double&gt;&amp; Orientation, const array_1d&lt;double, 3&gt;&amp; DeltaRotation)</a>
<a name="801"><span class="lineNum">     801 </span>            :     {</a>
<a name="802"><span class="lineNum">     802 </span>            :         Quaternion&lt;double&gt; DeltaOrientation = Quaternion&lt;double&gt;::Identity();</a>
<a name="803"><span class="lineNum">     803 </span>            : </a>
<a name="804"><span class="lineNum">     804 </span>            :         array_1d&lt;double, 3 &gt; theta = DeltaRotation;</a>
<a name="805"><span class="lineNum">     805 </span>            :         DEM_MULTIPLY_BY_SCALAR_3(theta, 0.5);</a>
<a name="806"><span class="lineNum">     806 </span>            : </a>
<a name="807"><span class="lineNum">     807 </span>            :         double thetaMag = DEM_MODULUS_3(theta);</a>
<a name="808"><span class="lineNum">     808 </span>            :         const double epsilon = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span>            :         if (thetaMag * thetaMag * thetaMag * thetaMag / 24.0 &lt; epsilon) { //Taylor: low angle</a>
<a name="811"><span class="lineNum">     811 </span>            :             double aux = (1 - thetaMag * thetaMag / 6);</a>
<a name="812"><span class="lineNum">     812 </span>            :             DeltaOrientation = Quaternion&lt;double&gt;((1 + thetaMag * thetaMag / 2), theta[0]*aux, theta[1]*aux, theta[2]*aux);</a>
<a name="813"><span class="lineNum">     813 </span>            :             DeltaOrientation.normalize();</a>
<a name="814"><span class="lineNum">     814 </span>            :         }</a>
<a name="815"><span class="lineNum">     815 </span>            :         else {</a>
<a name="816"><span class="lineNum">     816 </span>            :             double aux = std::sin(thetaMag)/thetaMag;</a>
<a name="817"><span class="lineNum">     817 </span>            :             DeltaOrientation = Quaternion&lt;double&gt;(cos(thetaMag), theta[0]*aux, theta[1]*aux, theta[2]*aux);</a>
<a name="818"><span class="lineNum">     818 </span>            :             DeltaOrientation.normalize();</a>
<a name="819"><span class="lineNum">     819 </span>            :         }</a>
<a name="820"><span class="lineNum">     820 </span>            :         Orientation = DeltaOrientation * Orientation;</a>
<a name="821"><span class="lineNum">     821 </span>            :         Orientation.ToEulerAngles(EulerAngles);</a>
<a name="822"><span class="lineNum">     822 </span>            :     }</a>
<a name="823"><span class="lineNum">     823 </span>            : </a>
<a name="824"><span class="lineNum">     824 </span><span class="lineNoCov">          0 :     static inline void UpdateOrientation(Quaternion&lt;double&gt;&amp; Orientation, const array_1d&lt;double, 3&gt;&amp; DeltaRotation)</span></a>
<a name="825"><span class="lineNum">     825 </span>            :     {</a>
<a name="826"><span class="lineNum">     826 </span>            :         Quaternion&lt;double&gt; DeltaOrientation = Quaternion&lt;double&gt;::Identity();</a>
<a name="827"><span class="lineNum">     827 </span>            : </a>
<a name="828"><span class="lineNum">     828 </span>            :         array_1d&lt;double, 3 &gt; theta = DeltaRotation;</a>
<a name="829"><span class="lineNum">     829 </span><span class="lineNoCov">          0 :         DEM_MULTIPLY_BY_SCALAR_3(theta, 0.5);</span></a>
<a name="830"><span class="lineNum">     830 </span>            : </a>
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 :         double thetaMag = DEM_MODULUS_3(theta);</span></a>
<a name="832"><span class="lineNum">     832 </span>            :         const double epsilon = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="833"><span class="lineNum">     833 </span>            : </a>
<a name="834"><span class="lineNum">     834 </span><span class="lineNoCov">          0 :         if (thetaMag * thetaMag * thetaMag * thetaMag / 24.0 &lt; epsilon) { //Taylor: low angle</span></a>
<a name="835"><span class="lineNum">     835 </span><span class="lineNoCov">          0 :             double aux = (1 - thetaMag * thetaMag / 6);</span></a>
<a name="836"><span class="lineNum">     836 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;((1 + thetaMag * thetaMag * 0.5), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="837"><span class="lineNum">     837 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="838"><span class="lineNum">     838 </span>            :         }</a>
<a name="839"><span class="lineNum">     839 </span>            :         else {</a>
<a name="840"><span class="lineNum">     840 </span><span class="lineNoCov">          0 :             double aux = std::sin(thetaMag)/thetaMag;</span></a>
<a name="841"><span class="lineNum">     841 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;(cos(thetaMag), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="842"><span class="lineNum">     842 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="843"><span class="lineNum">     843 </span>            :         }</a>
<a name="844"><span class="lineNum">     844 </span><span class="lineNoCov">          0 :         Orientation = DeltaOrientation * Orientation;</span></a>
<a name="845"><span class="lineNum">     845 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="846"><span class="lineNum">     846 </span>            : </a>
<a name="847"><span class="lineNum">     847 </span><span class="lineNoCov">          0 :     static inline void UpdateOrientation(const Quaternion&lt;double&gt;&amp; Orientation, Quaternion&lt;double&gt;&amp; NewOrientation, const array_1d&lt;double, 3&gt;&amp; DeltaRotation)</span></a>
<a name="848"><span class="lineNum">     848 </span>            :     {</a>
<a name="849"><span class="lineNum">     849 </span>            :         Quaternion&lt;double&gt; DeltaOrientation = Quaternion&lt;double&gt;::Identity();</a>
<a name="850"><span class="lineNum">     850 </span>            : </a>
<a name="851"><span class="lineNum">     851 </span>            :         array_1d&lt;double, 3 &gt; theta = DeltaRotation;</a>
<a name="852"><span class="lineNum">     852 </span><span class="lineNoCov">          0 :         DEM_MULTIPLY_BY_SCALAR_3(theta, 0.5);</span></a>
<a name="853"><span class="lineNum">     853 </span>            : </a>
<a name="854"><span class="lineNum">     854 </span><span class="lineNoCov">          0 :         double thetaMag = DEM_MODULUS_3(theta);</span></a>
<a name="855"><span class="lineNum">     855 </span>            :         const double epsilon = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="856"><span class="lineNum">     856 </span>            : </a>
<a name="857"><span class="lineNum">     857 </span><span class="lineNoCov">          0 :         if (thetaMag * thetaMag * thetaMag * thetaMag / 24.0 &lt; epsilon) { //Taylor: low angle</span></a>
<a name="858"><span class="lineNum">     858 </span><span class="lineNoCov">          0 :             double aux = (1 - thetaMag * thetaMag / 6);</span></a>
<a name="859"><span class="lineNum">     859 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;((1 + thetaMag * thetaMag * 0.5), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="860"><span class="lineNum">     860 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="861"><span class="lineNum">     861 </span>            :         }</a>
<a name="862"><span class="lineNum">     862 </span>            :         else {</a>
<a name="863"><span class="lineNum">     863 </span><span class="lineNoCov">          0 :             double aux = std::sin(thetaMag)/thetaMag;</span></a>
<a name="864"><span class="lineNum">     864 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;(cos(thetaMag), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="866"><span class="lineNum">     866 </span>            :         }</a>
<a name="867"><span class="lineNum">     867 </span><span class="lineNoCov">          0 :         NewOrientation = DeltaOrientation * Orientation;</span></a>
<a name="868"><span class="lineNum">     868 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="869"><span class="lineNum">     869 </span>            : </a>
<a name="870"><span class="lineNum">     870 </span><span class="lineNoCov">          0 :     static inline void EulerAnglesFromRotationAngle(array_1d&lt;double, 3&gt;&amp; EulerAngles, const array_1d&lt;double, 3&gt;&amp; RotatedAngle)</span></a>
<a name="871"><span class="lineNum">     871 </span>            :     {</a>
<a name="872"><span class="lineNum">     872 </span>            :         Quaternion&lt;double&gt; Orientation = Quaternion&lt;double&gt;::Identity();</a>
<a name="873"><span class="lineNum">     873 </span>            : </a>
<a name="874"><span class="lineNum">     874 </span>            :         array_1d&lt;double, 3 &gt; theta = RotatedAngle;</a>
<a name="875"><span class="lineNum">     875 </span><span class="lineNoCov">          0 :         DEM_MULTIPLY_BY_SCALAR_3(theta, 0.5);</span></a>
<a name="876"><span class="lineNum">     876 </span>            : </a>
<a name="877"><span class="lineNum">     877 </span><span class="lineNoCov">          0 :         double thetaMag = DEM_MODULUS_3(theta);</span></a>
<a name="878"><span class="lineNum">     878 </span>            : </a>
<a name="879"><span class="lineNum">     879 </span>            :         const double epsilon = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="880"><span class="lineNum">     880 </span>            : </a>
<a name="881"><span class="lineNum">     881 </span><span class="lineNoCov">          0 :         if (thetaMag * thetaMag * thetaMag * thetaMag / 24.0 &lt; epsilon) { //Taylor: low angle</span></a>
<a name="882"><span class="lineNum">     882 </span><span class="lineNoCov">          0 :             double aux = (1 - thetaMag * thetaMag / 6);</span></a>
<a name="883"><span class="lineNum">     883 </span><span class="lineNoCov">          0 :             Orientation = Quaternion&lt;double&gt;((1 + thetaMag * thetaMag / 2), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="884"><span class="lineNum">     884 </span><span class="lineNoCov">          0 :             Orientation.normalize();</span></a>
<a name="885"><span class="lineNum">     885 </span>            :         }</a>
<a name="886"><span class="lineNum">     886 </span>            :         else {</a>
<a name="887"><span class="lineNum">     887 </span><span class="lineNoCov">          0 :             double aux = std::sin(thetaMag)/thetaMag;</span></a>
<a name="888"><span class="lineNum">     888 </span><span class="lineNoCov">          0 :             Orientation = Quaternion&lt;double&gt;(cos(thetaMag), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="889"><span class="lineNum">     889 </span><span class="lineNoCov">          0 :             Orientation.normalize();</span></a>
<a name="890"><span class="lineNum">     890 </span>            :         }</a>
<a name="891"><span class="lineNum">     891 </span><span class="lineNoCov">          0 :         Orientation.ToEulerAngles(EulerAngles);</span></a>
<a name="892"><span class="lineNum">     892 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="893"><span class="lineNum">     893 </span>            : </a>
<a name="894"><span class="lineNum">     894 </span><span class="lineNoCov">          0 :     static inline void OrientationFromRotationAngle(Quaternion&lt;double&gt;&amp; DeltaOrientation, const array_1d&lt;double, 3&gt;&amp; DeltaRotation)</span></a>
<a name="895"><span class="lineNum">     895 </span>            :     {</a>
<a name="896"><span class="lineNum">     896 </span>            :         array_1d&lt;double, 3 &gt; theta = DeltaRotation;</a>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 :         DEM_MULTIPLY_BY_SCALAR_3(theta, 0.5);</span></a>
<a name="898"><span class="lineNum">     898 </span>            : </a>
<a name="899"><span class="lineNum">     899 </span><span class="lineNoCov">          0 :         double thetaMag = DEM_MODULUS_3(theta);</span></a>
<a name="900"><span class="lineNum">     900 </span>            :         const double epsilon = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="901"><span class="lineNum">     901 </span>            : </a>
<a name="902"><span class="lineNum">     902 </span><span class="lineNoCov">          0 :         if (thetaMag * thetaMag * thetaMag * thetaMag / 24.0 &lt; epsilon) { //Taylor: low angle</span></a>
<a name="903"><span class="lineNum">     903 </span><span class="lineNoCov">          0 :             double aux = (1 - thetaMag * thetaMag / 6);</span></a>
<a name="904"><span class="lineNum">     904 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;((1 + thetaMag * thetaMag / 2), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="905"><span class="lineNum">     905 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="906"><span class="lineNum">     906 </span>            :         }</a>
<a name="907"><span class="lineNum">     907 </span>            :         else {</a>
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 :             double aux = std::sin(thetaMag)/thetaMag;</span></a>
<a name="909"><span class="lineNum">     909 </span><span class="lineNoCov">          0 :             DeltaOrientation = Quaternion&lt;double&gt;(cos(thetaMag), theta[0]*aux, theta[1]*aux, theta[2]*aux);</span></a>
<a name="910"><span class="lineNum">     910 </span><span class="lineNoCov">          0 :             DeltaOrientation.normalize();</span></a>
<a name="911"><span class="lineNum">     911 </span>            :         }</a>
<a name="912"><span class="lineNum">     912 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="913"><span class="lineNum">     913 </span>            : </a>
<a name="914"><span class="lineNum">     914 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="915"><span class="lineNum">     915 </span>            :     ///////////////******EULER ANGLES from 2 vectors******/////////////////////////////////////////////////////////////////////////</a>
<a name="916"><span class="lineNum">     916 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="917"><span class="lineNum">     917 </span>            : </a>
<a name="918"><span class="lineNum">     918 </span>            : </a>
<a name="919"><span class="lineNum">     919 </span>            :     /*static inline void CalculateEulerAngles(const array_1d&lt;double,3&gt;&amp; OriginalVector_X, const array_1d&lt;double,3&gt;&amp; OriginalVector_Z,</a>
<a name="920"><span class="lineNum">     920 </span>            :                 const array_1d&lt;double,3&gt;&amp; RotatedVector_X, const array_1d&lt;double,3&gt;&amp; RotatedVector_Z, array_1d&lt;double,3&gt;&amp; EulerAngles)</a>
<a name="921"><span class="lineNum">     921 </span>            :     {</a>
<a name="922"><span class="lineNum">     922 </span>            : </a>
<a name="923"><span class="lineNum">     923 </span>            :         array_1d&lt; double,3 &gt; N = ZeroVector(3);</a>
<a name="924"><span class="lineNum">     924 </span>            : </a>
<a name="925"><span class="lineNum">     925 </span>            : </a>
<a name="926"><span class="lineNum">     926 </span>            : </a>
<a name="927"><span class="lineNum">     927 </span>            :         CrossProduct( OriginalVector_Z, RotatedVector_Z, N);</a>
<a name="928"><span class="lineNum">     928 </span>            : </a>
<a name="929"><span class="lineNum">     929 </span>            :         double return1 = DotProduct(N,OriginalVector_X);   //cos(Alpha)</a>
<a name="930"><span class="lineNum">     930 </span>            :         double return2 = DotProduct(OriginalVector_Z, RotatedVector_Z); //cos(Beta)</a>
<a name="931"><span class="lineNum">     931 </span>            :         double return3 = DotProduct(N,RotatedVector_X); //cos(Gamma)</a>
<a name="932"><span class="lineNum">     932 </span>            : </a>
<a name="933"><span class="lineNum">     933 </span>            :         EulerAngles[0] = acos(return1);</a>
<a name="934"><span class="lineNum">     934 </span>            :         EulerAngles[1] = acos(return2);</a>
<a name="935"><span class="lineNum">     935 </span>            :         EulerAngles[2] = acos(return3);</a>
<a name="936"><span class="lineNum">     936 </span>            : </a>
<a name="937"><span class="lineNum">     937 </span>            :     }*/</a>
<a name="938"><span class="lineNum">     938 </span>            : </a>
<a name="939"><span class="lineNum">     939 </span><span class="lineCov">       7312 :     static inline  bool InsideOutside(const array_1d&lt;double, 3&gt;&amp; Coord1,</span></a>
<a name="940"><span class="lineNum">     940 </span>            :                                       const array_1d&lt;double, 3&gt;&amp; Coord2,</a>
<a name="941"><span class="lineNum">     941 </span>            :                                       const array_1d&lt;double, 3&gt;&amp; JudgeCoord,</a>
<a name="942"><span class="lineNum">     942 </span>            :                                       const array_1d&lt;double, 3&gt;&amp; normal_element,</a>
<a name="943"><span class="lineNum">     943 </span>            :                                       double&amp; area){</a>
<a name="944"><span class="lineNum">     944 </span>            : </a>
<a name="945"><span class="lineNum">     945 </span>            :         //NOTE:: Normal_out here has to be the normal of the element orientation (not pointing particle)</a>
<a name="946"><span class="lineNum">     946 </span>            :         double b[3];</a>
<a name="947"><span class="lineNum">     947 </span>            :         double p1[3];</a>
<a name="948"><span class="lineNum">     948 </span>            :         double coor[3];</a>
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">       7312 :         DEM_COPY_SECOND_TO_FIRST_3(coor, Coord1)</span></a>
<a name="950"><span class="lineNum">     950 </span><span class="lineCov">       7312 :         b[0] = Coord2[0] - coor[0];</span></a>
<a name="951"><span class="lineNum">     951 </span><span class="lineCov">       7312 :         b[1] = Coord2[1] - coor[1];</span></a>
<a name="952"><span class="lineNum">     952 </span><span class="lineCov">       7312 :         b[2] = Coord2[2] - coor[2];</span></a>
<a name="953"><span class="lineNum">     953 </span><span class="lineCov">       7312 :         p1[0] = JudgeCoord[0] - coor[0];</span></a>
<a name="954"><span class="lineNum">     954 </span><span class="lineCov">       7312 :         p1[1] = JudgeCoord[1] - coor[1];</span></a>
<a name="955"><span class="lineNum">     955 </span><span class="lineCov">       7312 :         p1[2] = JudgeCoord[2] - coor[2];</span></a>
<a name="956"><span class="lineNum">     956 </span><span class="lineCov">       7312 :         DEM_SET_TO_CROSS_OF_FIRST_TWO_3(b, p1, coor)</span></a>
<a name="957"><span class="lineNum">     957 </span>            : </a>
<a name="958"><span class="lineNum">     958 </span><span class="lineCov">       7312 :         if (DEM_INNER_PRODUCT_3(coor, normal_element) &gt;= 0){</span></a>
<a name="959"><span class="lineNum">     959 </span><span class="lineCov">       7312 :             area = 0.5 * DEM_MODULUS_3(coor);</span></a>
<a name="960"><span class="lineNum">     960 </span><span class="lineCov">       7312 :             return true;</span></a>
<a name="961"><span class="lineNum">     961 </span>            :         }</a>
<a name="962"><span class="lineNum">     962 </span>            :         else return false;</a>
<a name="963"><span class="lineNum">     963 </span>            : </a>
<a name="964"><span class="lineNum">     964 </span>            :     }//InsideOutside</a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span>            :     static inline bool InsideOutside(const array_1d&lt;double, 3&gt; &amp;Coord1,</a>
<a name="967"><span class="lineNum">     967 </span>            :                                      const array_1d&lt;double, 3&gt;&amp; Coord2,</a>
<a name="968"><span class="lineNum">     968 </span>            :                                      const array_1d&lt;double, 3&gt;&amp; JudgeCoord,</a>
<a name="969"><span class="lineNum">     969 </span>            :                                      const array_1d&lt;double, 3&gt;&amp; normal_element) {</a>
<a name="970"><span class="lineNum">     970 </span>            : </a>
<a name="971"><span class="lineNum">     971 </span>            :         //NOTE:: Normal_out here has to be the normal of the element orientation (not pointing particle)</a>
<a name="972"><span class="lineNum">     972 </span>            :         array_1d&lt;double, 3&gt; cp1;</a>
<a name="973"><span class="lineNum">     973 </span>            :         array_1d&lt;double, 3&gt; b_a;</a>
<a name="974"><span class="lineNum">     974 </span>            :         array_1d&lt;double, 3&gt; p1_a;</a>
<a name="975"><span class="lineNum">     975 </span>            : </a>
<a name="976"><span class="lineNum">     976 </span>            :         noalias(b_a)  = Coord2 - Coord1;</a>
<a name="977"><span class="lineNum">     977 </span>            :         noalias(p1_a) = JudgeCoord - Coord1;</a>
<a name="978"><span class="lineNum">     978 </span>            : </a>
<a name="979"><span class="lineNum">     979 </span>            :         GeometryFunctions::CrossProduct(b_a, p1_a, cp1);</a>
<a name="980"><span class="lineNum">     980 </span>            : </a>
<a name="981"><span class="lineNum">     981 </span>            :         if (GeometryFunctions::DotProduct(cp1, normal_element) &gt;= 0)</a>
<a name="982"><span class="lineNum">     982 </span>            :         {</a>
<a name="983"><span class="lineNum">     983 </span>            :             //area = sqrt(cp1[0] * cp1[0] + cp1[1] * cp1[1] + cp1[2] * cp1[2]) * 0.5;</a>
<a name="984"><span class="lineNum">     984 </span>            :             return true;</a>
<a name="985"><span class="lineNum">     985 </span>            :         }</a>
<a name="986"><span class="lineNum">     986 </span>            :         else return false;</a>
<a name="987"><span class="lineNum">     987 </span>            : </a>
<a name="988"><span class="lineNum">     988 </span>            :     }//InsideOutside</a>
<a name="989"><span class="lineNum">     989 </span>            : </a>
<a name="990"><span class="lineNum">     990 </span><span class="lineCov">       1808 :     static inline void WeightsCalculation(std::vector&lt;double&gt; Area, std::vector&lt;double&gt;&amp; Weight)</span></a>
<a name="991"><span class="lineNum">     991 </span>            :     {</a>
<a name="992"><span class="lineNum">     992 </span><span class="lineCov">       1808 :         unsigned int facet_size = Area.size();</span></a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">       1808 :         if (facet_size == 3)</span></a>
<a name="994"><span class="lineNum">     994 </span>            :         {</a>
<a name="995"><span class="lineNum">     995 </span><span class="lineNoCov">          0 :             const double total_area = Area[0]+Area[1]+Area[2];</span></a>
<a name="996"><span class="lineNum">     996 </span><span class="lineNoCov">          0 :             const double inv_total_area = 1.0 / total_area;</span></a>
<a name="997"><span class="lineNum">     997 </span><span class="lineNoCov">          0 :             for (unsigned int i = 0; i&lt; 3; i++)</span></a>
<a name="998"><span class="lineNum">     998 </span>            :             {</a>
<a name="999"><span class="lineNum">     999 </span><span class="lineNoCov">          0 :                 Weight[i] = Area[(i+1)%facet_size] * inv_total_area;</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            :             }</a>
<a name="1001"><span class="lineNum">    1001 </span>            :         }</a>
<a name="1002"><span class="lineNum">    1002 </span><span class="lineCov">       1808 :         else if (facet_size == 4)</span></a>
<a name="1003"><span class="lineNum">    1003 </span>            :         {</a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">       1808 :             const double total_discriminant = Area[0]*Area[1]+Area[1]*Area[2]+Area[2]*Area[3]+Area[3]*Area[0]; //(Zhong et al 1993)</span></a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineCov">       1808 :             const double inv_total_discriminant = 1.0 / total_discriminant;</span></a>
<a name="1006"><span class="lineNum">    1006 </span><span class="lineCov">       9040 :             for (unsigned int i = 0; i&lt; 4; i++)</span></a>
<a name="1007"><span class="lineNum">    1007 </span>            :             {</a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineCov">       7232 :                 Weight[i] = (Area[(i+1)%facet_size]*Area[(i+2)%facet_size]) * inv_total_discriminant;</span></a>
<a name="1009"><span class="lineNum">    1009 </span>            :             }</a>
<a name="1010"><span class="lineNum">    1010 </span>            :         }</a>
<a name="1011"><span class="lineNum">    1011 </span>            :         else {</a>
<a name="1012"><span class="lineNum">    1012 </span>            :             KRATOS_WATCH(&quot;WEIGHTS FOR N-SIZE POLYGONAL FE TO BE IMPLEMENTED&quot;)</a>
<a name="1013"><span class="lineNum">    1013 </span>            :         }</a>
<a name="1014"><span class="lineNum">    1014 </span><span class="lineCov">       1808 :     }//WeightsCalculation</span></a>
<a name="1015"><span class="lineNum">    1015 </span>            : </a>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineCov">         22 :     static inline bool FastFacetCheck(const std::vector&lt; array_1d &lt;double,3&gt; &gt;&amp; Coord, const array_1d &lt;double,3&gt;&amp; Particle_Coord, double rad, double &amp;DistPToB, unsigned int &amp;current_edge_index)</span></a>
<a name="1017"><span class="lineNum">    1017 </span>            :     {</a>
<a name="1018"><span class="lineNum">    1018 </span>            :         double A[3];</a>
<a name="1019"><span class="lineNum">    1019 </span>            :         double B[3];</a>
<a name="1020"><span class="lineNum">    1020 </span>            :         double PC[3];</a>
<a name="1021"><span class="lineNum">    1021 </span>            : </a>
<a name="1022"><span class="lineNum">    1022 </span><span class="lineCov">         88 :         for (unsigned int i = 0; i &lt; 3; i++){</span></a>
<a name="1023"><span class="lineNum">    1023 </span><span class="lineCov">         66 :             B[i]  = Coord[0][i];</span></a>
<a name="1024"><span class="lineNum">    1024 </span><span class="lineCov">         66 :             PC[i] = Coord[1][i];</span></a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">         66 :             A[i]  = Coord[2][i];</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            :         }</a>
<a name="1027"><span class="lineNum">    1027 </span>            : </a>
<a name="1028"><span class="lineNum">    1028 </span><span class="lineCov">         88 :         for (unsigned int i = 0; i &lt; 3; i++){</span></a>
<a name="1029"><span class="lineNum">    1029 </span><span class="lineCov">         66 :             A[i] = A[i] - PC[i];</span></a>
<a name="1030"><span class="lineNum">    1030 </span><span class="lineCov">         66 :             B[i] = B[i] - PC[i];</span></a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineCov">         66 :             PC[i] = Particle_Coord[i] - PC[i];</span></a>
<a name="1032"><span class="lineNum">    1032 </span>            :         }</a>
<a name="1033"><span class="lineNum">    1033 </span>            : </a>
<a name="1034"><span class="lineNum">    1034 </span>            :         //Calculate Normal</a>
<a name="1035"><span class="lineNum">    1035 </span>            : </a>
<a name="1036"><span class="lineNum">    1036 </span>            :         double N_fast[3];</a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">         22 :         DEM_SET_TO_CROSS_OF_FIRST_TWO_3(A, B, N_fast)</span></a>
<a name="1038"><span class="lineNum">    1038 </span>            :         //normalize</a>
<a name="1039"><span class="lineNum">    1039 </span>            : </a>
<a name="1040"><span class="lineNum">    1040 </span>            :         double normal_flag = 1.0;</a>
<a name="1041"><span class="lineNum">    1041 </span>            : </a>
<a name="1042"><span class="lineNum">    1042 </span><span class="lineCov">         22 :         if (DEM_INNER_PRODUCT_3(PC, N_fast) &lt; 0){ //it is assumed that Indentation wont be greater than radius so we can detect contacts on both sides of the FE.</span></a>
<a name="1043"><span class="lineNum">    1043 </span>            :             normal_flag = -1.0;</a>
<a name="1044"><span class="lineNum">    1044 </span>            :         }</a>
<a name="1045"><span class="lineNum">    1045 </span>            : </a>
<a name="1046"><span class="lineNum">    1046 </span><span class="lineCov">         22 :         normalize(N_fast);</span></a>
<a name="1047"><span class="lineNum">    1047 </span>            : </a>
<a name="1048"><span class="lineNum">    1048 </span>            :         //Calculate distance:</a>
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<a name="1050"><span class="lineNum">    1050 </span><span class="lineCov">         22 :         DistPToB = 0.0;</span></a>
<a name="1051"><span class="lineNum">    1051 </span>            : </a>
<a name="1052"><span class="lineNum">    1052 </span><span class="lineCov">         88 :         for (unsigned int i = 0; i &lt; 3; i++){</span></a>
<a name="1053"><span class="lineNum">    1053 </span><span class="lineCov">         66 :             DistPToB += normal_flag * N_fast[i] * PC[i];</span></a>
<a name="1054"><span class="lineNum">    1054 </span>            :         }</a>
<a name="1055"><span class="lineNum">    1055 </span>            : </a>
<a name="1056"><span class="lineNum">    1056 </span><span class="lineCov">         22 :         if (DistPToB &lt; rad){</span></a>
<a name="1057"><span class="lineNum">    1057 </span>            :             array_1d &lt;double, 3&gt; IntersectionCoord;</a>
<a name="1058"><span class="lineNum">    1058 </span>            :             array_1d &lt;double, 3&gt; N;</a>
<a name="1059"><span class="lineNum">    1059 </span>            : </a>
<a name="1060"><span class="lineNum">    1060 </span><span class="lineCov">         80 :             for (unsigned int i = 0; i &lt; 3; i++){</span></a>
<a name="1061"><span class="lineNum">    1061 </span><span class="lineCov">         60 :                 IntersectionCoord[i] = Particle_Coord[i] - DistPToB * normal_flag * N_fast[i];</span></a>
<a name="1062"><span class="lineNum">    1062 </span><span class="lineCov">         60 :                 N[i] = N_fast[i];</span></a>
<a name="1063"><span class="lineNum">    1063 </span>            :             }</a>
<a name="1064"><span class="lineNum">    1064 </span>            : </a>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineCov">         20 :             int facet_size = Coord.size();</span></a>
<a name="1066"><span class="lineNum">    1066 </span>            : </a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineCov">        100 :             for (int i = 0; i &lt; facet_size; i++) {</span></a>
<a name="1068"><span class="lineNum">    1068 </span>            :                 double this_area = 0.0;</a>
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineCov">         80 :                 if (InsideOutside(Coord[i], Coord[(i+1)%facet_size], IntersectionCoord, N, this_area) == false){</span></a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                     current_edge_index = i;</span></a>
<a name="1072"><span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                     return false;</span></a>
<a name="1073"><span class="lineNum">    1073 </span>            :                 }</a>
<a name="1074"><span class="lineNum">    1074 </span>            :             }</a>
<a name="1075"><span class="lineNum">    1075 </span>            :             return true;</a>
<a name="1076"><span class="lineNum">    1076 </span>            :         }//if DistPToB &lt; rad</a>
<a name="1077"><span class="lineNum">    1077 </span>            : </a>
<a name="1078"><span class="lineNum">    1078 </span>            :         return false;</a>
<a name="1079"><span class="lineNum">    1079 </span>            :     }//FastFacetCheck</a>
<a name="1080"><span class="lineNum">    1080 </span>            : </a>
<a name="1081"><span class="lineNum">    1081 </span><span class="lineCov">       1808 :     static inline bool FacetCheck(const GeometryType&amp;  Coord, const array_1d &lt;double,3&gt;&amp; Particle_Coord, double rad,</span></a>
<a name="1082"><span class="lineNum">    1082 </span>            :                                   double LocalCoordSystem[3][3], double&amp; DistPToB, std::vector&lt;double&gt;&amp; Weight, unsigned int&amp; current_edge_index, bool&amp; inside)</a>
<a name="1083"><span class="lineNum">    1083 </span>            :     {</a>
<a name="1084"><span class="lineNum">    1084 </span><span class="lineCov">       1808 :         int facet_size = Coord.size();</span></a>
<a name="1085"><span class="lineNum">    1085 </span>            :         //Calculate Normal</a>
<a name="1086"><span class="lineNum">    1086 </span>            : </a>
<a name="1087"><span class="lineNum">    1087 </span>            :         array_1d &lt;double,3&gt; A;</a>
<a name="1088"><span class="lineNum">    1088 </span>            :         array_1d &lt;double,3&gt; B;</a>
<a name="1089"><span class="lineNum">    1089 </span>            :         array_1d &lt;double,3&gt; N;</a>
<a name="1090"><span class="lineNum">    1090 </span>            :         array_1d &lt;double,3&gt; PC;</a>
<a name="1091"><span class="lineNum">    1091 </span>            : </a>
<a name="1092"><span class="lineNum">    1092 </span><span class="lineCov">       7232 :         for (unsigned int i = 0; i&lt;3; i++)</span></a>
<a name="1093"><span class="lineNum">    1093 </span>            :         {</a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineCov">       5424 :             A[i] = Coord[2].Coordinates()[i]-Coord[1].Coordinates()[i];</span></a>
<a name="1095"><span class="lineNum">    1095 </span><span class="lineCov">       5424 :             B[i] = Coord[0].Coordinates()[i]-Coord[1].Coordinates()[i];</span></a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">       5424 :             PC[i] = Particle_Coord[i]-Coord[1].Coordinates()[i];</span></a>
<a name="1097"><span class="lineNum">    1097 </span>            :         }</a>
<a name="1098"><span class="lineNum">    1098 </span>            : </a>
<a name="1099"><span class="lineNum">    1099 </span><span class="lineCov">       1808 :         N[0] = A[1]*B[2] - A[2]*B[1];</span></a>
<a name="1100"><span class="lineNum">    1100 </span><span class="lineCov">       1808 :         N[1] = A[2]*B[0] - A[0]*B[2];</span></a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineCov">       1808 :         N[2] = A[0]*B[1] - A[1]*B[0];</span></a>
<a name="1102"><span class="lineNum">    1102 </span>            :         //normalize</a>
<a name="1103"><span class="lineNum">    1103 </span>            : </a>
<a name="1104"><span class="lineNum">    1104 </span><span class="lineCov">       1808 :         double normal_flag = 1.0;</span></a>
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<a name="1106"><span class="lineNum">    1106 </span><span class="lineCov">       1808 :         if (DotProduct(PC,N) &lt; 0) //it is assumed that Indentation wont be greater than radius so we can detect contacts on both sides of the FE.</span></a>
<a name="1107"><span class="lineNum">    1107 </span>            :         {</a>
<a name="1108"><span class="lineNum">    1108 </span><span class="lineCov">       1808 :             normal_flag = - 1.0;</span></a>
<a name="1109"><span class="lineNum">    1109 </span><span class="lineCov">       1808 :             N[0]=-N[0];</span></a>
<a name="1110"><span class="lineNum">    1110 </span><span class="lineCov">       1808 :             N[1]=-N[1];</span></a>
<a name="1111"><span class="lineNum">    1111 </span><span class="lineCov">       1808 :             N[2]=-N[2];</span></a>
<a name="1112"><span class="lineNum">    1112 </span>            :         }</a>
<a name="1113"><span class="lineNum">    1113 </span><span class="lineCov">       1808 :         normalize(N);</span></a>
<a name="1114"><span class="lineNum">    1114 </span>            : </a>
<a name="1115"><span class="lineNum">    1115 </span>            :         //Calculate distance:</a>
<a name="1116"><span class="lineNum">    1116 </span>            : </a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineCov">       1808 :         DistPToB = 0.0;</span></a>
<a name="1118"><span class="lineNum">    1118 </span>            : </a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">       7232 :         for (unsigned int i = 0; i&lt;3; i++)</span></a>
<a name="1120"><span class="lineNum">    1120 </span>            :         {</a>
<a name="1121"><span class="lineNum">    1121 </span><span class="lineCov">       5424 :             DistPToB += N[i]*PC[i];</span></a>
<a name="1122"><span class="lineNum">    1122 </span>            :         }</a>
<a name="1123"><span class="lineNum">    1123 </span>            : </a>
<a name="1124"><span class="lineNum">    1124 </span>            :         // Check if particle is inside Finite Element (even if contact is not possible, i.e. DistPToB &gt;= rad)</a>
<a name="1125"><span class="lineNum">    1125 </span>            :             array_1d &lt;double,3&gt; IntersectionCoord;</a>
<a name="1126"><span class="lineNum">    1126 </span>            : </a>
<a name="1127"><span class="lineNum">    1127 </span><span class="lineCov">       7232 :             for (unsigned int i = 0; i&lt;3; i++)</span></a>
<a name="1128"><span class="lineNum">    1128 </span>            :             {</a>
<a name="1129"><span class="lineNum">    1129 </span><span class="lineCov">       5424 :                 IntersectionCoord[i] = Particle_Coord[i] - DistPToB*N[i];</span></a>
<a name="1130"><span class="lineNum">    1130 </span>            :             }</a>
<a name="1131"><span class="lineNum">    1131 </span>            : </a>
<a name="1132"><span class="lineNum">    1132 </span>            :             std::vector&lt;double&gt; Area;</a>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineCov">       1808 :             Area.resize(facet_size);</span></a>
<a name="1134"><span class="lineNum">    1134 </span>            : </a>
<a name="1135"><span class="lineNum">    1135 </span><span class="lineCov">       9040 :             for (int i = 0; i&lt;facet_size; i++)</span></a>
<a name="1136"><span class="lineNum">    1136 </span>            :             {</a>
<a name="1137"><span class="lineNum">    1137 </span><span class="lineCov">       7232 :                 double this_area = 0.0;</span></a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineCov">       7232 :                 if (InsideOutside(Coord[i],</span></a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineCov">       7232 :                                   Coord[(i+1)%facet_size],</span></a>
<a name="1140"><span class="lineNum">    1140 </span>            :                                   IntersectionCoord,</a>
<a name="1141"><span class="lineNum">    1141 </span>            :                                   normal_flag*N,</a>
<a name="1142"><span class="lineNum">    1142 </span>            :                                   this_area) == false)</a>
<a name="1143"><span class="lineNum">    1143 </span>            :                 {</a>
<a name="1144"><span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                     current_edge_index = i;</span></a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                     inside = false;</span></a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                     return false;</span></a>
<a name="1147"><span class="lineNum">    1147 </span>            :                 }</a>
<a name="1148"><span class="lineNum">    1148 </span>            :                 else</a>
<a name="1149"><span class="lineNum">    1149 </span>            :                 {</a>
<a name="1150"><span class="lineNum">    1150 </span><span class="lineCov">       7232 :                     inside = true;</span></a>
<a name="1151"><span class="lineNum">    1151 </span><span class="lineCov">       7232 :                     Area[i] = this_area; //the area adjacent to vertex[ID] is assigned as Area[ID] so further treatment shall be done for the Weight calculation</span></a>
<a name="1152"><span class="lineNum">    1152 </span>            :                 }</a>
<a name="1153"><span class="lineNum">    1153 </span>            : </a>
<a name="1154"><span class="lineNum">    1154 </span>            :             }//for every vertex</a>
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<a name="1156"><span class="lineNum">    1156 </span><span class="lineCov">       1808 :         if (DistPToB &lt; rad)</span></a>
<a name="1157"><span class="lineNum">    1157 </span>            :         {</a>
<a name="1158"><span class="lineNum">    1158 </span>            :             double auxiliar_unit_vector[3];</a>
<a name="1159"><span class="lineNum">    1159 </span>            :             CrossProduct( N,A,auxiliar_unit_vector );</a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineCov">       1808 :             normalize( auxiliar_unit_vector );</span></a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">       1808 :             normalize( A );</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineCov">       7232 :             for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1163"><span class="lineNum">    1163 </span>            :             {</a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineCov">       5424 :                 LocalCoordSystem[0][j] = A[j];</span></a>
<a name="1165"><span class="lineNum">    1165 </span><span class="lineCov">       5424 :                 LocalCoordSystem[1][j] = auxiliar_unit_vector[j];</span></a>
<a name="1166"><span class="lineNum">    1166 </span><span class="lineCov">       5424 :                 LocalCoordSystem[2][j] = N[j];</span></a>
<a name="1167"><span class="lineNum">    1167 </span>            :             }</a>
<a name="1168"><span class="lineNum">    1168 </span>            : </a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineCov">       3616 :             WeightsCalculation(Area,Weight);</span></a>
<a name="1170"><span class="lineNum">    1170 </span>            :             return true;</a>
<a name="1171"><span class="lineNum">    1171 </span>            : </a>
<a name="1172"><span class="lineNum">    1172 </span>            :         }//if DistPToB &lt; rad</a>
<a name="1173"><span class="lineNum">    1173 </span>            : </a>
<a name="1174"><span class="lineNum">    1174 </span>            :         return false;</a>
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<a name="1176"><span class="lineNum">    1176 </span>            :     } //FacetCheck</a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span><span class="lineNoCov">          0 :     static inline bool FastEdgeVertexCheck(const array_1d&lt;double,3&gt;&amp; Coord1, const array_1d&lt;double,3&gt;&amp; Coord2, const array_1d&lt;double,3&gt;&amp; Particle_Coord, double Radius)</span></a>
<a name="1179"><span class="lineNum">    1179 </span>            :     {</a>
<a name="1180"><span class="lineNum">    1180 </span>            :         double IntersectionCoordEdge[3];</a>
<a name="1181"><span class="lineNum">    1181 </span>            :         double normal_unit_vector[3];</a>
<a name="1182"><span class="lineNum">    1182 </span>            :         double edge_unit_vector[3];</a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineNoCov">          0 :         double module_edge_vector = 0.0;</span></a>
<a name="1184"><span class="lineNum">    1184 </span>            :         double particle_vector1[3];</a>
<a name="1185"><span class="lineNum">    1185 </span>            :         double particle_vector2[3];</a>
<a name="1186"><span class="lineNum">    1186 </span>            : </a>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1188"><span class="lineNum">    1188 </span>            :         {</a>
<a name="1189"><span class="lineNum">    1189 </span><span class="lineNoCov">          0 :             edge_unit_vector[j] = Coord2[j] - Coord1[j];</span></a>
<a name="1190"><span class="lineNum">    1190 </span><span class="lineNoCov">          0 :             particle_vector1[j]  = Particle_Coord[j] - Coord1[j];</span></a>
<a name="1191"><span class="lineNum">    1191 </span><span class="lineNoCov">          0 :             particle_vector2[j]  = Particle_Coord[j] - Coord2[j];</span></a>
<a name="1192"><span class="lineNum">    1192 </span>            :         }</a>
<a name="1193"><span class="lineNum">    1193 </span>            : </a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         normalize( edge_unit_vector, module_edge_vector);</span></a>
<a name="1195"><span class="lineNum">    1195 </span>            :         double projection_on_edge = DotProduct(particle_vector1,edge_unit_vector);</a>
<a name="1196"><span class="lineNum">    1196 </span>            : </a>
<a name="1197"><span class="lineNum">    1197 </span><span class="lineNoCov">          0 :         double eta = projection_on_edge/module_edge_vector;</span></a>
<a name="1198"><span class="lineNum">    1198 </span>            : </a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineNoCov">          0 :         if ((eta&gt;=0.0) &amp;&amp; (eta&lt;=1.0)) //can only be edge, no vertex</span></a>
<a name="1200"><span class="lineNum">    1200 </span>            :         {</a>
<a name="1201"><span class="lineNum">    1201 </span><span class="lineNoCov">          0 :             for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1202"><span class="lineNum">    1202 </span>            :             {</a>
<a name="1203"><span class="lineNum">    1203 </span><span class="lineNoCov">          0 :                 IntersectionCoordEdge[j] = Coord1[j] + projection_on_edge*edge_unit_vector[j];</span></a>
<a name="1204"><span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                 normal_unit_vector[j]   = Particle_Coord[j] - IntersectionCoordEdge[j];</span></a>
<a name="1205"><span class="lineNum">    1205 </span>            :             }</a>
<a name="1206"><span class="lineNum">    1206 </span>            : </a>
<a name="1207"><span class="lineNum">    1207 </span>            :             double DistParticleToEdge;</a>
<a name="1208"><span class="lineNum">    1208 </span><span class="lineNoCov">          0 :             normalize( normal_unit_vector, DistParticleToEdge);</span></a>
<a name="1209"><span class="lineNum">    1209 </span>            : </a>
<a name="1210"><span class="lineNum">    1210 </span><span class="lineNoCov">          0 :             if (DistParticleToEdge &lt; Radius)</span></a>
<a name="1211"><span class="lineNum">    1211 </span>            :             {</a>
<a name="1212"><span class="lineNum">    1212 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="1213"><span class="lineNum">    1213 </span>            :             }</a>
<a name="1214"><span class="lineNum">    1214 </span>            :         }</a>
<a name="1215"><span class="lineNum">    1215 </span>            : </a>
<a name="1216"><span class="lineNum">    1216 </span><span class="lineNoCov">          0 :         if (eta &lt; 0.0)  //1rst Vertex</span></a>
<a name="1217"><span class="lineNum">    1217 </span>            :         {</a>
<a name="1218"><span class="lineNum">    1218 </span>            :             double dist_to_vertex_sq = 0.0;</a>
<a name="1219"><span class="lineNum">    1219 </span><span class="lineNoCov">          0 :             double Rad_sq = Radius*Radius;</span></a>
<a name="1220"><span class="lineNum">    1220 </span>            : </a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineNoCov">          0 :             for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            :             {</a>
<a name="1223"><span class="lineNum">    1223 </span><span class="lineNoCov">          0 :                 dist_to_vertex_sq +=particle_vector1[j]*particle_vector1[j];</span></a>
<a name="1224"><span class="lineNum">    1224 </span>            :             }</a>
<a name="1225"><span class="lineNum">    1225 </span>            : </a>
<a name="1226"><span class="lineNum">    1226 </span><span class="lineNoCov">          0 :             if (dist_to_vertex_sq &lt; Rad_sq)</span></a>
<a name="1227"><span class="lineNum">    1227 </span>            :             {</a>
<a name="1228"><span class="lineNum">    1228 </span>            :                 return true;</a>
<a name="1229"><span class="lineNum">    1229 </span>            :             }</a>
<a name="1230"><span class="lineNum">    1230 </span>            :         }</a>
<a name="1231"><span class="lineNum">    1231 </span>            : </a>
<a name="1232"><span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         if (eta &gt; 1.0)  //2n vertex</span></a>
<a name="1233"><span class="lineNum">    1233 </span>            :         {</a>
<a name="1234"><span class="lineNum">    1234 </span>            :             double dist_to_vertex_sq = 0.0;</a>
<a name="1235"><span class="lineNum">    1235 </span><span class="lineNoCov">          0 :             double Rad_sq = Radius*Radius;</span></a>
<a name="1236"><span class="lineNum">    1236 </span><span class="lineNoCov">          0 :             for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1237"><span class="lineNum">    1237 </span>            :             {</a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                 dist_to_vertex_sq +=particle_vector2[j]*particle_vector2[j];</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            :             }</a>
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<a name="1241"><span class="lineNum">    1241 </span><span class="lineNoCov">          0 :             if (dist_to_vertex_sq &lt; Rad_sq)</span></a>
<a name="1242"><span class="lineNum">    1242 </span>            :             {</a>
<a name="1243"><span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                 return true;</span></a>
<a name="1244"><span class="lineNum">    1244 </span>            :             }</a>
<a name="1245"><span class="lineNum">    1245 </span>            :         }</a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span>            :         return false;</a>
<a name="1248"><span class="lineNum">    1248 </span>            : </a>
<a name="1249"><span class="lineNum">    1249 </span>            :     }//FastEdgeVertexCheck;</a>
<a name="1250"><span class="lineNum">    1250 </span>            : </a>
<a name="1251"><span class="lineNum">    1251 </span><span class="lineNoCov">          0 :     static inline bool EdgeCheck(const array_1d&lt;double,3&gt;&amp; Coord1, const array_1d&lt;double,3&gt;&amp; Coord2, const array_1d&lt;double,3&gt;&amp; Particle_Coord, double Radius,</span></a>
<a name="1252"><span class="lineNum">    1252 </span>            :                                   double LocalCoordSystem[3][3], double&amp; DistParticleToEdge, double&amp; eta)</a>
<a name="1253"><span class="lineNum">    1253 </span>            :     {</a>
<a name="1254"><span class="lineNum">    1254 </span>            :         double IntersectionCoordEdge[3];</a>
<a name="1255"><span class="lineNum">    1255 </span>            :         double normal_unit_vector[3];</a>
<a name="1256"><span class="lineNum">    1256 </span>            :         double edge_unit_vector[3];</a>
<a name="1257"><span class="lineNum">    1257 </span><span class="lineNoCov">          0 :         double module_edge_vector = 0.0;</span></a>
<a name="1258"><span class="lineNum">    1258 </span>            :         double particle_vector[3];</a>
<a name="1259"><span class="lineNum">    1259 </span>            : </a>
<a name="1260"><span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1261"><span class="lineNum">    1261 </span>            :         {</a>
<a name="1262"><span class="lineNum">    1262 </span><span class="lineNoCov">          0 :             edge_unit_vector[j] = Coord2[j] - Coord1[j];</span></a>
<a name="1263"><span class="lineNum">    1263 </span><span class="lineNoCov">          0 :             particle_vector[j]  = Particle_Coord[j] - Coord1[j];</span></a>
<a name="1264"><span class="lineNum">    1264 </span>            :         }</a>
<a name="1265"><span class="lineNum">    1265 </span>            : </a>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineNoCov">          0 :         normalize(edge_unit_vector, module_edge_vector);</span></a>
<a name="1267"><span class="lineNum">    1267 </span>            :         double projection_on_edge = DotProduct(particle_vector,edge_unit_vector);</a>
<a name="1268"><span class="lineNum">    1268 </span>            : </a>
<a name="1269"><span class="lineNum">    1269 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1270"><span class="lineNum">    1270 </span>            :         {</a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineNoCov">          0 :             IntersectionCoordEdge[j] = Coord1[j] + projection_on_edge*edge_unit_vector[j];</span></a>
<a name="1272"><span class="lineNum">    1272 </span><span class="lineNoCov">          0 :             normal_unit_vector[j]   = Particle_Coord[j] - IntersectionCoordEdge[j];</span></a>
<a name="1273"><span class="lineNum">    1273 </span>            :         }</a>
<a name="1274"><span class="lineNum">    1274 </span>            : </a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         normalize( normal_unit_vector, DistParticleToEdge);</span></a>
<a name="1276"><span class="lineNum">    1276 </span>            : </a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         eta = projection_on_edge / module_edge_vector;</span></a>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         if (DistParticleToEdge &lt; Radius)</span></a>
<a name="1280"><span class="lineNum">    1280 </span>            :         {</a>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineNoCov">          0 :             if ((eta&gt;=0.0) &amp;&amp; (eta&lt;=1.0))</span></a>
<a name="1282"><span class="lineNum">    1282 </span>            :             {</a>
<a name="1283"><span class="lineNum">    1283 </span>            :                 double dummy_length = 0.0;</a>
<a name="1284"><span class="lineNum">    1284 </span>            :                 double auxiliar_unit_vector[3];</a>
<a name="1285"><span class="lineNum">    1285 </span>            :                 CrossProduct(normal_unit_vector,edge_unit_vector,auxiliar_unit_vector);</a>
<a name="1286"><span class="lineNum">    1286 </span><span class="lineNoCov">          0 :                 normalize(auxiliar_unit_vector, dummy_length);</span></a>
<a name="1287"><span class="lineNum">    1287 </span>            : </a>
<a name="1288"><span class="lineNum">    1288 </span><span class="lineNoCov">          0 :                 for (unsigned int j = 0; j&lt;3; j++)</span></a>
<a name="1289"><span class="lineNum">    1289 </span>            :                 {</a>
<a name="1290"><span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                     LocalCoordSystem[0][j] = edge_unit_vector[j];</span></a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                     LocalCoordSystem[1][j] = auxiliar_unit_vector[j];</span></a>
<a name="1292"><span class="lineNum">    1292 </span><span class="lineNoCov">          0 :                     LocalCoordSystem[2][j] = normal_unit_vector[j];</span></a>
<a name="1293"><span class="lineNum">    1293 </span>            :                 }</a>
<a name="1294"><span class="lineNum">    1294 </span>            : </a>
<a name="1295"><span class="lineNum">    1295 </span>            :                 return true;</a>
<a name="1296"><span class="lineNum">    1296 </span>            :             }</a>
<a name="1297"><span class="lineNum">    1297 </span>            :         } //if distance to edge &lt; radius</a>
<a name="1298"><span class="lineNum">    1298 </span>            : </a>
<a name="1299"><span class="lineNum">    1299 </span>            :         return false;</a>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<a name="1301"><span class="lineNum">    1301 </span>            :     }//EdgeCheck</a>
<a name="1302"><span class="lineNum">    1302 </span>            : </a>
<a name="1303"><span class="lineNum">    1303 </span><span class="lineNoCov">          0 :     static inline bool VertexCheck(const array_1d&lt;double,3&gt;&amp; Coord, const array_1d&lt;double,3&gt;&amp; Particle_Coord, double Radius, double LocalCoordSystem[3][3], double&amp; DistParticleToVertex)</span></a>
<a name="1304"><span class="lineNum">    1304 </span>            :     {</a>
<a name="1305"><span class="lineNum">    1305 </span>            :         double dist_sq = 0.0;</a>
<a name="1306"><span class="lineNum">    1306 </span>            :         array_1d&lt;double, 3&gt; normal_v;</a>
<a name="1307"><span class="lineNum">    1307 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j &lt; 3; j++)</span></a>
<a name="1308"><span class="lineNum">    1308 </span>            :         {</a>
<a name="1309"><span class="lineNum">    1309 </span><span class="lineNoCov">          0 :             normal_v[j] = Particle_Coord[j] - Coord[j];</span></a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineNoCov">          0 :             dist_sq += normal_v[j] * normal_v[j];</span></a>
<a name="1311"><span class="lineNum">    1311 </span>            :         }</a>
<a name="1312"><span class="lineNum">    1312 </span><span class="lineNoCov">          0 :         if (dist_sq &lt;= Radius * Radius)</span></a>
<a name="1313"><span class="lineNum">    1313 </span>            :         {</a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineNoCov">          0 :             DistParticleToVertex = sqrt(dist_sq);</span></a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineNoCov">          0 :             ComputeContactLocalCoordSystem(normal_v, DistParticleToVertex, LocalCoordSystem);</span></a>
<a name="1316"><span class="lineNum">    1316 </span><span class="lineNoCov">          0 :             return true;</span></a>
<a name="1317"><span class="lineNum">    1317 </span>            :         }</a>
<a name="1318"><span class="lineNum">    1318 </span>            :         return false;</a>
<a name="1319"><span class="lineNum">    1319 </span>            :     }//VertexCheck</a>
<a name="1320"><span class="lineNum">    1320 </span>            : </a>
<a name="1321"><span class="lineNum">    1321 </span>            : </a>
<a name="1322"><span class="lineNum">    1322 </span>            :     static inline bool FastVertexCheck(const array_1d&lt;double,3&gt;&amp; Coord, const array_1d&lt;double,3&gt;&amp; Particle_Coord, double Radius)</a>
<a name="1323"><span class="lineNum">    1323 </span>            :     {</a>
<a name="1324"><span class="lineNum">    1324 </span>            :         double dist_sq = 0.0;</a>
<a name="1325"><span class="lineNum">    1325 </span>            :         array_1d&lt;double, 3&gt; normal_v;</a>
<a name="1326"><span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         for (unsigned int j = 0; j &lt; 3; j++)</span></a>
<a name="1327"><span class="lineNum">    1327 </span>            :         {</a>
<a name="1328"><span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             normal_v[j] = Particle_Coord[j] - Coord[j];</span></a>
<a name="1329"><span class="lineNum">    1329 </span><span class="lineNoCov">          0 :             dist_sq += normal_v[j] * normal_v[j];</span></a>
<a name="1330"><span class="lineNum">    1330 </span>            :         }</a>
<a name="1331"><span class="lineNum">    1331 </span><span class="lineNoCov">          0 :         if (dist_sq &lt;= Radius * Radius) return true;</span></a>
<a name="1332"><span class="lineNum">    1332 </span>            :         return false;</a>
<a name="1333"><span class="lineNum">    1333 </span>            :     }//FastVertexCheck</a>
<a name="1334"><span class="lineNum">    1334 </span>            : </a>
<a name="1335"><span class="lineNum">    1335 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1336"><span class="lineNum">    1336 </span>            :     ///////////////******The four Functions BELOW are used to calculate the weight coefficient for quadrilateral*******///////////</a>
<a name="1337"><span class="lineNum">    1337 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1338"><span class="lineNum">    1338 </span>            :     /*static inline void Coord_transform(double origin[3], double coordsystem[3][3], double Coord[3], double TransCoord[3])</a>
<a name="1339"><span class="lineNum">    1339 </span>            :     {</a>
<a name="1340"><span class="lineNum">    1340 </span>            :         TransCoord[0]=0.0;</a>
<a name="1341"><span class="lineNum">    1341 </span>            :         TransCoord[1]=0.0;</a>
<a name="1342"><span class="lineNum">    1342 </span>            :         TransCoord[2]=0.0;</a>
<a name="1343"><span class="lineNum">    1343 </span>            :         double vector[3];</a>
<a name="1344"><span class="lineNum">    1344 </span>            :         vector[0]=Coord[0] - origin[0];</a>
<a name="1345"><span class="lineNum">    1345 </span>            :         vector[1]=Coord[1] - origin[1];</a>
<a name="1346"><span class="lineNum">    1346 </span>            :         vector[2]=Coord[2] - origin[2];</a>
<a name="1347"><span class="lineNum">    1347 </span>            :         TransCoord[0]=DotProduct(coordsystem[0],vector);</a>
<a name="1348"><span class="lineNum">    1348 </span>            :         TransCoord[1]=DotProduct(coordsystem[1],vector);</a>
<a name="1349"><span class="lineNum">    1349 </span>            :         TransCoord[2]=DotProduct(coordsystem[2],vector);</a>
<a name="1350"><span class="lineNum">    1350 </span>            :     }*/</a>
<a name="1351"><span class="lineNum">    1351 </span>            : </a>
<a name="1352"><span class="lineNum">    1352 </span>            :     /*static inline void N44(double xp,double yp,double xy[4][2],double&amp; N1,double&amp; N2,double&amp; N3,double&amp; N4)</a>
<a name="1353"><span class="lineNum">    1353 </span>            :     {</a>
<a name="1354"><span class="lineNum">    1354 </span>            :         double xc=(xy[0][0]+xy[1][0]+xy[2][0]+xy[3][0])/4.0;</a>
<a name="1355"><span class="lineNum">    1355 </span>            :         double yc=(xy[0][1]+xy[1][1]+xy[2][1]+xy[3][1])/4.0;</a>
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<a name="1357"><span class="lineNum">    1357 </span>            :         double elelength_x=2.0*fabs(xy[0][0]-xc);</a>
<a name="1358"><span class="lineNum">    1358 </span>            :         double elelength_y=2.0*fabs(xy[0][1]-yc);</a>
<a name="1359"><span class="lineNum">    1359 </span>            : </a>
<a name="1360"><span class="lineNum">    1360 </span>            :         double Eps,Ita;</a>
<a name="1361"><span class="lineNum">    1361 </span>            :         Eps=2.0*(xp-xc)/elelength_x;</a>
<a name="1362"><span class="lineNum">    1362 </span>            :         Ita=2.0*(yp-yc)/elelength_y;</a>
<a name="1363"><span class="lineNum">    1363 </span>            :         N1=0.25*(1+Eps*2*(xy[0][0]-xc)/elelength_x)*(1+Ita*2*(xy[0][1]-yc)/elelength_y);</a>
<a name="1364"><span class="lineNum">    1364 </span>            :         N2=0.25*(1+Eps*2*(xy[1][0]-xc)/elelength_x)*(1+Ita*2*(xy[1][1]-yc)/elelength_y);</a>
<a name="1365"><span class="lineNum">    1365 </span>            :         N3=0.25*(1+Eps*2*(xy[2][0]-xc)/elelength_x)*(1+Ita*2*(xy[2][1]-yc)/elelength_y);</a>
<a name="1366"><span class="lineNum">    1366 </span>            :         N4=0.25*(1+Eps*2*(xy[3][0]-xc)/elelength_x)*(1+Ita*2*(xy[3][1]-yc)/elelength_y);</a>
<a name="1367"><span class="lineNum">    1367 </span>            :     }*/</a>
<a name="1368"><span class="lineNum">    1368 </span>            : </a>
<a name="1369"><span class="lineNum">    1369 </span>            :     //Cfeng: irregular quadrilateral transfer to regular quadrilateral</a>
<a name="1370"><span class="lineNum">    1370 </span>            :     /*static inline void gl_to_iso(double x0, double y0, double xy[4][2], double&amp; x_exisp, double&amp; y_etasp)</a>
<a name="1371"><span class="lineNum">    1371 </span>            :     {</a>
<a name="1372"><span class="lineNum">    1372 </span>            :         double exisp=0.0;</a>
<a name="1373"><span class="lineNum">    1373 </span>            :         double etasp=0.0;</a>
<a name="1374"><span class="lineNum">    1374 </span>            :         double tolerance=1.0e-8;</a>
<a name="1375"><span class="lineNum">    1375 </span>            :         double x,y,x1,x2,x3,x4,y1,y2,y3,y4,a1,a2,a3,a4,b1,b2,b3,b4,s1,t1,d1,g1,g2,g0;</a>
<a name="1376"><span class="lineNum">    1376 </span>            :         x1 = xy[0][0];</a>
<a name="1377"><span class="lineNum">    1377 </span>            :         x2 = xy[1][0];</a>
<a name="1378"><span class="lineNum">    1378 </span>            :         x3 = xy[2][0];</a>
<a name="1379"><span class="lineNum">    1379 </span>            :         x4 = xy[3][0];</a>
<a name="1380"><span class="lineNum">    1380 </span>            :         y1 = xy[0][1];</a>
<a name="1381"><span class="lineNum">    1381 </span>            :         y2 = xy[1][1];</a>
<a name="1382"><span class="lineNum">    1382 </span>            :         y3 = xy[2][1];</a>
<a name="1383"><span class="lineNum">    1383 </span>            :         y4 = xy[3][1];</a>
<a name="1384"><span class="lineNum">    1384 </span>            :         a1=0.25*(-x1+x2+x3-x4);</a>
<a name="1385"><span class="lineNum">    1385 </span>            :         a2=0.25*(x1-x2+x3-x4);</a>
<a name="1386"><span class="lineNum">    1386 </span>            :         a3=0.25*(-x1-x2+x3+x4);</a>
<a name="1387"><span class="lineNum">    1387 </span>            :         a4=0.25*(x1+x2+x3+x4);</a>
<a name="1388"><span class="lineNum">    1388 </span>            :         b1=0.25*(-y1+y2+y3-y4);</a>
<a name="1389"><span class="lineNum">    1389 </span>            :         b2=0.25*(y1-y2+y3-y4);</a>
<a name="1390"><span class="lineNum">    1390 </span>            :         b3=0.25*(-y1-y2+y3+y4);</a>
<a name="1391"><span class="lineNum">    1391 </span>            :         b4=0.25*(y1+y2+y3+y4);</a>
<a name="1392"><span class="lineNum">    1392 </span>            : </a>
<a name="1393"><span class="lineNum">    1393 </span>            :         x = x0 - a4;</a>
<a name="1394"><span class="lineNum">    1394 </span>            :         y = y0 - b4;</a>
<a name="1395"><span class="lineNum">    1395 </span>            :         s1 = a2*b3 - a3*b2;</a>
<a name="1396"><span class="lineNum">    1396 </span>            :         t1 = b2*x - a2*y + a1*b3 - a3*b1;</a>
<a name="1397"><span class="lineNum">    1397 </span>            :         d1 = b1*x - a1*y;</a>
<a name="1398"><span class="lineNum">    1398 </span>            : </a>
<a name="1399"><span class="lineNum">    1399 </span>            :         if (fabs(s1) &lt; tolerance)</a>
<a name="1400"><span class="lineNum">    1400 </span>            :         {</a>
<a name="1401"><span class="lineNum">    1401 </span>            :             etasp = -d1/t1;</a>
<a name="1402"><span class="lineNum">    1402 </span>            :             exisp = (x-a3*etasp) / (a1+a2*etasp);</a>
<a name="1403"><span class="lineNum">    1403 </span>            :         }</a>
<a name="1404"><span class="lineNum">    1404 </span>            :         else</a>
<a name="1405"><span class="lineNum">    1405 </span>            :         {</a>
<a name="1406"><span class="lineNum">    1406 </span>            :             const double sqrt_aux = sqrt(t1*t1-4*s1*d1);</a>
<a name="1407"><span class="lineNum">    1407 </span>            :             g1 = (-t1 + sqrt_aux) / (2*s1);</a>
<a name="1408"><span class="lineNum">    1408 </span>            :             g2 = (-t1 - sqrt_aux) / (2*s1);</a>
<a name="1409"><span class="lineNum">    1409 </span>            :             if (fabs(g1) &lt; 1.0+tolerance)</a>
<a name="1410"><span class="lineNum">    1410 </span>            :             {</a>
<a name="1411"><span class="lineNum">    1411 </span>            :                 g0 = (x-a3*g1) / (a1+a2*g1);</a>
<a name="1412"><span class="lineNum">    1412 </span>            :                 if (fabs(g0) &lt; 1.0+tolerance)</a>
<a name="1413"><span class="lineNum">    1413 </span>            :                 {</a>
<a name="1414"><span class="lineNum">    1414 </span>            :                     etasp = g1;</a>
<a name="1415"><span class="lineNum">    1415 </span>            :                     exisp = g0;</a>
<a name="1416"><span class="lineNum">    1416 </span>            :                 }</a>
<a name="1417"><span class="lineNum">    1417 </span>            :             }</a>
<a name="1418"><span class="lineNum">    1418 </span>            :             if(fabs(g2) &lt; 1.0+tolerance)</a>
<a name="1419"><span class="lineNum">    1419 </span>            :             {</a>
<a name="1420"><span class="lineNum">    1420 </span>            :                 g0 = (x-a3*g2) / (a1+a2*g2);</a>
<a name="1421"><span class="lineNum">    1421 </span>            :                 if(fabs(g0) &lt; 1.0+tolerance)</a>
<a name="1422"><span class="lineNum">    1422 </span>            :                 {</a>
<a name="1423"><span class="lineNum">    1423 </span>            :                     etasp = g2;</a>
<a name="1424"><span class="lineNum">    1424 </span>            :                     exisp = g0;</a>
<a name="1425"><span class="lineNum">    1425 </span>            :                 }</a>
<a name="1426"><span class="lineNum">    1426 </span>            :             }</a>
<a name="1427"><span class="lineNum">    1427 </span>            :         }</a>
<a name="1428"><span class="lineNum">    1428 </span>            :         x_exisp=exisp;</a>
<a name="1429"><span class="lineNum">    1429 </span>            :         y_etasp=etasp;</a>
<a name="1430"><span class="lineNum">    1430 </span>            :     }*/</a>
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<a name="1432"><span class="lineNum">    1432 </span>            :     /*static void CalQuadWeightCoefficient(double Coord[4][3], double LocalCoordSystem[3][3], double IntersectionCoord[3], double Weight[4])</a>
<a name="1433"><span class="lineNum">    1433 </span>            :     {</a>
<a name="1434"><span class="lineNum">    1434 </span>            : </a>
<a name="1435"><span class="lineNum">    1435 </span>            : </a>
<a name="1436"><span class="lineNum">    1436 </span>            :         int j;</a>
<a name="1437"><span class="lineNum">    1437 </span>            : </a>
<a name="1438"><span class="lineNum">    1438 </span>            :         double FaceCenter[3] = {0.0};</a>
<a name="1439"><span class="lineNum">    1439 </span>            :         for(j = 0; j &lt; 4; j++)</a>
<a name="1440"><span class="lineNum">    1440 </span>            :         {</a>
<a name="1441"><span class="lineNum">    1441 </span>            :             FaceCenter[0] += Coord[j][0] * 0.25;</a>
<a name="1442"><span class="lineNum">    1442 </span>            :             FaceCenter[1] += Coord[j][1] * 0.25;</a>
<a name="1443"><span class="lineNum">    1443 </span>            :             FaceCenter[2] += Coord[j][2] * 0.25;</a>
<a name="1444"><span class="lineNum">    1444 </span>            :         }</a>
<a name="1445"><span class="lineNum">    1445 </span>            : </a>
<a name="1446"><span class="lineNum">    1446 </span>            :         double TransCoord0[3],TransCoord1[3],TransCoord2[3],TransCoord3[3];</a>
<a name="1447"><span class="lineNum">    1447 </span>            :         double xy[4][2];</a>
<a name="1448"><span class="lineNum">    1448 </span>            :         double xy1[4][2]={{-1.0,-1.0},{1.0,-1.0},{1.0,1.0},{-1.0,1.0}};</a>
<a name="1449"><span class="lineNum">    1449 </span>            : </a>
<a name="1450"><span class="lineNum">    1450 </span>            : </a>
<a name="1451"><span class="lineNum">    1451 </span>            :         double TempLocalCoordSystem[3][3]={{0.0}, {0.0}, {0.0}};</a>
<a name="1452"><span class="lineNum">    1452 </span>            :         double vx[3]={1.0,0,0},vy[3]={0,1.0,0},vz[3]={0, 0, 1.0};</a>
<a name="1453"><span class="lineNum">    1453 </span>            : </a>
<a name="1454"><span class="lineNum">    1454 </span>            :         if( DotProduct(LocalCoordSystem[2],vx)&lt;0 || DotProduct(LocalCoordSystem[2],vy)&lt;0 || DotProduct(LocalCoordSystem[2],vz)&lt;0 )</a>
<a name="1455"><span class="lineNum">    1455 </span>            :         {</a>
<a name="1456"><span class="lineNum">    1456 </span>            :             for(j=0;j&lt;3;j++)</a>
<a name="1457"><span class="lineNum">    1457 </span>            :             {</a>
<a name="1458"><span class="lineNum">    1458 </span>            :                 TempLocalCoordSystem[0][j] =  LocalCoordSystem[0][j];</a>
<a name="1459"><span class="lineNum">    1459 </span>            :                 TempLocalCoordSystem[1][j] =  LocalCoordSystem[1][j];</a>
<a name="1460"><span class="lineNum">    1460 </span>            :                 TempLocalCoordSystem[2][j] = -LocalCoordSystem[2][j];</a>
<a name="1461"><span class="lineNum">    1461 </span>            :             }</a>
<a name="1462"><span class="lineNum">    1462 </span>            :         }</a>
<a name="1463"><span class="lineNum">    1463 </span>            : </a>
<a name="1464"><span class="lineNum">    1464 </span>            : </a>
<a name="1465"><span class="lineNum">    1465 </span>            : </a>
<a name="1466"><span class="lineNum">    1466 </span>            :         else</a>
<a name="1467"><span class="lineNum">    1467 </span>            :         {</a>
<a name="1468"><span class="lineNum">    1468 </span>            :             for(j=0;j&lt;3;j++)</a>
<a name="1469"><span class="lineNum">    1469 </span>            :             {</a>
<a name="1470"><span class="lineNum">    1470 </span>            :                 TempLocalCoordSystem[0][j] = LocalCoordSystem[0][j];</a>
<a name="1471"><span class="lineNum">    1471 </span>            :                 TempLocalCoordSystem[1][j] = LocalCoordSystem[1][j];</a>
<a name="1472"><span class="lineNum">    1472 </span>            :                 TempLocalCoordSystem[2][j] = LocalCoordSystem[2][j];</a>
<a name="1473"><span class="lineNum">    1473 </span>            :             }</a>
<a name="1474"><span class="lineNum">    1474 </span>            :         }</a>
<a name="1475"><span class="lineNum">    1475 </span>            : </a>
<a name="1476"><span class="lineNum">    1476 </span>            : </a>
<a name="1477"><span class="lineNum">    1477 </span>            :         Coord_transform(FaceCenter, TempLocalCoordSystem, Coord[0], TransCoord0);</a>
<a name="1478"><span class="lineNum">    1478 </span>            :         Coord_transform(FaceCenter, TempLocalCoordSystem, Coord[1], TransCoord1);</a>
<a name="1479"><span class="lineNum">    1479 </span>            :         Coord_transform(FaceCenter, TempLocalCoordSystem, Coord[2], TransCoord2);</a>
<a name="1480"><span class="lineNum">    1480 </span>            :         Coord_transform(FaceCenter, TempLocalCoordSystem, Coord[3], TransCoord3);</a>
<a name="1481"><span class="lineNum">    1481 </span>            : </a>
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<a name="1483"><span class="lineNum">    1483 </span>            :         xy[0][0] = TransCoord0[0]; xy[0][1] = TransCoord0[1];</a>
<a name="1484"><span class="lineNum">    1484 </span>            :         xy[1][0] = TransCoord1[0]; xy[1][1] = TransCoord1[1];</a>
<a name="1485"><span class="lineNum">    1485 </span>            :         xy[2][0] = TransCoord2[0]; xy[2][1] = TransCoord2[1];</a>
<a name="1486"><span class="lineNum">    1486 </span>            :         xy[3][0] = TransCoord3[0]; xy[3][1] = TransCoord3[1];</a>
<a name="1487"><span class="lineNum">    1487 </span>            : </a>
<a name="1488"><span class="lineNum">    1488 </span>            :         double in0=0.0, in1=0.0, in2=0.0, in3=0.0;</a>
<a name="1489"><span class="lineNum">    1489 </span>            :         double TransCoordp[3];</a>
<a name="1490"><span class="lineNum">    1490 </span>            :         double Coordp_iso[2];</a>
<a name="1491"><span class="lineNum">    1491 </span>            : </a>
<a name="1492"><span class="lineNum">    1492 </span>            : </a>
<a name="1493"><span class="lineNum">    1493 </span>            :         Coord_transform(FaceCenter, TempLocalCoordSystem, IntersectionCoord, TransCoordp);</a>
<a name="1494"><span class="lineNum">    1494 </span>            : </a>
<a name="1495"><span class="lineNum">    1495 </span>            :         gl_to_iso(TransCoordp[0],TransCoordp[1],xy,Coordp_iso[0],Coordp_iso[1]);</a>
<a name="1496"><span class="lineNum">    1496 </span>            : </a>
<a name="1497"><span class="lineNum">    1497 </span>            :         N44(Coordp_iso[0],Coordp_iso[1], xy1, in0, in1, in2, in3);</a>
<a name="1498"><span class="lineNum">    1498 </span>            : </a>
<a name="1499"><span class="lineNum">    1499 </span>            :         Weight[0]=in0;</a>
<a name="1500"><span class="lineNum">    1500 </span>            :         Weight[1]=in1;</a>
<a name="1501"><span class="lineNum">    1501 </span>            :         Weight[2]=in2;</a>
<a name="1502"><span class="lineNum">    1502 </span>            :         Weight[3]=in3;</a>
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<a name="1504"><span class="lineNum">    1504 </span>            : </a>
<a name="1505"><span class="lineNum">    1505 </span>            : </a>
<a name="1506"><span class="lineNum">    1506 </span>            :     }*/</a>
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<a name="1508"><span class="lineNum">    1508 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1509"><span class="lineNum">    1509 </span>            :     ///////////////******The four Functions ABOVE are used to calculate the weight coefficient for quadrilateral*******///////////</a>
<a name="1510"><span class="lineNum">    1510 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1511"><span class="lineNum">    1511 </span>            : </a>
<a name="1512"><span class="lineNum">    1512 </span>            :     static inline void GetRotationMatrix(const array_1d&lt;double, 3&gt;&amp; EulerAngles, double rotation_matrix[3][3]) {</a>
<a name="1513"><span class="lineNum">    1513 </span>            : </a>
<a name="1514"><span class="lineNum">    1514 </span>            :         double cosA=cos(EulerAngles[0]);</a>
<a name="1515"><span class="lineNum">    1515 </span>            :         double sinA=sin(EulerAngles[0]);</a>
<a name="1516"><span class="lineNum">    1516 </span>            :         double cosB=cos(EulerAngles[1]);</a>
<a name="1517"><span class="lineNum">    1517 </span>            :         double sinB=sin(EulerAngles[1]);</a>
<a name="1518"><span class="lineNum">    1518 </span>            :         double cosC=cos(EulerAngles[2]);</a>
<a name="1519"><span class="lineNum">    1519 </span>            :         double sinC=sin(EulerAngles[2]);</a>
<a name="1520"><span class="lineNum">    1520 </span>            : </a>
<a name="1521"><span class="lineNum">    1521 </span>            :         rotation_matrix[0][0] = cosC*cosA - cosB*sinA*sinC;</a>
<a name="1522"><span class="lineNum">    1522 </span>            :         rotation_matrix[0][1] = -sinC*cosA - cosB*sinA*cosC;</a>
<a name="1523"><span class="lineNum">    1523 </span>            :         rotation_matrix[0][2] = sinB*sinA;</a>
<a name="1524"><span class="lineNum">    1524 </span>            :         rotation_matrix[1][0] = cosC*sinA + cosB*cosA*sinC;</a>
<a name="1525"><span class="lineNum">    1525 </span>            :         rotation_matrix[1][1] = -sinC*sinA + cosB*cosA*cosC;</a>
<a name="1526"><span class="lineNum">    1526 </span>            :         rotation_matrix[1][2] = -sinB*cosA;</a>
<a name="1527"><span class="lineNum">    1527 </span>            :         rotation_matrix[2][0] = sinC*sinB;</a>
<a name="1528"><span class="lineNum">    1528 </span>            :         rotation_matrix[2][1] = cosC*sinB;</a>
<a name="1529"><span class="lineNum">    1529 </span>            :         rotation_matrix[2][2] = cosB;</a>
<a name="1530"><span class="lineNum">    1530 </span>            : </a>
<a name="1531"><span class="lineNum">    1531 </span>            :         return;</a>
<a name="1532"><span class="lineNum">    1532 </span>            :     }</a>
<a name="1533"><span class="lineNum">    1533 </span>            : </a>
<a name="1534"><span class="lineNum">    1534 </span>            :     static inline void GetEulerAngles(const double rotation_matrix[3][3], array_1d&lt;double, 3 &gt; &amp; EulerAngles)</a>
<a name="1535"><span class="lineNum">    1535 </span>            :     {</a>
<a name="1536"><span class="lineNum">    1536 </span>            :         if (rotation_matrix[2][2] &lt; 1.0)</a>
<a name="1537"><span class="lineNum">    1537 </span>            :         {</a>
<a name="1538"><span class="lineNum">    1538 </span>            :             if (rotation_matrix[2][2] &gt; -1.0) {</a>
<a name="1539"><span class="lineNum">    1539 </span>            :                 EulerAngles[0] = atan2(rotation_matrix[0][2], -rotation_matrix[1][2]);</a>
<a name="1540"><span class="lineNum">    1540 </span>            :                 EulerAngles[1] = acos(rotation_matrix[2][2]);</a>
<a name="1541"><span class="lineNum">    1541 </span>            :                 EulerAngles[2] = atan2(rotation_matrix[2][0], rotation_matrix[2][1]);</a>
<a name="1542"><span class="lineNum">    1542 </span>            :             }</a>
<a name="1543"><span class="lineNum">    1543 </span>            :             else // r22 = -1</a>
<a name="1544"><span class="lineNum">    1544 </span>            :             {</a>
<a name="1545"><span class="lineNum">    1545 </span>            :                 // Not a unique solution: thetaZ1 - thetaZ0 = atan2(-r01,r00)</a>
<a name="1546"><span class="lineNum">    1546 </span>            :                 EulerAngles[0] = -atan2(-rotation_matrix[0][1], rotation_matrix[0][0]);</a>
<a name="1547"><span class="lineNum">    1547 </span>            :                 EulerAngles[1] = Globals::Pi;</a>
<a name="1548"><span class="lineNum">    1548 </span>            :                 EulerAngles[2] = 0;</a>
<a name="1549"><span class="lineNum">    1549 </span>            :             }</a>
<a name="1550"><span class="lineNum">    1550 </span>            :         }</a>
<a name="1551"><span class="lineNum">    1551 </span>            :         else // r22 = +1</a>
<a name="1552"><span class="lineNum">    1552 </span>            :         {</a>
<a name="1553"><span class="lineNum">    1553 </span>            :             // Not a unique solution: thetaZ1 + thetaZ0 = atan2(-r01,r00)</a>
<a name="1554"><span class="lineNum">    1554 </span>            :             EulerAngles[0] = atan2(-rotation_matrix[0][1], rotation_matrix[0][0]);</a>
<a name="1555"><span class="lineNum">    1555 </span>            :             EulerAngles[1] = 0;</a>
<a name="1556"><span class="lineNum">    1556 </span>            :             EulerAngles[2] = 0;</a>
<a name="1557"><span class="lineNum">    1557 </span>            :         }</a>
<a name="1558"><span class="lineNum">    1558 </span>            : </a>
<a name="1559"><span class="lineNum">    1559 </span>            :         return;</a>
<a name="1560"><span class="lineNum">    1560 </span>            :     }</a>
<a name="1561"><span class="lineNum">    1561 </span>            : </a>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     static inline void GetGiDEulerAngles(const BoundedMatrix&lt;double, 3, 3&gt;&amp; rotation_matrix, array_1d&lt;double, 3&gt;&amp; EulerAngles) {</span></a>
<a name="1563"><span class="lineNum">    1563 </span>            :         const double numerical_limit = std::numeric_limits&lt;double&gt;::epsilon();</a>
<a name="1564"><span class="lineNum">    1564 </span>            :         const double two_pi = 3.1415926535897932384626433 * 2.0;</a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         if(rotation_matrix(2, 2)&lt;1.0-numerical_limit &amp;&amp; rotation_matrix(2, 2)&gt;-1.0+numerical_limit){</span></a>
<a name="1566"><span class="lineNum">    1566 </span><span class="lineNoCov">          0 :             const double senb=sqrt(1.0-rotation_matrix(2, 2)*rotation_matrix(2, 2));</span></a>
<a name="1567"><span class="lineNum">    1567 </span><span class="lineNoCov">          0 :             EulerAngles[1]=acos(rotation_matrix(2, 2));</span></a>
<a name="1568"><span class="lineNum">    1568 </span><span class="lineNoCov">          0 :             EulerAngles[2]=acos(rotation_matrix(1, 2)/senb);</span></a>
<a name="1569"><span class="lineNum">    1569 </span><span class="lineNoCov">          0 :             if(rotation_matrix(0, 2)/senb&lt;0.0) EulerAngles[2]=two_pi - EulerAngles[2];</span></a>
<a name="1570"><span class="lineNum">    1570 </span><span class="lineNoCov">          0 :             EulerAngles[0]=acos(-rotation_matrix(2, 1)/senb);</span></a>
<a name="1571"><span class="lineNum">    1571 </span><span class="lineNoCov">          0 :             if(rotation_matrix(2, 0)/senb&lt;0.0) EulerAngles[0]=two_pi - EulerAngles[0];</span></a>
<a name="1572"><span class="lineNum">    1572 </span>            :         } else {</a>
<a name="1573"><span class="lineNum">    1573 </span>            :             // fixed a=0.0 (arbitrary)</a>
<a name="1574"><span class="lineNum">    1574 </span><span class="lineNoCov">          0 :             EulerAngles[1]=acos(rotation_matrix(2, 2));</span></a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineNoCov">          0 :             EulerAngles[0]=0.0;</span></a>
<a name="1576"><span class="lineNum">    1576 </span><span class="lineNoCov">          0 :             EulerAngles[2]=acos(rotation_matrix(0, 0));</span></a>
<a name="1577"><span class="lineNum">    1577 </span><span class="lineNoCov">          0 :             if(-rotation_matrix(1, 0)&lt;0.0) EulerAngles[2]=two_pi - EulerAngles[2];</span></a>
<a name="1578"><span class="lineNum">    1578 </span>            :         }</a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1580"><span class="lineNum">    1580 </span>            : </a>
<a name="1581"><span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     inline void QuaternionToGiDEulerAngles(const Quaternion&lt;double&gt;&amp; quaternion, array_1d&lt;double, 3&gt;&amp; EulerAngles) {</span></a>
<a name="1582"><span class="lineNum">    1582 </span>            :         BoundedMatrix&lt;double, 3, 3&gt; rotation_matrix = ZeroMatrix(3,3);</a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineNoCov">          0 :         quaternion.ToRotationMatrix(rotation_matrix);</span></a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineNoCov">          0 :         GetGiDEulerAngles(rotation_matrix, EulerAngles);</span></a>
<a name="1585"><span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1586"><span class="lineNum">    1586 </span>            : </a>
<a name="1587"><span class="lineNum">    1587 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1588"><span class="lineNum">    1588 </span>            :     ///////////////****************************TRIANGLE - SPHERE INTERSECTION AREA CALCULATION**************************///////////</a>
<a name="1589"><span class="lineNum">    1589 </span>            :     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</a>
<a name="1590"><span class="lineNum">    1590 </span>            : </a>
<a name="1591"><span class="lineNum">    1591 </span>            :     static inline void TriAngleArea(double Coord1[3], double Coord2[3], double Coord3[3], double&amp; area)</a>
<a name="1592"><span class="lineNum">    1592 </span>            :     {</a>
<a name="1593"><span class="lineNum">    1593 </span>            :         int k;</a>
<a name="1594"><span class="lineNum">    1594 </span>            :         double Vector1[3],Vector2[3],Vector0[3];</a>
<a name="1595"><span class="lineNum">    1595 </span>            :         for (k = 0;k &lt; 3; k++)</a>
<a name="1596"><span class="lineNum">    1596 </span>            :         {</a>
<a name="1597"><span class="lineNum">    1597 </span>            :             Vector1[k] = Coord3[k] - Coord1[k];</a>
<a name="1598"><span class="lineNum">    1598 </span>            :             Vector2[k] = Coord2[k] - Coord1[k];</a>
<a name="1599"><span class="lineNum">    1599 </span>            :         }</a>
<a name="1600"><span class="lineNum">    1600 </span>            : </a>
<a name="1601"><span class="lineNum">    1601 </span>            :         CrossProduct(Vector1, Vector2, Vector0);</a>
<a name="1602"><span class="lineNum">    1602 </span>            :         area = 0.5 * DEM_MODULUS_3(Vector0);</a>
<a name="1603"><span class="lineNum">    1603 </span>            :     }</a>
<a name="1604"><span class="lineNum">    1604 </span>            : </a>
<a name="1605"><span class="lineNum">    1605 </span>            :     //TriAngle Weight, coord1,coord2,coord3,testcoord,weight</a>
<a name="1606"><span class="lineNum">    1606 </span>            :     static inline void TriAngleWeight(double Coord1[3], double Coord2[3], double Coord3[3], double JudgeCoord[3], double Weight[3])</a>
<a name="1607"><span class="lineNum">    1607 </span>            :     {</a>
<a name="1608"><span class="lineNum">    1608 </span>            :         double area[3], s;</a>
<a name="1609"><span class="lineNum">    1609 </span>            :         TriAngleArea(Coord1, Coord2, JudgeCoord, area[0]);</a>
<a name="1610"><span class="lineNum">    1610 </span>            :         TriAngleArea(Coord2, Coord3, JudgeCoord, area[1]);</a>
<a name="1611"><span class="lineNum">    1611 </span>            :         TriAngleArea(Coord3, Coord1, JudgeCoord, area[2]);</a>
<a name="1612"><span class="lineNum">    1612 </span>            : </a>
<a name="1613"><span class="lineNum">    1613 </span>            :         TriAngleArea(Coord1, Coord2, Coord3, s);</a>
<a name="1614"><span class="lineNum">    1614 </span>            :         /////s = area[0] + area[1] + area[2];</a>
<a name="1615"><span class="lineNum">    1615 </span>            :         const double s_inv = 1.0 / s;</a>
<a name="1616"><span class="lineNum">    1616 </span>            :         Weight[0] = area[1] * s_inv;</a>
<a name="1617"><span class="lineNum">    1617 </span>            :         Weight[1] = area[2] * s_inv;</a>
<a name="1618"><span class="lineNum">    1618 </span>            :         Weight[2] = area[0] * s_inv;</a>
<a name="1619"><span class="lineNum">    1619 </span>            :     }</a>
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<a name="1621"><span class="lineNum">    1621 </span>            :     //Quadrilatera Weight, coord1,coord2,coord3,testcoord,weight (Paper Zhang)</a>
<a name="1622"><span class="lineNum">    1622 </span>            :     static inline void QuadAngleWeight(double Coord1[3], double Coord2[3], double Coord3[3], double Coord4[3], double JudgeCoord[3], double Weight[4])</a>
<a name="1623"><span class="lineNum">    1623 </span>            :     {</a>
<a name="1624"><span class="lineNum">    1624 </span>            :         double area[4], s1, s2, s;</a>
<a name="1625"><span class="lineNum">    1625 </span>            :         TriAngleArea(Coord1, Coord2, JudgeCoord, area[0]);</a>
<a name="1626"><span class="lineNum">    1626 </span>            :         TriAngleArea(Coord2, Coord3, JudgeCoord, area[1]);</a>
<a name="1627"><span class="lineNum">    1627 </span>            :         TriAngleArea(Coord3, Coord4, JudgeCoord, area[2]);</a>
<a name="1628"><span class="lineNum">    1628 </span>            :         TriAngleArea(Coord4, Coord1, JudgeCoord, area[3]);</a>
<a name="1629"><span class="lineNum">    1629 </span>            : </a>
<a name="1630"><span class="lineNum">    1630 </span>            :         TriAngleArea(Coord1, Coord2, Coord3, s1);//msimsi</a>
<a name="1631"><span class="lineNum">    1631 </span>            :         TriAngleArea(Coord1, Coord3, Coord4, s2);//msimsi</a>
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<a name="1633"><span class="lineNum">    1633 </span>            :         s = s1 + s2;</a>
<a name="1634"><span class="lineNum">    1634 </span>            : </a>
<a name="1635"><span class="lineNum">    1635 </span>            :         if (fabs(area[0] + area[1] + area[2] + area[3] - s) &lt; 1.0e-15) //msimsi</a>
<a name="1636"><span class="lineNum">    1636 </span>            :         {</a>
<a name="1637"><span class="lineNum">    1637 </span>            :             double QuadNormArea = 1 / ((area[0] + area[2]) * (area[1] + area[3]));</a>
<a name="1638"><span class="lineNum">    1638 </span>            : </a>
<a name="1639"><span class="lineNum">    1639 </span>            :             Weight[0] = (area[1] * area[2]) * QuadNormArea;</a>
<a name="1640"><span class="lineNum">    1640 </span>            :             Weight[1] = (area[2] * area[3]) * QuadNormArea;</a>
<a name="1641"><span class="lineNum">    1641 </span>            :             Weight[2] = (area[3] * area[0]) * QuadNormArea;</a>
<a name="1642"><span class="lineNum">    1642 </span>            :             Weight[3] = (area[0] * area[1]) * QuadNormArea;</a>
<a name="1643"><span class="lineNum">    1643 </span>            :         }</a>
<a name="1644"><span class="lineNum">    1644 </span>            :     }</a>
<a name="1645"><span class="lineNum">    1645 </span>            : </a>
<a name="1646"><span class="lineNum">    1646 </span>            :     static inline void AreaAndCentroidCircularSector(double C[3], double Radius, double P1[3], double P2[3], double Normal[3], double&amp; Area, double CoMSC[3])</a>
<a name="1647"><span class="lineNum">    1647 </span>            :     {</a>
<a name="1648"><span class="lineNum">    1648 </span>            :         double a[3]           = {0.0};</a>
<a name="1649"><span class="lineNum">    1649 </span>            :         double c[3]           = {0.0};</a>
<a name="1650"><span class="lineNum">    1650 </span>            :         double bisection[3]   = {0.0};</a>
<a name="1651"><span class="lineNum">    1651 </span>            :         double norm_a         = 0.0;</a>
<a name="1652"><span class="lineNum">    1652 </span>            : </a>
<a name="1653"><span class="lineNum">    1653 </span>            :         for (unsigned int index = 0;index&lt;3;index++) {</a>
<a name="1654"><span class="lineNum">    1654 </span>            : </a>
<a name="1655"><span class="lineNum">    1655 </span>            :             a[index] = P1[index]-C[index];</a>
<a name="1656"><span class="lineNum">    1656 </span>            :             c[index] = P2[index]-P1[index];</a>
<a name="1657"><span class="lineNum">    1657 </span>            : </a>
<a name="1658"><span class="lineNum">    1658 </span>            :         }</a>
<a name="1659"><span class="lineNum">    1659 </span>            : </a>
<a name="1660"><span class="lineNum">    1660 </span>            :         CrossProduct(Normal,c,bisection);</a>
<a name="1661"><span class="lineNum">    1661 </span>            :         normalize(bisection);</a>
<a name="1662"><span class="lineNum">    1662 </span>            :         double dot_product = DotProduct(bisection,a);</a>
<a name="1663"><span class="lineNum">    1663 </span>            : </a>
<a name="1664"><span class="lineNum">    1664 </span>            :         if (dot_product&lt;0.0) {</a>
<a name="1665"><span class="lineNum">    1665 </span>            : </a>
<a name="1666"><span class="lineNum">    1666 </span>            :             for (unsigned int index = 0;index&lt;3;index++) {</a>
<a name="1667"><span class="lineNum">    1667 </span>            : </a>
<a name="1668"><span class="lineNum">    1668 </span>            :                 bisection[index] = -bisection[index];</a>
<a name="1669"><span class="lineNum">    1669 </span>            :             }</a>
<a name="1670"><span class="lineNum">    1670 </span>            : </a>
<a name="1671"><span class="lineNum">    1671 </span>            :             dot_product = -dot_product;</a>
<a name="1672"><span class="lineNum">    1672 </span>            :         }</a>
<a name="1673"><span class="lineNum">    1673 </span>            : </a>
<a name="1674"><span class="lineNum">    1674 </span>            :         module(a, norm_a);</a>
<a name="1675"><span class="lineNum">    1675 </span>            : </a>
<a name="1676"><span class="lineNum">    1676 </span>            :         double cos_alpha = dot_product/norm_a;</a>
<a name="1677"><span class="lineNum">    1677 </span>            :         double alpha = acos(cos_alpha);</a>
<a name="1678"><span class="lineNum">    1678 </span>            :         double sin_alpha = std::sin(alpha);</a>
<a name="1679"><span class="lineNum">    1679 </span>            : </a>
<a name="1680"><span class="lineNum">    1680 </span>            :         Area = Radius*Radius*alpha;</a>
<a name="1681"><span class="lineNum">    1681 </span>            :         double dist = 0.66666666666666*(Radius*sin_alpha/alpha);</a>
<a name="1682"><span class="lineNum">    1682 </span>            :         for (unsigned int index = 0;index&lt;3;index++) {</a>
<a name="1683"><span class="lineNum">    1683 </span>            :             CoMSC[index] = C[index]+dist*bisection[index];</a>
<a name="1684"><span class="lineNum">    1684 </span>            :         }</a>
<a name="1685"><span class="lineNum">    1685 </span>            : </a>
<a name="1686"><span class="lineNum">    1686 </span>            :     }//AreaCircularSector</a>
<a name="1687"><span class="lineNum">    1687 </span>            : </a>
<a name="1688"><span class="lineNum">    1688 </span>            :     static inline void AlternativeAreaCircularSegment(double Radius, double tol_Radius, double V0V1[3], double V0CC[3], double Normal[3], double&amp; AreaSC, bool&amp; flag)</a>
<a name="1689"><span class="lineNum">    1689 </span>            :     {</a>
<a name="1690"><span class="lineNum">    1690 </span>            : </a>
<a name="1691"><span class="lineNum">    1691 </span>            :         double normal_outwards[3] = {0.0};</a>
<a name="1692"><span class="lineNum">    1692 </span>            :         flag = false;</a>
<a name="1693"><span class="lineNum">    1693 </span>            :         AreaSC = 0.0;</a>
<a name="1694"><span class="lineNum">    1694 </span>            : </a>
<a name="1695"><span class="lineNum">    1695 </span>            :         CrossProduct(V0V1, Normal, normal_outwards);</a>
<a name="1696"><span class="lineNum">    1696 </span>            :         normalize(normal_outwards);</a>
<a name="1697"><span class="lineNum">    1697 </span>            : </a>
<a name="1698"><span class="lineNum">    1698 </span>            :         double dist = DotProduct(normal_outwards,V0CC);</a>
<a name="1699"><span class="lineNum">    1699 </span>            :         double delta_circle = Radius + dist; //distance can be positive or negative, depending on the side where the circle is</a>
<a name="1700"><span class="lineNum">    1700 </span>            : </a>
<a name="1701"><span class="lineNum">    1701 </span>            :         if ((delta_circle &gt; tol_Radius) &amp;&amp; (delta_circle - 2*Radius &lt; -tol_Radius)) {//check for intersection</a>
<a name="1702"><span class="lineNum">    1702 </span>            : </a>
<a name="1703"><span class="lineNum">    1703 </span>            :             flag = true;</a>
<a name="1704"><span class="lineNum">    1704 </span>            :             double b = sqrt(delta_circle*(2*Radius-delta_circle));</a>
<a name="1705"><span class="lineNum">    1705 </span>            :             AreaSC   = 2.0*Radius*Radius*atan(delta_circle/b)-b*(Radius-delta_circle);</a>
<a name="1706"><span class="lineNum">    1706 </span>            :         }</a>
<a name="1707"><span class="lineNum">    1707 </span>            :     }//AreaAndCentroidCircularSector1</a>
<a name="1708"><span class="lineNum">    1708 </span>            : </a>
<a name="1709"><span class="lineNum">    1709 </span>            :     static inline void AreaAndCentroidCircularSegment(double Centre[3], double Radius, double tol_Radius, double V0[3], double V1[3], double Normal[3], double&amp; AreaSegC, double CoMSegC[3], bool&amp; flag)</a>
<a name="1710"><span class="lineNum">    1710 </span>            :     {</a>
<a name="1711"><span class="lineNum">    1711 </span>            :         double V0V1[3]            = {0.0};</a>
<a name="1712"><span class="lineNum">    1712 </span>            :         double V0CC[3]            = {0.0};</a>
<a name="1713"><span class="lineNum">    1713 </span>            :         double a[3]               = {0.0};</a>
<a name="1714"><span class="lineNum">    1714 </span>            :         double normal_outwards[3] = {0.0};</a>
<a name="1715"><span class="lineNum">    1715 </span>            :         double Radius_SQ          = 0.0;</a>
<a name="1716"><span class="lineNum">    1716 </span>            :         double distance_V0V1      = 0.0;</a>
<a name="1717"><span class="lineNum">    1717 </span>            :         double dist_CoM           = 0.0;</a>
<a name="1718"><span class="lineNum">    1718 </span>            :         AreaSegC                  = 0.0;</a>
<a name="1719"><span class="lineNum">    1719 </span>            :         flag = false;</a>
<a name="1720"><span class="lineNum">    1720 </span>            : </a>
<a name="1721"><span class="lineNum">    1721 </span>            :         for (unsigned int index = 0; index&lt;3; index++) {</a>
<a name="1722"><span class="lineNum">    1722 </span>            : </a>
<a name="1723"><span class="lineNum">    1723 </span>            :             V0V1[index]     = V1[index] - V0[index];</a>
<a name="1724"><span class="lineNum">    1724 </span>            :             V0CC[index]     = Centre[index] - V0[index];</a>
<a name="1725"><span class="lineNum">    1725 </span>            :         }</a>
<a name="1726"><span class="lineNum">    1726 </span>            : </a>
<a name="1727"><span class="lineNum">    1727 </span>            :         GeometryFunctions::CrossProduct(V0V1,Normal,normal_outwards);</a>
<a name="1728"><span class="lineNum">    1728 </span>            :         GeometryFunctions::normalize(V0V1,distance_V0V1);</a>
<a name="1729"><span class="lineNum">    1729 </span>            : </a>
<a name="1730"><span class="lineNum">    1730 </span>            :         double distV0 =  GeometryFunctions::DotProduct(V0CC,V0V1);</a>
<a name="1731"><span class="lineNum">    1731 </span>            : </a>
<a name="1732"><span class="lineNum">    1732 </span>            :         if ((distV0 &gt; 0.0) &amp;&amp; (distV0 &lt; distance_V0V1)) {</a>
<a name="1733"><span class="lineNum">    1733 </span>            : </a>
<a name="1734"><span class="lineNum">    1734 </span>            :             GeometryFunctions::normalize(normal_outwards);</a>
<a name="1735"><span class="lineNum">    1735 </span>            :             double dist_normal   = GeometryFunctions::DotProduct(normal_outwards,V0CC);</a>
<a name="1736"><span class="lineNum">    1736 </span>            :             double delta_circle  = Radius + dist_normal; //distance can be positive or negative, depending on the side where the circle is</a>
<a name="1737"><span class="lineNum">    1737 </span>            : </a>
<a name="1738"><span class="lineNum">    1738 </span>            :             if ((delta_circle &gt; tol_Radius) &amp;&amp; ( delta_circle - 2.0*Radius &lt; -tol_Radius)) {//check for intersection</a>
<a name="1739"><span class="lineNum">    1739 </span>            : </a>
<a name="1740"><span class="lineNum">    1740 </span>            :                 Radius_SQ = Radius*Radius;</a>
<a name="1741"><span class="lineNum">    1741 </span>            :                 double semi_dist = sqrt(Radius_SQ - dist_normal*dist_normal);</a>
<a name="1742"><span class="lineNum">    1742 </span>            :                 flag = true;</a>
<a name="1743"><span class="lineNum">    1743 </span>            : </a>
<a name="1744"><span class="lineNum">    1744 </span>            :                 for (unsigned int index = 0;index&lt;3;index++) {</a>
<a name="1745"><span class="lineNum">    1745 </span>            : </a>
<a name="1746"><span class="lineNum">    1746 </span>            :                     a[index] = V0[index] + (distV0 - semi_dist)*V0V1[index] - Centre[index]; //Vector from Center to first intersection point</a>
<a name="1747"><span class="lineNum">    1747 </span>            :                 }</a>
<a name="1748"><span class="lineNum">    1748 </span>            : </a>
<a name="1749"><span class="lineNum">    1749 </span>            :                 double cos_alpha = GeometryFunctions::DotProduct(a,normal_outwards)/(GeometryFunctions::module(a)*GeometryFunctions::module(normal_outwards));</a>
<a name="1750"><span class="lineNum">    1750 </span>            :                 double alpha = acos(cos_alpha);</a>
<a name="1751"><span class="lineNum">    1751 </span>            :                 double sin_alpha = std::sin(alpha);</a>
<a name="1752"><span class="lineNum">    1752 </span>            : </a>
<a name="1753"><span class="lineNum">    1753 </span>            :                 AreaSegC = Radius_SQ*(alpha-sin_alpha*cos_alpha);</a>
<a name="1754"><span class="lineNum">    1754 </span>            : </a>
<a name="1755"><span class="lineNum">    1755 </span>            :                 if (fabs(sin_alpha) &lt; tol_Radius) {dist_CoM=0.0;}</a>
<a name="1756"><span class="lineNum">    1756 </span>            : </a>
<a name="1757"><span class="lineNum">    1757 </span>            :                 else {dist_CoM = 0.6666666666666 * (Radius*sin_alpha*sin_alpha*sin_alpha/(alpha-sin_alpha*cos_alpha));}</a>
<a name="1758"><span class="lineNum">    1758 </span>            : </a>
<a name="1759"><span class="lineNum">    1759 </span>            :                 for (unsigned int index = 0; index&lt;3; index++) {</a>
<a name="1760"><span class="lineNum">    1760 </span>            :                     CoMSegC[index] = Centre[index] + dist_CoM*normal_outwards[index];</a>
<a name="1761"><span class="lineNum">    1761 </span>            :                 }</a>
<a name="1762"><span class="lineNum">    1762 </span>            :             } //if normal dist is okay</a>
<a name="1763"><span class="lineNum">    1763 </span>            : </a>
<a name="1764"><span class="lineNum">    1764 </span>            :         } // if longitudinal dist is okay</a>
<a name="1765"><span class="lineNum">    1765 </span>            : </a>
<a name="1766"><span class="lineNum">    1766 </span>            :     }//AreaAndCentroidCircularSegment</a>
<a name="1767"><span class="lineNum">    1767 </span>            : </a>
<a name="1768"><span class="lineNum">    1768 </span>            :     static inline void AreaAndCentroidTriangle(double Coord1[3], double Coord2[3], double Coord3[3], double&amp; area, double CoMTri[3]) {</a>
<a name="1769"><span class="lineNum">    1769 </span>            : </a>
<a name="1770"><span class="lineNum">    1770 </span>            :         TriAngleArea(Coord1,Coord2,Coord3,area);</a>
<a name="1771"><span class="lineNum">    1771 </span>            : </a>
<a name="1772"><span class="lineNum">    1772 </span>            :         for (unsigned int index =0; index&lt;3; index++) {</a>
<a name="1773"><span class="lineNum">    1773 </span>            : </a>
<a name="1774"><span class="lineNum">    1774 </span>            :             CoMTri[index] = 0.33333333333333 * (Coord1[index]+Coord2[index]+Coord3[index]);</a>
<a name="1775"><span class="lineNum">    1775 </span>            :             }</a>
<a name="1776"><span class="lineNum">    1776 </span>            : </a>
<a name="1777"><span class="lineNum">    1777 </span>            :         } //AreaAndCentroidTriangle</a>
<a name="1778"><span class="lineNum">    1778 </span>            : </a>
<a name="1779"><span class="lineNum">    1779 </span>            :     } //namespace GeometryFunctions</a>
<a name="1780"><span class="lineNum">    1780 </span>            : </a>
<a name="1781"><span class="lineNum">    1781 </span>            : } //namespace Kratos</a>
<a name="1782"><span class="lineNum">    1782 </span>            : </a>
<a name="1783"><span class="lineNum">    1783 </span>            : #endif  /* _GEOMETRYFUNCTIONS_H */</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
